<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>谈谈如何学习Linux内核</title>
      <link href="/posts/382a00c7/"/>
      <url>/posts/382a00c7/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="https://zhuanlan.zhihu.com/p/252708081">谈谈如何学习Linux内核</a></p><h1 id="谈谈如何学习Linux内核"><a href="#谈谈如何学习Linux内核" class="headerlink" title="谈谈如何学习Linux内核"></a>谈谈如何学习Linux内核</h1><p>学习内核的好处很多，在学习过程中不仅可以夯实大量理论基础，还可以学习到很多编码惯用法，提升学习能力和分析能力。</p><h2 id="确立高度，明确目标"><a href="#确立高度，明确目标" class="headerlink" title="确立高度，明确目标"></a>确立高度，明确目标</h2><h3 id="高度决定视角，视角决定行动"><a href="#高度决定视角，视角决定行动" class="headerlink" title="高度决定视角，视角决定行动"></a>高度决定视角，视角决定行动</h3><p>在学习内核过程中最容易犯的错误，也是非常难掌握的其实是你站在一个什么样的高度上去学习。站什么样的高度去学习也与自身的能力相关，所以这个问题其实更多是在新开始学习的学习者感到非常痛苦的一件事。一方面又希望自己能学懂，但是又不知道如何开始入手。</p><p>我列举几个常见的例子：</p><p>(1) 一开始就看源码，最开始我也做过这种事，内核有什么都不知道，结果就想着啃0.11的内核，结果很显然，2天立马放弃，完全看不懂。</p><p>(2) 翻开书从第一页开始往下啃，如果这本书比较薄还好，如果比较厚，比如《深入Linux内核架构》，那看2天也得放弃。</p><p>(3) 不喜欢看目录，不喜欢快速浏览，就想着一个一个字眼的往下抠。如果本身有一定基础，看的时候还不会觉得腻，但是很快就发现，看了半天，什么都没有记住。</p><p>还有很多类似的问题，这些都是我们平时学习的时候特别容易出现的一些误区。这些其实都是没有正确审视自己的能力，胡乱挑选高度导致。</p><h3 id="高度是什么"><a href="#高度是什么" class="headerlink" title="高度是什么?"></a>高度是什么?</h3><p><strong>高度越高，也就是越偏向于理解各种抽象概念，倾向于构建对整体结构的一个认知，忽略一些不必要细节，不关心技术实现手段。</strong></p><p><strong>高度越低，也就是越偏向于对使用技术的选择，倾向于代码实现的各个细节，但是前提一般会在某个抽象的概念领域内进行各种细节性的讨论。</strong></p><p>我们的大脑更倾向于理解抽象的内容，但是在行动时，我们却更倾向于去把握细节性的内容。结果导致的内容就是，我们总是希望通过学习细节来构造对抽象概念的理解，最后被细节性内容中各种噪声干扰思绪，产生一种“这东西好难”的错觉。在理解了这点，那高度对我们的行为有和指导意义也就呼之欲出了?<br>以读书为例。<strong>站的越高，</strong>意味着自己看的内容越粗糙，也就是看书的时候不会去逐字逐句的看，而是一个章节一个章节的看，极端的情况就是只看目录，在这个过程中主要集中精力构建整体结构，对核心的概念进行抽象。这时候学的内容都相对表面，但是好处就是对以后的学习有很强的指导意义，缺点很明显，会让人底气不足，而且在达到一定程度后，很容易到达瓶颈，发觉怎么看都看不懂了。<strong>站的越低，</strong>意味着自己看的内容很细致，看书的时候就是一个个字眼的扣，极端情况就是开始阅读源码，去看开源社区的各种问题。但是就像诗句说的，站的越低，也就常有一种“不识庐山真面目，只缘身在此山中”的感觉。这种情况下特别容易被各种细节干扰，例如为什么要有这些参数，为什么这里需要判断这个条件等等这些细枝末节的问题。</p><h3 id="如何运用高度"><a href="#如何运用高度" class="headerlink" title="如何运用高度"></a>如何运用高度</h3><p>以前对一篇博文印象很深刻，作者理解的学习曲线划分成了两个比较大的过程，上升的过程就是一个不断学习积累的过程，而平缓没有增长的过程则是对之前积累到饱和的知识进行消化的过程。我将这个学习过程进行进一步的划分，我觉得在学习积累的<strong>前半部分应该以</strong>偏向学习抽象概念为主，而<strong>后半部分应该</strong>偏向学习实现细节。</p><p><img src="https://pic3.zhimg.com/80/v2-d4bb4253e9d2cd98f2e223dee8ae06be_1440w.webp" alt="img"></p><p>所以个人的心得是从高到低的学习，在一个新的学习阶段，应该先多花点时间学习一些概念化的内容，这时候切忌去看具体的实现，而是多考虑如何在大脑中构建各种抽象模型</p><p>对整体的架构有所概念了，然后开始学习一些细节性的内容，比如开始看些源码，抠写书上的字眼，读读一些具体的博客什么的。</p><h2 id="学习小Tips"><a href="#学习小Tips" class="headerlink" title="学习小Tips"></a>学习小Tips</h2><h3 id="如何看书"><a href="#如何看书" class="headerlink" title="如何看书"></a>如何看书</h3><p><strong>不要从第一页开始翻 不要一页一页的翻</strong></p><ul><li>花些时间看看前言，在很多书的前言部分，作者会告诉你，整本书的结构应该是什么样，应该要以什么样的顺序去阅读，在阅读的时候应该站在什么样的角度去阅读，这是作者的建议，有什么比作者的建议更值得我们听取呢!?</li><li>不要寄希望与一次看懂一本书，越是好的书越是要反复的看，但是很多人对这个反复理解有问题，认为反复的看就是一页页翻，重复看几遍。其实不是这样，每次反复应该让自己换一个高度，第一次翻的时候可以站在很高的高度，看一本书甚至只需要1天的时间，重复几次后，站的高度应该越低，很可能看一个章节需要1天时间，甚至有时候看一页就需要1天的时间。</li><li>一本书的目录就像你在沙漠中的指南针，不要忽略目录的作用。每次翻开书，在决定自己看什么之前，花点时间浏览下目录，让自己回忆(了解)要看的章节的架构，带着这个结构去学习事半功倍。</li><li>带着问题去看书，这点很难，因为提什么样的问题和你选择的高度密切相关，站的高度越高，那就越不要给自己提一些细节性的问题，反之则反之。</li></ul><h3 id="如何看代码"><a href="#如何看代码" class="headerlink" title="如何看代码"></a>如何看代码</h3><p>如果开始看代码，一定要记住，<strong>自己已经站在一个非常底层的高度度了</strong>，能够有能力阅读代码，就意味着你必须对整体的结构有比较清晰的认识，如果你都不知道这个结构，那看代码为时太早。</p><p>无论是什么样的代码，其实思路都很类似，即使Linux内核是用C这种面相过程的语言编写，但是这么多年发展下来，Linux内核已经带有了大量面对对象编程的特点。</p><p>在看代码的时候也是有两种不同的高度可以选择，我先解释其中最细致的一种：</p><h4 id="如何阅读函数"><a href="#如何阅读函数" class="headerlink" title="如何阅读函数"></a>如何阅读函数</h4><p>一个函数写下来经常上百行，但是你需要一行一行的看么?肯定不能，那清晰认识一个函数的结构就很重要。</p><p>一个函数就是为了解决一个问题，函数名基本都能说明其功能，函数参数是输入，返回值就是输出，函数体就是整体的执行逻辑。在函数体内部，也基本都是类似的逻辑，先是对各种输入参数进行检查，然后书写功能逻辑，然后构造输出的结果。所以一个函数写下来总是这样的一种结构。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">输出结果 函数名(输入)<br>{<br>    <span class="hljs-keyword">if</span> (输入的参数有问题)<br>    {<br>    异常处理，跳出<br>    }<br>    准备参数<br>        <br>    功能逻辑<br>        <br>    构造输出结果<br>        <br>    返回输出结果<br>}<br></code></pre></td></tr></tbody></table></figure><p>一个函数其实就是一个方法，阅读的难度比书写的难度要低，书写代码需要考虑的问题非常多，但是在阅读代码的时候问题就简单很多，很多书写代码过程中需要考虑的问题在阅读代码的过程中就不需要考虑 。</p><ul><li>函数名：在书写代码过程中需要考虑一个函数的函数名需要能够精确表达出这个函数所具备的功能，所以经常存在各种名目规范。而阅读代码过程则可以通过阅读函数名大致了解这个函数的功能。</li><li>注释：在编写代码的时候，都会建议添加对应的函数注释，解释函数体的功能和一些注意事项；在阅读过程中可以选择性的阅读这些注释(注意：是选择性阅读，千万不要每个注释都读)</li><li>输入参数：在书写代码的时候，这部分的内容也是很头疼的内容，不仅需要确定需要哪些输入，还需要输入的形式，而且还需要精确定义每个输入参数的语义；但是在阅读代码的过程中，这部分内容基本可以忽略，我们很少会关系所看到的函数需要哪些参数输入。</li><li>输出结果：在书写代码的时候，这部分也是很头疼的一件事，因为精确定义输出结果也是非常困难和麻烦的一件事；在阅读代码过程中，也需要注意输出结果，不然一个函数执行了老半天，结果连输出结果是什么都没概念，也太失败了点。</li><li>参数检测：在编写代码过着中非常烦的一件事，每个人都希望调用函数的人会传入正确的参数，但是根本做不到，结果每次都要花费一定精力对输入参数的边界、非空等进行检查；在阅读代码过程中，根本不需要阅读这部分的代码，恰恰这部分内容在每个函数体中占据了相当一部分的位置；</li><li>参数准备：编写代码的过程中，因为函数体内部的逻辑需要进行很多准备，所以常常需要有一个参数准备的过程；而阅读代码的过程基本可以忽略这部分的逻辑，或者快速浏览这部分逻辑，这里恰恰是很多新手花费大量精力纠缠的内容，其实没必要在这里纠结，跳过就好。</li><li>功能逻辑：这部分是函数体中最为精华的部分，而且代码编写起来也是相当的麻烦，被各种逻辑弄的死去火来，最后还需要重构等等手段；在阅读代码过程中，这部分其实很难把握，因为功能逻辑可能被封装在另外一个函数内部，这时候大家会习惯性的继续深入看，结果弄的自己更加混乱，又比如有的时候几个功能逻辑点组成了一套逻辑，但是大家却将这部分逻辑割裂来看，结果总感觉读的很别扭。这部分内容需要一些经验，但是有一个指导，就是在看这部分代码的时候要注意自己所站的高度，选择采用何种策略。</li><li>构造输出结果：函数体内部还会花费大量的代码进行对最后返回结果的构造工作，就像搭积木一样；不过在阅读代码的时候，我们并不需要花费太多精力在这些逻辑上，多注意注意一些返回结果的语义。</li></ul><p>阅读代码还有很多技巧，例如如何在带有goto语句的代码中快速理解逻辑，如何界定那些注释是可以忽略的，如何将一些代码逻辑看成一块整体内容，何时应该跳到更深的一层函数阅读等等。这些都需要平时的经验积累。</p><h4 id="如何在大量的代码中游刃有余"><a href="#如何在大量的代码中游刃有余" class="headerlink" title="如何在大量的代码中游刃有余"></a>如何在大量的代码中游刃有余</h4><p>看代码有一个粒度问题，我们不能一行一行的看，也不能一个一个函数的看，我之前提到了，Linux内核有大量面向对象编程的影子，所以在看大量代码的时候，必须学会面向对象编程的思维模式。这样对自己在大量代码阅读中提供大量参考意见。</p><p>或许有人会告诉你，面向对象编程就是弄明白什么是对象、如何写一个class就可以了。确实，学习面向对象编程，弄明白对象是基础，不过我觉得可以再拔高一点，理解一些更抽象的概念，在这些抽象概念的指导下去学习，可以有更多的指导意义。</p><ul><li>层：层并不是面向对象编程特有，但是理解层是很重要的，我们遇到的典型的层就是网络协议栈，为什么我们网络协议会有那么多层，就因为需要处理的事情太多，我们不得不将内容一块块的分割，分割的时候，发现用层进行组织，可以让结构更加清晰，所以你以后会发现，大量的系统都会带有层的味道。linux内核中带有大量的层设计，如网络协议栈有层，内存管理与寻址有层，文件I/O也有层。</li><li><strong>领域模型</strong>：领域模型就是一个系统中最为核心的几个抽象实体，一个系统，基本就是围绕着领域模型展开，在学习内核不同的子系统的时候，一定要花大量的精力在领域模型上，切记!!!在Linux内核上也有大量的领域模型，例如在虚拟文件系统部分存在4大抽象inode，dentry，file等。在进程调度系统的最核心抽象是task_struct。在进程地址空间则有mm_struct，address_space等这些核心的领域模型。我感觉可以花费80%的时间在理解这些领域模型上。</li><li>领域驱动类：领域模型内部其实是大量的属性组成，但是如果只有属性，没有一个执行的方法，那这个领域模型也不能发挥作用，面向对象编程的做法就是将这些方法编程领域驱动类，说的直白一些就是接口。在Linux中就是那些函数指针和对应的回调函数。平时看代码，大家会花费大量的时间去看各个回调函数，这个其实是吃力不讨好的办法，与其花大量的心思去看各个回调函数的实现，不如多思考下，为什么会有这些操作方法，它们是如何抽象出来的。</li></ul><p>如果能够理解上述的这几个抽象，那在大量代码中如何游刃有余就相对容易了，有一个简单的套路：<br>(1) 在较高的角度，弄明白一个系统为了解决什么问题，应该有哪些抽象</p><p>(2) 在对整体结构有所了解以后，花心思看看这些抽象对应的领域模型，因为一般情况领域模型很庞大，所以看的时候也需要有步骤的进行拆解学习。</p><p>(3) 在对领域模型有所了解后，开始看领域驱动类，想明白为什么会有这些操作。</p><p>(4) 在上述准备好后，就可以花费一些时间去看各个函数的具体实现，并且在看的过程中多思考领域模型为什么这么设计。</p>]]></content>
      
      
      <categories>
          
          <category> 好文转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker下使用Dokerfile创建image</title>
      <link href="/posts/42edd7ca/"/>
      <url>/posts/42edd7ca/</url>
      
        <content type="html"><![CDATA[<h1 id="docker下使用Dockerfile创建image"><a href="#docker下使用Dockerfile创建image" class="headerlink" title="docker下使用Dockerfile创建image"></a>docker下使用Dockerfile创建image</h1><h2 id="创建-Dockerfile-文件"><a href="#创建-Dockerfile-文件" class="headerlink" title="创建 Dockerfile 文件"></a>创建 Dockerfile 文件</h2><p>文件如下</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用 ubuntu:21.04 作为基板，以下都是在此基础上安装等等</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">21.04</span><br><span class="hljs-comment"># 指定维护者信息</span><br><span class="hljs-keyword">MAINTAINER</span> acoollib&lt;acoollib@gmail.com&gt;<br><span class="hljs-comment"># 运行命令，推荐此方式，但是此方式写起来比较麻烦，后续直接使用另一种方式</span><br><span class="hljs-comment"># 具体查看 参考3链接</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">"/bin/bash"</span>,<span class="hljs-string">"-c"</span>,<span class="hljs-string">"echo hello"</span>]</span><br><span class="hljs-comment"># 添加用户</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd --create-home -u 1000 u</span><br><span class="hljs-comment"># 修改时区</span><br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone</span><br><br><span class="hljs-comment"># 换源</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">'/security.ubuntu.com/d'</span> /etc/apt/sources.list</span><br><br><span class="hljs-comment"># 安装软件</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get install -y repo git ssh make gcc libssl-dev liblz4-tool \</span><br><span class="language-bash">    expect g++ patchelf chrpath gawk texinfo chrpath diffstat binfmt-support \</span><br><span class="language-bash">    qemu-user-static live-build bison flex fakeroot cmake gcc-multilib g++-multilib unzip \</span><br><span class="language-bash">    device-tree-compiler ncurses-dev \</span><br><span class="language-bash">    time \</span><br><span class="language-bash">    openssh-server net-tools</span><br><span class="hljs-comment"># 替换 openssh-server 配置，使其支持root登录</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">'/.*PermitRootLogin*/c\PermitRootLogin yes'</span> /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># 使用创建好的用户</span><br><span class="hljs-keyword">USER</span> u<br><br><span class="hljs-comment"># 工作目录使用 /home/u</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /home/u</span><br><br></code></pre></td></tr></tbody></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p><code>sudo docker build -t test .</code></p><ul><li>build 指定为构建镜像</li><li>-t 指定镜像名为 test</li><li>. 指令构建路径为当前目录，确保Dockerfile在当前目录，并且当前目录没有其它无用文件。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/JAVA_XCNH/article/details/107981610">Docker日常使用</a></li><li><a href="https://blog.csdn.net/qq_38132995/article/details/119380751">Dockerfile文件创建详解(实战)</a></li><li><a href="https://www.cnblogs.com/linjiqin/p/8735230.html">Dockerfile指令详解</a></li><li><a href="https://gonglja.github.io/posts/6c58185/#%E9%85%8D%E7%BD%AEssh%E6%9C%8D%E5%8A%A1">配置ssh服务</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言运算符优先级</title>
      <link href="/posts/b6db5676/"/>
      <url>/posts/b6db5676/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自 <a href="https://blog.csdn.net/yuliying/article/details/72898132">C语言运算符优先级</a></p></blockquote><table border="1" cellspacing="0" cellpadding="0" width="612"><tbody><tr><td><p align="center"><strong>优先级</strong></p></td><td><p align="center"><strong>运算符</strong></p></td><td><p align="center"><strong>名称或含义</strong></p></td><td><p align="center"><strong>使用形式</strong></p></td><td><p align="center"><strong>结合方向</strong></p></td><td><p align="center"><strong>说明</strong></p></td></tr><tr><td rowspan="4"><p align="center"><strong>1</strong></p></td><td><p align="center"><strong>[]</strong></p></td><td><p>数组下标</p></td><td><p>数组名 [常量表达式]</p></td><td rowspan="4"><p align="center">左到右</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>()</strong></p></td><td><p>圆括号</p></td><td><p>(表达式）/ 函数名 (形参表)</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>.</strong></p></td><td><p>成员选择（对象）</p></td><td><p>对象. 成员名</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>-&gt;</strong></p></td><td><p>成员选择（指针）</p></td><td><p>对象指针 -&gt; 成员名</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"></td></tr><tr><td rowspan="9"><p align="center"><strong>2</strong></p></td><td><p align="center"><strong>-</strong></p></td><td><p>负号<a href="https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&amp;spm=1001.2101.3001.7020" target="_blank" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&amp;spm=1001.2101.3001.7020&quot;}" data-tit="运算符" data-pretit="运算符">运算符</a></p></td><td><p>- 表达式</p></td><td rowspan="9"><p align="center"><strong>右到左</strong></p></td><td rowspan="7"><p align="center">单目运算符</p></td></tr><tr><td><p align="center"><strong>~</strong></p></td><td><p>按位取反运算符</p></td><td><p>~ 表达式</p></td></tr><tr><td><p align="center"><strong>++</strong></p></td><td><p>自增运算符</p></td><td><p>++ 变量名 / 变量名 ++</p></td></tr><tr><td><p align="center"><strong>--</strong></p></td><td><p>自减运算符</p></td><td><p>-- 变量名 / 变量名 --</p></td></tr><tr><td><p align="center"><strong>*</strong></p></td><td><p>取值运算符</p></td><td><p>* 指针变量</p></td></tr><tr><td><p align="center"><strong>&amp;</strong></p></td><td><p>取地址运算符</p></td><td><p>&amp; 变量名</p></td></tr><tr><td><p align="center"><strong>!</strong></p></td><td><p>逻辑非运算符</p></td><td><p>! 表达式</p></td></tr><tr><td><p align="center"><strong>(类型)</strong></p></td><td><p>强制类型转换</p></td><td><p>(数据类型) 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>sizeof</strong></p></td><td><p>长度运算符</p></td><td><p>sizeof(表达式)</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"></td></tr><tr><td rowspan="3"><p align="center"><strong>3</strong></p></td><td><p align="center"><strong>/</strong></p></td><td><p>除</p></td><td><p>表达式 / 表达式</p></td><td rowspan="3"><p align="center">左到右</p></td><td rowspan="3"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>*</strong></p></td><td><p>乘</p></td><td><p>表达式 * 表达式</p></td></tr><tr><td><p align="center"><strong>%</strong></p></td><td><p>余数（取模）</p></td><td><p>整型表达式 % 整型表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>4</strong></p></td><td><p align="center"><strong>+</strong></p></td><td><p>加</p></td><td><p>表达式 + 表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>-</strong></p></td><td><p>减</p></td><td><p>表达式 - 表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>5</strong></p></td><td><p align="center"><strong>&lt;&lt;&nbsp;</strong></p></td><td><p>左移</p></td><td><p>变量 &lt;&lt; 表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>&gt;&gt;&nbsp;</strong></p></td><td><p>右移</p></td><td><p>变量 &gt;&gt; 表达式</p></td></tr><tr><td width="612" colspan="6"></td></tr><tr><td rowspan="4"><p align="center"><strong>6</strong></p></td><td><p align="center"><strong>&gt;&nbsp;</strong></p></td><td><p>大于</p></td><td><p>表达式 &gt; 表达式</p></td><td rowspan="4"><p align="center">左到右</p></td><td rowspan="4"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>&gt;=</strong></p></td><td><p>大于等于</p></td><td><p>表达式 &gt;= 表达式</p></td></tr><tr><td><p align="center"><strong>&lt;&nbsp;</strong></p></td><td><p>小于</p></td><td><p>表达式 &lt; 表达式</p></td></tr><tr><td><p align="center"><strong>&lt;=</strong></p></td><td><p>小于等于</p></td><td><p>表达式 &lt;= 表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>7</strong></p></td><td><p align="center"><strong>==</strong></p></td><td><p>等于</p></td><td><p>表达式 == 表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>！=</strong></p></td><td><p>不等于</p></td><td><p>表达式!= 表达式</p></td></tr><tr><td width="612" colspan="6"></td></tr><tr><td><p align="center"><strong>8</strong></p></td><td><p align="center"><strong>&amp;</strong></p></td><td><p>按位与</p></td><td><p>表达式 &amp; 表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>9</strong></p></td><td><p align="center"><strong>^</strong></p></td><td><p>按位异或</p></td><td><p>表达式 ^ 表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>10</strong></p></td><td><p align="center"><strong>|</strong></p></td><td><p>按位或</p></td><td><p>表达式 | 表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>11</strong></p></td><td><p align="center"><strong>&amp;&amp;</strong></p></td><td><p>逻辑与</p></td><td><p>表达式 &amp;&amp; 表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>12</strong></p></td><td><p align="center"><strong>||</strong></p></td><td><p>逻辑或</p></td><td><p>表达式 || 表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td width="612" colspan="6"></td></tr><tr><td><p align="center"><strong>13</strong></p></td><td><p align="center"><strong>?:</strong></p></td><td><p>条件运算符</p></td><td><p>表达式 1?</p><p>表达式 2: 表达式 3</p></td><td><p align="center"><strong>右到左</strong></p></td><td><p align="center">三目运算符</p></td></tr><tr><td width="612" colspan="6"></td></tr><tr><td rowspan="11"><p align="center"><strong>14</strong></p></td><td><p align="center"><strong>=</strong></p></td><td><p>赋值运算符</p></td><td><p>变量 = 表达式</p></td><td rowspan="11"><p align="center"><strong>右到左</strong></p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>/=</strong></p></td><td><p>除后赋值</p></td><td><p>变量 /= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>*=</strong></p></td><td><p>乘后赋值</p></td><td><p>变量 *= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>%=</strong></p></td><td><p>取模后赋值</p></td><td><p>变量 %= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>+=</strong></p></td><td><p>加后赋值</p></td><td><p>变量 += 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>-=</strong></p></td><td><p>减后赋值</p></td><td><p>变量 -= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>&lt;&lt;=</strong></p></td><td><p>左移后赋值</p></td><td><p>变量 &lt;&lt;= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>&gt;&gt;=</strong></p></td><td><p>右移后赋值</p></td><td><p>变量 &gt;&gt;= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>&amp;=</strong></p></td><td><p>按位与后赋值</p></td><td><p>变量 &amp;= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>^=</strong></p></td><td><p>按位异或后赋值</p></td><td><p>变量 ^= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong>|=</strong></p></td><td><p>按位或后赋值</p></td><td><p>变量 |= 表达式</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"></td></tr><tr><td><p align="center"><strong>15</strong></p></td><td><p align="center"><strong>，</strong></p></td><td><p>逗号运算符</p></td><td><p>表达式, 表达式,…</p></td><td><p align="center">左到右</p></td><td><p align="center">--</p></td></tr></tbody></table><p><strong>说明</strong></p><p><strong>同一优先级的运算符，运算次序由结合方向所决定。</strong><br><strong>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</strong></p><p><strong>口诀</strong>：</p><ol><li>成员1</li><li>全体单目2</li><li>乘除3</li><li>加减4</li><li>移位5</li><li>关系6</li><li>等于不等排第7</li><li><code>&amp;</code> <code>^</code> <code>|</code> 8、9、10</li><li><code>&amp;&amp;</code> <code>||</code> 逻辑与 和 逻辑或 分别11和12</li><li>三目运算符 13</li><li>赋值运算</li><li><code>，</code>逗号运算符</li></ol>]]></content>
      
      
      <categories>
          
          <category> 好文转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下docker的使用</title>
      <link href="/posts/6c58185/"/>
      <url>/posts/6c58185/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu下docker的使用"><a href="#ubuntu下docker的使用" class="headerlink" title="ubuntu下docker的使用"></a>ubuntu下docker的使用</h1><p>由于 vmware 太重了，所以后续准备使用 docker 来完成各种各样板卡环境的配置。</p><p>docker 中的系统与宿主机使用 ssh 通信。</p><h2 id="docker-安装与配置"><a href="#docker-安装与配置" class="headerlink" title="docker 安装与配置"></a>docker 安装与配置</h2><p><img src="https://cdn.zsite.com/data/upload/d/docker/202009/f_dec504d3c908d19e6c5165f251d3d124.jpg" alt="docker架构"></p><p>具体介绍详见 <a href="https://www.docker.org.cn/docker/192.html">Docker 架构及工作原理</a></p><h3 id="安装-docker-本体"><a href="#安装-docker-本体" class="headerlink" title="安装 docker 本体"></a>安装 docker 本体</h3><p>终端执行</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -sSL https://get.daocloud.io/docker | sh<br></code></pre></td></tr></tbody></table></figure><p>验证安装是否成功</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run hello-world<br></code></pre></td></tr></tbody></table></figure><p>出现了以下，表示成功。<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202205051622408.png"></p><h3 id="配置-18-04-的-ubuntu-镜像"><a href="#配置-18-04-的-ubuntu-镜像" class="headerlink" title="配置 18.04 的 ubuntu 镜像"></a>配置 18.04 的 ubuntu 镜像</h3><p>配置16或者其它版本的ubuntu镜像也是如此，可在<a href="https://hub.docker.com/">https://hub.docker.com/</a> 搜索镜像，或者使用命令<code>docker search ubuntu</code>来搜索ubuntu相关的镜像。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker pull ubuntu:18.04<br></code></pre></td></tr></tbody></table></figure><h3 id="运行-ubuntu18-04"><a href="#运行-ubuntu18-04" class="headerlink" title="运行 ubuntu18.04"></a>运行 ubuntu18.04</h3><p><code>sudo docker images</code>先查看 ubuntu18.04 对应的id <code>c6ad7e71ba7d</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">sudo docker run -itd --name ubuntu18.04 c6ad7e71ba7d<br></code></pre></td></tr></tbody></table></figure><p>共享宿主机目录</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run  --mount type=bind,source="$(pwd)"/data,target=/home/data -it &lt;name_of_container&gt; /bin/bash<br></code></pre></td></tr></tbody></table></figure><p>共享宿主机下的目录<code>/home/u/data</code>，在docker中的<code>/home/data</code>显示</p><p><strong>如果要共享，仅需执行这个命令就可以了。</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run --mount type=bind,source=/home/u/data,target=/home/data  -itd --name ubuntu18.04 c6ad7e71ba7d /bin/bash<br></code></pre></td></tr></tbody></table></figure><p>不加<code>/bin/bash</code>可能会报错。。</p><h3 id="执行-ubuntu18-04"><a href="#执行-ubuntu18-04" class="headerlink" title="执行 ubuntu18.04"></a>执行 ubuntu18.04</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker exec -it ubuntu18.04 /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会直接显示下面终端，表示已经进入了docker中的ubuntu18.04</span><br>root@98c152bc6c63:/# <br></code></pre></td></tr></tbody></table></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用如下命令查看容器的name或者是<span class="hljs-built_in">id</span></span><br>sudo docker container  ls<br><br>CONTAINER ID   IMAGE          COMMAND   CREATED          STATUS          PORTS     NAMES<br>86ad708ba348   c6ad7e71ba7d   "bash"    26 minutes ago   Up 26 minutes             ubuntu18.04<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止指定的容器</span><br>sudo docker stop ubuntu18.04<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>sudo docker stop 86ad708ba348<br></code></pre></td></tr></tbody></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker rm 容器名或id<br></code></pre></td></tr></tbody></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker rmi 镜像id<br><span class="hljs-meta prompt_"># </span><span class="language-bash">例如</span><br>sudo docker rmi  c6ad7e71ba7d<br></code></pre></td></tr></tbody></table></figure><h3 id="第二次进入docker中的镜像"><a href="#第二次进入docker中的镜像" class="headerlink" title="第二次进入docker中的镜像"></a>第二次进入docker中的镜像</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 获取镜像<span class="hljs-built_in">id</span>和名称</span><br>sudo docker ps -a<br><br>CID=a5bab384761f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 防止容器正在运行，首先停止容器，在开始</span><br>sudo docker stop $CID<br>sudo docker start $CID<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.进入容器，并执行 service ssh start，其目的是开启ssh服务</span><br>sudo docker exec -it $CID /bin/bash service ssh start<br></code></pre></td></tr></tbody></table></figure><h3 id="查看容器占用大小"><a href="#查看容器占用大小" class="headerlink" title="查看容器占用大小"></a>查看容器占用大小</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker system df -v<br></code></pre></td></tr></tbody></table></figure><h2 id="ubuntu配置"><a href="#ubuntu配置" class="headerlink" title="ubuntu配置"></a>ubuntu配置</h2><h3 id="配置ssh服务"><a href="#配置ssh服务" class="headerlink" title="配置ssh服务"></a>配置ssh服务</h3><p>接下来拷贝数据进入，首先得保证ssh通的，ssh首先得先安装，先换源。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list<br>sed -i '/security.ubuntu.com/d' /etc/apt/sources.list<br><br>apt clean <br>apt update <br></code></pre></td></tr></tbody></table></figure><p>安装常用软件</p><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">apt install -y git vim ssh openssh-<span class="hljs-keyword">server</span> net-tools<br></code></pre></td></tr></tbody></table></figure><p>推送文件到docker上的ubuntu发现22端口拒绝<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202205051642813.png"></p><p>修改ssh配置</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">去掉PermitRootLogin项注释，将value改为<span class="hljs-built_in">yes</span></span><br>vim /etc/ssh/sshd_config <br><span class="hljs-meta prompt_"># </span><span class="language-bash">-----------------------------------------------------------------------</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">PermitRootLogin prohibit-password</span><br>PermitRootLogin yes<br></code></pre></td></tr></tbody></table></figure><p>重启ssh </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/etc/init.d/ssh  restart<br></code></pre></td></tr></tbody></table></figure><p>修改本机密码</p><p><code>passwd</code>，随便按一个就行</p><p>接着上传，就可以了。<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202205051651722.png"></p><h3 id="安装编译所需"><a href="#安装编译所需" class="headerlink" title="安装编译所需"></a>安装编译所需</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install -y gcc g++ make gawk bison libncurses-dev libncurses5-dev  zlib1g-dev python unzip <br>apt install -y ninja-build <br></code></pre></td></tr></tbody></table></figure><h3 id="配置非-root-用户"><a href="#配置非-root-用户" class="headerlink" title="配置非 root 用户"></a>配置非 root 用户</h3><p>推荐使用非<code>root</code>用户，但又有<code>root</code>权限</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装sudo</span> <br>apt install sudo <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加用户</span><br>adduser u<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为新用户设置密码</span><br>passwd u<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为该用户指定命令解释程序</span><br>usermod -s /bin/bash u<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为该文件添加写权限，默认只有读权限</span><br>chmod u+w /etc/sudoers<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑sudoers</span><br>vim /etc/sudoers <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 root ALL=(ALL:ALL) ALL 后追加新行，如下图</span><br>u  ALL=(ALL:ALL) ALL<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">恢复只读权限</span><br>chmod u-w /etc/sudoers<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给新目录添加读写权限</span><br>chown u:u -R /home/u<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到新用户</span><br>su u<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202205052036667.png"></p><p>从此刻开始，以非<code>root</code>用户编译<code>lede</code></p><h3 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h3><p>首先安装 tzdata，否则会报错</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">u@86ad708ba348:~/gn$ tzselect <br>/usr/bin/tzselect: line 180: /usr/share/zoneinfo/iso3166.tab: No such file or directory<br>/usr/bin/tzselect: time zone files are not set up correctly<br></code></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install tzdata<br></code></pre></td></tr></tbody></table></figure><p>接着安装完之后会让你配置时区，选择 <code>6.Asia - 70.Shanghai</code> </p><p>接着运行 <code>tzselect</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell">u@86ad708ba348:~/gn$ tzselect <br>Please identify a location so that time zone rules can be set correctly.<br>Please select a continent, ocean, "coord", or "TZ".<br> 1) Africa<br> 2) Americas<br> 3) Antarctica<br> 4) Asia<br> 5) Atlantic Ocean<br> 6) Australia<br> 7) Europe<br> 8) Indian Ocean<br> 9) Pacific Ocean<br>10) coord - I want to use geographical coordinates.<br>11) TZ - I want to specify the time zone using the Posix TZ format.<br><span class="hljs-meta prompt_">#</span><span class="language-bash">? 4</span><br>Please select a country whose clocks agree with yours.<br> 1) Afghanistan  18) Iraq    35) Pakistan<br> 2) Antarctica  19) Israel    36) Palestine<br> 3) Armenia  20) Japan    37) Philippines<br> 4) Azerbaijan  21) Jordan    38) Qatar<br> 5) Bahrain  22) Kazakhstan    39) Russia<br> 6) Bangladesh  23) Korea (North)    40) Saudi Arabia<br> 7) Bhutan  24) Korea (South)    41) Singapore<br> 8) Brunei  25) Kuwait    42) Sri Lanka<br> 9) Cambodia  26) Kyrgyzstan    43) Syria<br>10) China  27) Laos    44) Taiwan<br>11) Cyprus  28) Lebanon    45) Tajikistan<br>12) East Timor  29) Macau    46) Thailand<br>13) Georgia  30) Malaysia    47) Turkmenistan<br>14) Hong Kong  31) Mongolia    48) United Arab Emirates<br>15) India  32) Myanmar (Burma)    49) Uzbekistan<br>16) Indonesia  33) Nepal    50) Vietnam<br>17) Iran  34) Oman    51) Yemen<br><span class="hljs-meta prompt_">#</span><span class="language-bash">? 10</span><br>Please select one of the following time zone regions.<br>1) Beijing Time<br>2) Xinjiang Time<br><span class="hljs-meta prompt_">#</span><span class="language-bash">? 1</span><br><br>The following information has been given:<br><br>China<br>Beijing Time<br><br>Therefore TZ='Asia/Shanghai' will be used.<br>Selected time is now:Fri May  6 08:49:39 CST 2022.<br>Universal Time is now:Fri May  6 00:49:39 UTC 2022.<br>Is the above information OK?<br>1) Yes<br>2) No<br><span class="hljs-meta prompt_">#</span><span class="language-bash">? <span class="hljs-built_in">yes</span></span><br>Please enter a number in range.<br><span class="hljs-meta prompt_">#</span><span class="language-bash">? 1</span><br><br>You can make this change permanent for yourself by appending the line<br>TZ='Asia/Shanghai'; export TZ<br>to the file '.profile' in your home directory; then log out and log in again.<br><br>Here is that TZ value again, this time on standard output so that you<br>can use the /usr/bin/tzselect command in shell scripts:<br>Asia/Shanghai<br></code></pre></td></tr></tbody></table></figure><p>在拷贝时区到localtime中</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime <br></code></pre></td></tr></tbody></table></figure><p>使用<code>date -R</code> 就可查到更改的时间了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/86371599">ubuntu 一键换源</a></p></li><li><p><a href="https://blog.csdn.net/qq_43914736/article/details/90608587">Docker Ubuntu上安装ssh和连接ssh</a></p></li><li><p><a href="https://blog.csdn.net/zhengchaooo/article/details/79500032">Ubuntu修改时区和更新时间</a></p></li><li><p><a href="https://stackoverflow.com/questions/30652299/having-docker-access-external-files">Having Docker access External files</a></p></li><li><p><a href="https://www.cnblogs.com/kingsonfu/p/11578073.html">docker容器添加对外映射端口</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux0.11环境搭建与阅读</title>
      <link href="/posts/ca3a0e2a/"/>
      <url>/posts/ca3a0e2a/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux0-11环境搭建与阅读"><a href="#Linux0-11环境搭建与阅读" class="headerlink" title="Linux0.11环境搭建与阅读"></a>Linux0.11环境搭建与阅读</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>更好的学习 linux 内核思想，做一个有想法的人。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在 windows 下使用虚拟机 vmware ，虚拟机使用 ubuntu 22.04 LTS，模拟器使用 qemu 。</p><p>搭建虚拟机vmware过程省略，具体的可查看 <a href="https://gonglja.github.io/posts/d78cdbc6/">archlinux的搭建</a></p><h3 id="搭建ubuntu中qemu"><a href="#搭建ubuntu中qemu" class="headerlink" title="搭建ubuntu中qemu"></a>搭建ubuntu中qemu</h3><blockquote><p>由于使用命令 sudo apt install qemu 安装版本过旧并可能存在问题，所以本文使用编译方式安装。</p></blockquote><p>ubuntu 宿主机环境如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202205110934467.png"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 安装环境必备包</span><br>sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev <br>sudo apt install ninja-build<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 下载qemu源码</span><br>git clone https://mirrors.tuna.tsinghua.edu.cn/git/qemu.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 配置qemu</span><br>cd qemu<br>./configure <br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果配置没有报错，则可以直接编译并安装了。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">大约 6376.73s 编译完成，可使用命令 time make -j$(<span class="hljs-built_in">nproc</span>) 查看时间，以下为我本次编译所需时间</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">make -j12  6376.73s user 729.92s system 1160% cpu 10:12.17 total</span><br>make -j$(nproc) <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接./configure 可能会报错，./configure --with-git-submodules=validate 重新配置后编译安装即可。</span><br>sudo make install -j$(nproc) <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.验证 通过命令可以看出 qemu 的版本号，代表安装完成。</span><br>u@u-virtual-machine /home/u/workspace/tools                                                                           <br>⚡ qemu-system-x86_64 --version<br>QEMU emulator version 7.0.50<br>Copyright (c) 2003-2022 Fabrice Bellard and the QEMU Project developers<br></code></pre></td></tr></tbody></table></figure><p>配置好后，打开发现只输出一句话，VNC Server runnning on 127.0.0.1:5900 </p><p>这是因为没有支持<code>SDL</code>(Simple DirectMedia Layer)</p><p>所以需要重新配置后在安装，</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装SDL支持依赖</span><br>sudo apt install libsdl1.2-dev libsdl2-dev<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">继续配置，一会搜索一下看下SDL是否为YES，为YES则已经开启了，剩下的直接编译安装就可。</span><br>./configure --with-git-submodules=validate<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译和安装</span><br>make -j$(nproc) &amp;&amp; sudo make install -j$(nproc)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次验证，输入下面命令后会直接弹出qemu虚拟机</span><br>qemu-system-x86_64<br></code></pre></td></tr></tbody></table></figure><h3 id="配置gdb环境"><a href="#配置gdb环境" class="headerlink" title="配置gdb环境"></a>配置gdb环境</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install gdb<br></code></pre></td></tr></tbody></table></figure><p>习惯使用pwndbg了，添加此插件。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先下载源码，并编译，没有问题那么就开始分析源码了。</p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>地址为 <a href="https://github.com/yuan-xy/Linux-0.11">https://github.com/yuan-xy/Linux-0.11</a></p><p>不过也可以fork到自己的仓库中，方便后面更改后的上传。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/Gonglja/Linux-0.11.git &amp;&amp; cd Linux-0.11<br>make clean -j$(nproc) &amp;&amp; make -j$(nproc) <br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接可以编过，不会缺少什么库。</span><br></code></pre></td></tr></tbody></table></figure><p>代码汇编部分采用AT&amp;T语法，需要熟悉AT&amp;T</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>大部分来自闪客大佬的<a href="https://github.com/sunym1993/flash-linux0.11-talk">品读 Linux 0.11 核心代码</a>和赵炯博士的<a href="https://zh.1lib.education/book/16407357/1b5b4a">Linux内核0.11完全注释_V3.0</a>，</p><p>本文只是一个在学习 Linux-0.11 过程中的一个笔记，如有侵权，请联系:<a href="mailto:glj0@outlook.com">glj0@outlook.com</a></p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><table><thead><tr><th>类别</th><th>寄存器</th><th>说明</th></tr></thead><tbody><tr><td></td><td>AX</td><td></td></tr><tr><td></td><td>BX</td><td></td></tr><tr><td></td><td>CX</td><td></td></tr><tr><td></td><td>DX</td><td></td></tr><tr><td></td><td>CS</td><td>代码段（code segment）寄存器</td></tr><tr><td></td><td>DS</td><td>数据段（data segment）寄存器</td></tr><tr><td></td><td>SS</td><td>堆栈段（stack segment）寄存器</td></tr><tr><td></td><td>ES</td><td>附加段（extra segment）寄存器</td></tr><tr><td></td><td>SP</td><td>堆栈指针(stack pointer)寄存器</td></tr><tr><td></td><td>BP</td><td>基址指针（base pointer）寄存器</td></tr><tr><td></td><td>SI</td><td>源变址指针（source index）寄存器</td></tr><tr><td></td><td>DI</td><td>目的变址指针（destination index）寄存器</td></tr><tr><td></td><td>IP</td><td>指令指针（instruction pointer）寄存器</td></tr><tr><td></td><td>FLAGS</td><td>状态标志（）</td></tr><tr><td></td><td>IDTR</td><td>中断描述符表索引（）</td></tr><tr><td></td><td>GDTR</td><td>全局描述符表索引（）</td></tr><tr><td></td><td>CR3</td><td>页表索引</td></tr></tbody></table><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>AT&amp;T</p><table><thead><tr><th>类别</th><th>指令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>跳转指令</td><td>jmp</td><td>跳转到相对有效地址</td><td><code>jmp *4(%edi)</code>跳转到EDI寄存器+4偏移处</td></tr><tr><td></td><td>ljmp</td><td>长跳转</td><td><code>ljmp $0xfebc,$0x12345678</code> <code>0xfebc</code>用于<code>CS</code>寄存器，<code>0x12345678</code>用于<code>EIP</code>寄存器，换句话说，跳转至<code>0xfebc&lt;&lt;16 + 0x12345678</code>处</td></tr><tr><td></td><td>jne</td><td>条件跳转，CF=0，则跳转</td><td><code>mov $AX,%ax;jnc label;</code> 如果AX &gt;= 0，则跳转到label处执行。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>数据传送指令</td><td>movsw</td><td>从源地址向目的地址传送数据<br>在16位模式下，源地址<code>DS:SI</code> ，目的地址<code>ES:DI</code><br>在32位模式下，源地址<code>DS:ESI</code>，目的地址<code>ES:EDI</code><br>movsb、movsw、movsd 区别，b字节、w字、d双字，也即传递一个字节、一个字、一个双字。</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>cld;rep;stosl</td><td>cld设置<code>edi</code>或同<code>esi</code>为递增方向（从前往后）（如果为std，则从后往前 反向），rep做(<code>%ecx</code>)次重复操作，stosl表示edi每次增加4</td><td></td></tr></tbody></table><p>先看下最外层的Makefile，关注几个点</p><p>当链接器链接的时候，其参数携带<code>-Ttext 0</code>，指定代码段的运行地址从<code>0</code>开始</p><p>另一个就是<code>all</code>，也就是<code>Image</code>，是由<code>boot/bootsect boot/setup tools/system</code>等编译的，编译结束后又经过<code>tools/build.sh</code>脚本构建镜像</p><table><thead><tr><th>模块</th><th>偏移（段/Byte）</th><th>大小（段/Byte）</th><th>备注</th></tr></thead><tbody><tr><td>bootsect</td><td>0/0</td><td>1/512</td><td>启动阶段</td></tr><tr><td>setup</td><td>1/512</td><td>4/2048</td><td>配置阶段</td></tr><tr><td>system</td><td>5/2560</td><td>(2888-1-4)*512=1476096，最大长度，实际为system的大小</td><td>内核等</td></tr><tr><td>DEFAULT_MINOR_ROOT DEFAULT_MAJOR_ROOT</td><td>0/508*1</td><td>2</td><td>版本号信息</td></tr></tbody></table><p>也由此可知，上电后从boot跳转过来后，直接执行的是<code>bootsect</code>中的内容。</p><h4 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  boot git:(master) ✗ tree    <br>.<br>├── bootsect.s<br>├── head.s<br>├── Makefile<br>└── setup.s<br><br>0 directories, 4 files<br></code></pre></td></tr></tbody></table></figure><p>先看下<code>Makefile</code>，通过编译脚本可得 链接器参数为 <code>-Ttext 0</code>，另外三个<code>bootsect</code>、<code>setup</code>、<code>head</code>模块也是分别编译。</p><ul><li><p><input disabled="" type="checkbox"> 补个图</p><p>  <img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204021631675.png"></p></li></ul><p><strong>当cpu上电后，bios会将第一个可启动的硬盘的前512字节数据，拷贝到0x7c00处。</strong></p><blockquote><p>什么叫可启动设备：只要第一个扇区的512字节的最后两字节分别为0x55、0xaa，那么其就是一个可启动设备。</p></blockquote><p>前512字节是什么呢？<code>bootsect</code>模块，换句话说，当<code>cpu</code>上电后，<code>bios</code>将<code>bootsect</code>拷贝到<code>0x7c00</code>处，其大小为 <code>512</code> Byte。</p><p>之后就进入到<code>0x7c00</code>处，开始执行<code>bootsect</code>模块的代码。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204021638456.png"></p><h4 id="bootsect"><a href="#bootsect" class="headerlink" title="bootsect"></a>bootsect</h4><p><code>.global</code> 声明部分标号对全局可见，</p><ul><li>_start 程序开始的地方</li><li>begtext text段开始的位置</li><li>begdata data段开始的位置</li><li>begbss bss段开始的位置</li><li>endtext text段结束的位置</li><li>enddata data段结束的位置</li><li>endbss bss段结束的位置</li></ul><p><code>.equ</code> 表达式赋值操作符</p><table><thead><tr><th>标号</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SYSSIZE</td><td>0x3000</td><td>system大小</td></tr><tr><td>SETUPLEN</td><td>4</td><td>setup段中长度</td></tr><tr><td>BOOTSEG</td><td>0x07c0</td><td>boot段源地址</td></tr><tr><td>INITSEG</td><td>0x9000</td><td>boot段即将移动到的位置</td></tr><tr><td>SETUPSEG</td><td>0x9020</td><td>setup段开始的位置</td></tr><tr><td>SYSSEG</td><td>0x1000</td><td>system加载的位置0x10000</td></tr><tr><td>ENDSEG</td><td>SYSSEG+SYSSIZE</td><td>停止加载的位置</td></tr></tbody></table><p><code>ljmp $BOOTSEG, $_start</code>长跳转，跳转至$BOOTSEG&lt;&lt;16 + _start$处，也即<code>0x7c00</code>处。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">_start:<br>mov$BOOTSEG, %ax    <br>mov%ax, %ds#将ds段寄存器设置为0x7C0<br>mov$INITSEG, %ax<br>mov%ax, %es#将es段寄存器设置为0x9000<br>mov$256, %cx #设置移动计数值256字<br>sub%si, %si   #源地址ds:si = 0x07C0:0x0000<br>sub%di, %di  #目标地址 es:si = 0x9000:0x0000<br>         rep                                    #重复执行并递减cx的值<br>movsw                              #从内存[si]处移动cx个字到[di]处<br></code></pre></td></tr></tbody></table></figure><p>由于不能直接给ds赋值，借助ax，将ds寄存器值设置为<code>0x7C0</code>；同理，将es段寄存器设置为<code>0x900</code>。</p><p>接着设置cx寄存器值为<code>256</code>，将si、di寄存器清零。</p><blockquote><p><strong>movsw</strong>：数据传送指令，从源地址向目的地址传送数据</p><p>在16位模式下，源地址<code>DS:SI</code> ，目的地址<code>ES:DI</code></p><p>在32位模式下，源地址<code>DS:ESI</code>，目的地址<code>ES:EDI</code></p><p>movsb、movsw、movsd 区别，b字节、w字、d双字，也即传递一个字节、一个字、一个双字。</p></blockquote><p>所以，这段代码的作用就是将<code>ds:si</code>(<code>0x7c0:0x0</code>即<code>0x7c00</code>)处开始，大小为<code>256字</code>，即<code>512字节</code>的数据拷贝到<code>es:di</code>(<code>0x9000:0x0</code>即<code>0x90000</code>)处。</p><p>也就是cpu上电后，bios将第一个可启动设备的前<code>512字节</code>先拷贝到<code>0x7c00</code>处，接着跳转到<code>0x7c00</code>处执行，然后又将该部分拷贝到<code>0x90000</code>处</p><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091106175.png" style="zoom:50%;"><p><code>ljmp $INITSEG, $go</code> 长跳转，直接跳转至<code>0x9000:go</code>处。</p><p>接着执行<code>go</code>处的代码。由于是长跳转，所以cs的值为<code>$INITSEG</code>，也就是<code>0x9000</code>。</p><p>所以此处代码也就是将<code>ds</code>、<code>es</code>、<code>ss</code>设置为移动后代码所在的段处，并且将堆栈段 设置为<code>0x9000:0</code> - <code>0x9000:0xff00</code>，即<code>0x90000 </code>- <code>0x9ff00</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">go: mov   %cs, %ax#将ds，es，ss都设置成移动后代码所在的段处(0x9000)<br>mov%ax, %ds<br>mov%ax, %es<br># put stack at 0x9ff00.<br>mov%ax, %ss<br>mov$0xFF00, %sp# arbitrary value &gt;&gt;512<br></code></pre></td></tr></tbody></table></figure><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091424605.png" style="zoom:50%;"><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">load_setup:<br>mov$0x0000, %dx# drive 0, head 0<br>mov$0x0002, %cx# sector 2, track 0<br>mov$0x0200, %bx# address = 512, in INITSEG<br>.equ    AX, 0x0200+SETUPLEN<br>mov     $AX, %ax    # service 2, nr of sectors<br>int$0x13         # read it<br></code></pre></td></tr></tbody></table></figure><p>看一下<code>int $13</code>，BIOS int 13h中断也叫直接磁盘服务（Direct Disk Service）其对应。</p><blockquote><p>此处int为中断，<code>int 0x13</code>，发起<code>0x13</code>号中断。</p><p>当中断发生后，CPU会根据中断编号去找对应的中断函数入口地址并跳转过去执行，相当于此处执行了一个函数。</p></blockquote><ul><li>ax=0x0204 其功能描述为读扇区，扇区数为4</li><li>bx=0x0200 其功能配置es寄存器组成缓冲区地址，es:bx 缓冲区地址</li><li>cx=0x0002 分为ch和cl，ch 柱面，cl 扇区。即0柱面2扇区。</li><li>dx=0x0000 分为dh和dl，dh 磁头，dl 驱动器00H<del>7FH 软盘；80H</del>FFH 硬盘</li></ul><p>也就是从 <code>软盘驱动器0</code>的<code>0柱面2扇区</code>开始，拷贝<code>4扇区</code>到<code>es:bx</code>，也就是<code>0x9000:0x0200</code>即<code>0x90200</code></p><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091342057.png" style="zoom:50%;"><p>拷贝的是什么东西呢？硬盘中1-5共4扇区的代码。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">load_setup:<br>...<br>jncok_load_setup   # ok - continue<br>mov$0x0000, %dx<br>mov$0x0000, %ax# reset the diskette<br>int$0x13<br>jmpload_setup<br></code></pre></td></tr></tbody></table></figure><p>接着 因为AX&gt;=0，跳转到<code>ok_load_setup</code>执行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ok_load_setup:<br>...<br>mov$SYSSEG, %ax<br>mov%ax, %es# segment of 0x010000<br>call    read_it<br>...<br>ljmp$SETUPSEG, $0<br></code></pre></td></tr></tbody></table></figure><p>这部分只看主要代码，其将剩下的从第6个扇区后面的x个扇区，加载到内存<code>0x10000</code>处，简单来说，就是将system代码挪了个地。</p><p>接着一个长跳转 <code>SETUPSEG</code>，将CS设置为<code>0x9020</code>，EIP设置为<code>0x0</code> 也就是跳转到<code>0x9020&lt;&lt;16 | 0</code>即<code>0x90200</code></p><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091422374.png" style="zoom:50%;"><p>硬盘中数据是怎么分区的呢</p><p>通过<code>Makefile</code>和<code>tools/build.sh</code>配合完成，其中</p><ul><li><p><code>bootsect.s</code>编译成bootsect，放在第<code>1</code>扇区</p></li><li><p><code>setup.s</code>编译成<code>setup</code>，放在<code>2~5</code>扇区</p></li><li><p>将剩下的<code>head.s</code>和其他代码编译成<code>system</code>，放在随后的240个扇区？（不一定是240扇区）</p><p>  <img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204022233895.png"></p><p>  总结一下：cpu上电后bios将第一个可启动分区的前512字节(bootsect)拷贝到0x7c00处，并跳转过去执行，接着bootsect 又把自己搬到了0x90000处。</p><p>  然后跳转过去，将2扇区-5扇区（setup）共4扇区拷贝到0x90200处。接着将6扇区以后（system）拷贝到0x10000处。最后跳转到<code>0x90200</code>处执行。</p><blockquote><p>在分析的过程中，我们借助<code>gdb</code>，<code>target remote :1234</code>，</p><p>b *0x7c00  在0x7c00处加个断点</p><p>b *0x90200 在0x90200处加个断点</p><p>当跳转到 0x90200 处，通过命令 <code>x/512b 0x90200</code>/<code>x/256h 0x90200</code>处值，发现就是我们拷贝过去的第一个扇区（bootsect）</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206061437146.png"></p></blockquote></li></ul><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p>setup.s负责从BIOS中获取系统数据，并将这些数据放到系统内存的合适地方。这段代码询问bios 有关内存/磁盘/其它参数，并将这些参数存到一个“安全的”地方：0x90000-0x901FF。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.equ SETUPSEG, 0x9020# this is the current segment<br>...<br>ljmp $SETUPSEG, $_start<br>_start:<br>mov %cs,%ax<br>mov %ax,%ds<br>mov %ax,%es<br></code></pre></td></tr></tbody></table></figure><p>跳转到相对于<code>0x90200</code>处偏移_start的位置，也就是当前_start代码的位置，更新当前ds、es寄存器值为<code>0x9020</code>。</p><p>接着往下看代码，都是形似 <code>mov %ax,\$xxa;mov %bx,\$xxb;mov %cx,\$xxc;mov %dx,\$xxd;int xxe;</code>都是通过bios中断获取信息，然后将其存在内存中。</p><p>存在哪呢？实际上是保存在ds寄存器值为cs，偏移为0处（cs:0 == cs&lt;&lt;16+0）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ljmp $SETUPSEG, $_start<br>_start:<br>mov %cs,%ax<br>mov %ax,%ds<br>...<br>int$0x10# save it in known place, con_init fetches<br>mov%dx, %ds:0# it from 0x90000.<br></code></pre></td></tr></tbody></table></figure><p>最终会通过bios获取到这些数据，将之存到0x90000处。</p><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table><p>将以上信息存储到0x90000处后，将关闭中断。因为后面我们要自己实现中断，并且将bios的中断向量表破坏掉，所以这个时候是不允许中断进来的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">...<br>cli<br>...<br></code></pre></td></tr></tbody></table></figure><p>看下面的部分，是不很熟悉<code>movsw</code>，是一个数据传送指令，将一段数据从源地址传送到目的地址，详见<a href="#%E6%8C%87%E4%BB%A4">指令</a>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov$0x0000, %ax<br>cld# 'direction'=0, movs moves forward<br>do_move:<br>mov%ax, %es# destination segment<br>add$0x1000, %ax<br>cmp$0x9000, %ax<br>jzend_move<br>mov%ax, %ds# source segment<br>sub%di, %di<br>sub%si, %si<br>mov $0x8000, %cx<br>rep<br>movsw<br>jmpdo_move<br><br></code></pre></td></tr></tbody></table></figure><p>这段代码，也就是将system 模块移动到新的位置，新位置起始为0。</p><p>与以下c代码相同。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> add[<span class="hljs-number">0x90000</span>];<br><span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0x10000</span>; i&lt;<span class="hljs-number">0x90000</span>;i++){<br>add[j++] = add[i];<br>}<br></code></pre></td></tr></tbody></table></figure><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091459373.png" style="zoom:50%;"><p>重新规划后内存布局如下，</p><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091501381.png" style="zoom:50%;"><p><a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499667&amp;idx=1&amp;sn=a7e2297f16d048794fa31cceaa183fc9&amp;chksm=c2c5853ef5b20c286df24a28013f0fc3b0336790eca4a0d069ab831f6c536c03d1398893534b&amp;cur_album_id=2123743679373688834&amp;scene=189#wechat_redirect">切换到保护模式</a></p><p>实模式与保护模式的第一个区别：物理地址计算方式不同</p><p>实模式下：物理地址为段寄存器中的地址&lt;&lt;16 + 偏移地址。</p><p>保护模式下：段寄存器中 存的是段选择子，段选择子去全局描述符中寻找段选择符，从中取出段基地址 再加上偏移地址才是物理地址。</p><blockquote><p>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”。</p><p>“Any problem  in computer science can be solved by anther layer of indirection.”</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206061651461.png" style="zoom:50%;"><p><strong>段选择子结构</strong></p><p>由段描述符索引 以及TI、RPL组成</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206061654823.png"></p><p><strong>段描述符结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204040913252.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206061743389.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206061744063.png"></p><p><strong>全局描述符表寄存器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204040902532.png"></p><p>也就是说：<strong>进入保护模式之后，物理地址计算方式发生改变，在仅有段机制的情况下，段寄存器(cs)中存的不再是段基址，而是段选择子，段选择子结构如上，</strong></p><p><strong>段选择子中存的是段描述符索引，通过段描述符索引就可以从全局描述符表(gdt)中取出对应的段描述符结构，其中包含段基地址，段基地址+偏移地址就是物理地址。</strong></p><p><strong>全局描述符表(gdt)在哪存呢？内存中，在哪个位置呢？这时候就有一个专门的寄存器gdtr去存储gdt的位置，其结构如上。</strong></p><p>所以，以下前两句代码，也就是将idt/gdt的地址存储到idtr/gdtr中；中间的代码(gdt_48标签处)则描述了全局描述符表寄存器的配置值，低16位：gdt界限，也就是全局描述符表的长度，高32位，描述了全局描述符表的内存地址；后面的代码(gdt标签处)描述了3个段描述符，第一个为空，第二个是代码段描述符(type=code)，第三个是数据段描述符(type=data)，第二个和第三个基地址均为0，那么也就是说在后面不管通过段选择子选择的是代码段还是数据段，其基地址为0，实际物理地址（仅段模式机制下，否则称为线性地址）等于偏移地址。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">...<br>lidt fword ptr idt_48;// 加载中断描述符表(idt)寄存器，idt_48 是6 字节操作数的位置<br>lgdt fword ptr gdt_48      ;// 加载全局描述符表(gdt)寄存器，gdt_48 是6 字节操作数的位置<br>...<br>gdt_48:<br>dw800h         ;// 全局表长度为2k 字节，因为每8 字节组成一个段描述符项，所以表中共可有256 项<br>dw512+gdt,9h            ;// 4 个字节构成的内存线性地址：(0009&lt;&lt;16 + 0200)+gdt，也即90200 + gdt(即在本程序段中的偏移地址)。<br>...<br>gdt:<br>.word0,0,0,0  # dummy<br><br>.word0x07FF# 8Mb - limit=2047 (2048*4096=8Mb)<br>.word0x0000# base address=0<br>.word0x9A00# code read/exec<br>.word0x00C0# granularity=4096, 386<br><br>.word0x07FF# 8Mb - limit=2047 (2048*4096=8Mb)<br>.word0x0000# base address=0<br>.word0x9200# data read/write<br>.word0x00C0# granularity=4096, 386<br></code></pre></td></tr></tbody></table></figure><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091544587.png" style="zoom:50%;"><blockquote><p>这个图描述了如何从逻辑地址经过分段、分页之后得到物理地址的。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204041906123.png"></p></blockquote><p>开启A20线</p><blockquote><p>A20地址线是为了突破20位地址线的限制，变成32位可用，所以即使地址线有32位了，但是你如果不手动开启，还是会限制20位可用。现在的CPU位数都32位、64位，为了兼容以前的20位地址总线，便有了此选项。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">...<br>inb     $0x92, %al# open A20 line(Fast Gate A20).<br>orb     $0x02, %al<br>outb    %al, $0x92<br>...<br></code></pre></td></tr></tbody></table></figure><p>接着是对可编程中断控制器 8259 芯片的编程，一堆代码不用看，其作用就是重新配置中断号IRQ0-IRQ15的功能。</p><table><thead><tr><th align="center">PIC 请求号</th><th align="center">中断号</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">IRQ0</td><td align="center">0x20</td><td align="center">时钟中断</td></tr><tr><td align="center">IRQ1</td><td align="center">0x21</td><td align="center">键盘中断</td></tr><tr><td align="center">IRQ2</td><td align="center">0x22</td><td align="center">接连从芯片</td></tr><tr><td align="center">IRQ3</td><td align="center">0x23</td><td align="center">串口2</td></tr><tr><td align="center">IRQ4</td><td align="center">0x24</td><td align="center">串口1</td></tr><tr><td align="center">IRQ5</td><td align="center">0x25</td><td align="center">并口2</td></tr><tr><td align="center">IRQ6</td><td align="center">0x26</td><td align="center">软盘驱动器</td></tr><tr><td align="center">IRQ7</td><td align="center">0x27</td><td align="center">并口1</td></tr><tr><td align="center">IRQ8</td><td align="center">0x28</td><td align="center">实时钟中断</td></tr><tr><td align="center">IRQ9</td><td align="center">0x29</td><td align="center">保留</td></tr><tr><td align="center">IRQ10</td><td align="center">0x2a</td><td align="center">保留</td></tr><tr><td align="center">IRQ11</td><td align="center">0x2b</td><td align="center">保留</td></tr><tr><td align="center">IRQ12</td><td align="center">0x2c</td><td align="center">鼠标中断</td></tr><tr><td align="center">IRQ13</td><td align="center">0x2d</td><td align="center">数学协处理器</td></tr><tr><td align="center">IRQ14</td><td align="center">0x2e</td><td align="center">硬盘中断</td></tr><tr><td align="center">IRQ15</td><td align="center">0x2f</td><td align="center">保留</td></tr></tbody></table><p>打开cr0寄存器的第0位，也即开启了保护模式。模式的切换非常简单，重要的是前期的准备工作。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204040953220.png"></p><p>起初是先给ax赋值为0x0001，后面通过lmsw命令将ax的值给到cr0寄存器。</p><p>但是后来可以直接通过mov 指令读写cr0寄存器，这样就可以读出cr0的值，然后将0位置1，接着在写回cr0，这样也能实现。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#mov$0x0001, %ax# protected mode (PE) bit<br>#lmsw%ax# This is it!<br>mov%cr0, %eax# get machine status(cr0|MSW)<br>bts$0, %eax# turn on the PE-bit <br>mov%eax, %cr0# protection enabled<br></code></pre></td></tr></tbody></table></figure><p>接着就是直接跳转到物理地址 0 处了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.equsel_cs0, 0x0008 # select for code segment 0 (  001:0 :00) <br>ljmp$sel_cs0, $0# jmp offset 0 of code segment 0 in gdt<br></code></pre></td></tr></tbody></table></figure><p>首先将<code>sel_cs0</code>置为<code>0x0008</code>，由于是保护模式，所以<code>ds</code>为段选择子，其值为<code>0x0008</code>，<code>0b0000_0000_0000_1000</code>，描述符索引为<code>0b0000_0000_0000_1</code>，也就是<code>1</code>，前面我们设定的段描述符，第0个为空，第1个为代码段，第2个为数据段，也就是代码段，其基地址为0，所以此处也就是跳转到0地址处。</p><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>由最外层的Makefile可得，system由<code>boot/head.o</code>、<code>init/main.o</code>及其它组成，并且system在bootsect中被搬运至0处。</p><p>所以在setup中跳转到0处，也就是跳转到head中了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pg_dir:<br>.globl startup_32<br>startup_32:<br>movl $0x10,%eax<br>mov %ax,%ds<br>mov %ax,%es<br>mov %ax,%fs<br>mov %ax,%gs<br>lss stack_start,%esp<br>call setup_idt<br>call setup_gdt<br>movl $0x10,%eax   # reload all the segment registers<br>mov %ax,%ds# after changing gdt. CS was already<br>mov %ax,%es# reloaded in 'setup_gdt'<br>mov %ax,%fs<br>mov %ax,%gs<br>lss stack_start,%esp<br></code></pre></td></tr></tbody></table></figure><p>看下代码，刚开始有个标号<code>pg_dir</code>，这个是页目录，之后设置分页机制得时候，页目录会放这，覆盖这里得代码。</p><p>往下走，就是给eax赋值为0x10，给 ds、es、fs、gs赋值0x10(0b0001_0000)，也就是0b0001_0 即2，索引为2的段为数据段。</p><p>然后<code>lss stack_start,%esp</code>，将<code>stack_start</code>高位给ss，低16位给esp。（之前是0x9ff00，现在要换到_stack_start）</p><p>stack_start这个标号在sched.c中，（关于为什么是start_start 而不是_stack_start这个是因为cdecl调用规约中第4条:编译后的函数名前缀以一个下划线字符开始）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> user_stack [ <span class="hljs-number">4096</span>&gt;&gt;<span class="hljs-number">2</span> ] ;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br><span class="hljs-type">long</span> * a;<br><span class="hljs-type">short</span> b;<br>} stack_start = { &amp; user_stack [<span class="hljs-number">4096</span>&gt;&gt;<span class="hljs-number">2</span>] , <span class="hljs-number">0x10</span> };<br></code></pre></td></tr></tbody></table></figure><p>也就是将高位0x10给ss，低位<code>user_stack [4096&gt;&gt;2]</code> 的元素的下一个地址值给esp，0x10也就是0x0001_0000表示指向全局描述符的第0x0001_0个段，也就是第2个段为data段，其基地址为0。</p><p><code>call setup_idt</code>设置中断描述符表<br><code>call setup_gdt</code>设置全局描述符表</p><p>然后又重新设置一遍，为什么要重新设置？在上面设置中断/全局描述符表的时候，修改了gdt，所以要重新设置才会生效。</p><p>接下来重点看 <code>setup_idt</code>/<code>setup_gdt</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">setup_idt:<br>lea ignore_int,%edx<br>movl $0x00080000,%eax<br>movw %dx,%ax/* selector = 0x0008 = cs */<br>movw $0x8E00,%dx/* interrupt gate - dpl=0, present */<br><br>lea idt,%edi<br>mov $256,%ecx<br>rp_sidt:<br>movl %eax,(%edi)<br>movl %edx,4(%edi)<br>addl $8,%edi<br>dec %ecx<br>jne rp_sidt<br>lidt idt_descr<br>ret<br>...<br>idt_descr:<br>.word 256*8-1# idt contains 256 entries<br>.long idt<br>...<br>idt:.fill 256,8,0# idt is uninitialized #256项，每项8字节，填0<br></code></pre></td></tr></tbody></table></figure><p>设置256个中断描述符，每个中断描述符中的中断处理都指向<code>ignore_int</code>，这是个默认的中断处理程序，后面慢慢会被具体的中断程序覆盖。</p><p>setup_gdt也是如此，设置后的gdt如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gdt:   .quad 0x0000000000000000/* NULL descriptor */<br>.quad 0x00c09a0000000fff/* 16Mb */<br>.quad 0x00c0920000000fff/* 16Mb */<br>.quad 0x0000000000000000/* TEMPORARY - don't use */<br>.fill 252,8,0/* space for LDT's and TSS's etc */<br></code></pre></td></tr></tbody></table></figure><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091549575.png" style="zoom:50%;"><p>这部分代码有两个精彩的地方，一个是分页机制、另一个就是怎么进入main函数的。</p><p>配置完idt和gdt后，接着继续往下走，跳转到<code>after_page_tables</code>后，先是几个<code>push</code>，其中包含了c语言的世界的地址，然后一个跳转到<code>setup_paging</code>，给<code>ecx</code>分配大小为5*1024（5pages）,然后将<code>eax</code>清零，<code>edi</code>清零。接着将al中的数据（0）填充到edi起始的位置（0）处，方向为正向，大小为<code>5*1024*4</code>。（也就是说 <strong>从零地址开始前20k内存清零</strong>）</p><blockquote><p>cld;rep;stosl<br>cld设置edi或同esi为递增方向，rep做(%ecx)次重复操作，stosl表示edi每次增加4,这条语句达到按4字节清空前5*1024*4字节地址空间的目的。</p></blockquote><p>然后就把内存分成了这个样子，如下图，页表0-3正好可以将 16MB 空间完全覆盖（$(0x5000-0x1000)/4 * 4 / 1024=16MB$）</p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206081847610.png" style="zoom:50%;"><p>开启分页机制</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs assembly">...<br>jmp after_page_tables<br>...<br>after_page_tables:<br>pushl $0# These are the parameters to main :-)<br>pushl $0<br>pushl $0<br>pushl $L6# return address for main, if it decides to.<br>pushl $main<br>jmp setup_paging<br>L6:<br>jmp L6<br>...<br><br>.align 2<br>setup_paging:<br>movl $1024*5,%ecx/* 5 pages - pg_dir+4 page tables */<br>xorl %eax,%eax<br>xorl %edi,%edi/* pg_dir is at 0x000 */<br>cld;rep;stosl<br>movl $pg0+7,pg_dir/* 7--&gt;111-&gt; set User/supervisor Read/Write Present */<br>movl $pg1+7,pg_dir+4/*  --------- " " --------- */<br>movl $pg2+7,pg_dir+8/*  --------- " " --------- */<br>movl $pg3+7,pg_dir+12/*  --------- " " --------- */<br>movl $pg3+4092,%edi<br>movl $0xfff007,%eax/*  16Mb - 4096 + 7 (r/w user,p) */<br>std<br>1:stosl/* fill pages backwards - more efficient :-) */<br>subl $0x1000,%eax<br>jge 1b<br>cld<br>xorl %eax,%eax/* pg_dir is at 0x0000 */<br>movl %eax,%cr3/* cr3 - page directory start */<br>movl %cr0,%eax<br>orl $0x80000000,%eax<br>movl %eax,%cr0/* set paging (PG) bit */<br>ret/* this also flushes prefetch-queue */<br>...<br>.org 0x1000<br>pg0:<br><br>.org 0x2000<br>pg1:<br><br>.org 0x3000<br>pg2:<br><br>.org 0x4000<br>pg3:<br><br>.org 0x5000<br></code></pre></td></tr></tbody></table></figure><p>接着往下走，几个mov指令将页目录表的前几个空填上，<code>$pg0 ~ $pg4</code>地址如：0x1000、0x2000、0x3000、0x4000 对应页表地址为0x1、2、3、4（0x1000&gt;&gt;12）</p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206081846349.png" style="zoom:50%;"><p>那么<code>+7</code>又是什么意思？这个时候就必须了解一下 页目录项/页表项 的结构了。如下图所示，7 二进制位 0b0111 ，也就是对应的是低3位为1，第1位表示可读写、第2位表示用户/管理员 第3位表示页面级的写穿透，7也就是表示 当前页可读可写，管理员模式，写穿透等等。</p><p>也就是说 $pg0+7，$pg0 表示的是页表的地址，7表示的是页面的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206081849718.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206081849233.png"></p><p>那么知道了怎么存的，给你一个地址，是怎么转换的呢？</p><p>在没有分页机制之前，我们从逻辑地址经过分段机制之后，就变成了物理地址；现在呢，多了分页机制后，还需要在经过一次转换才能是真正的物理地址。</p><pre><code class=" mermaid">graph TDclassDef default fill:#fca104;A[逻辑地址]--分段机制--&gt;B["线性地址"]B--&gt;C{"是否开启分页"}C--&gt;|是&lt;br&gt;分页机制转换| D1["物理地址"]C--&gt;|否&lt;br&gt;直接就是物理地址| D2["物理地址"]</code></pre><p>那么是怎么转换的呢？是通过一个叫MMU的硬件来实现的，也叫内存管理单元，由它将线性地址转为物理地址。</p><p>首先线性地址为32位，会被拆分成 <strong>高10位：中间10位：低12位</strong>这样的格式。这种页表方案叫二级页表，第一级为页目录表PDE，第二级叫页表PTE</p><p>高12位负责在页目录表中找到一个页目录项，</p><p>中间10位在对应的页表中找到一个页表项，</p><p>低12位表示偏移地址。</p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206082006590.png" style="zoom:50%;"><p>比如：15M的一个线性地址，二进制表示为 0000000011_0100000000_000000000000，</p><p>也就是页目录表中的第4个页目录项<code>3</code>，<code>页表3</code>中的<code>第256项</code>，再加上<code>偏移地址0</code>，刚好为以<code>15M</code>起始的位置的大小为4K的空间</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206082019816.png"></p><p><code>edi</code>值设置为<code>$pg3+4092</code>，也即是<code>0x5ffc</code>，<code>eax</code>值为<code>0xfff007</code></p><p>这6行负责填满4个页表中所有项的内容，一共有 4(页表)*1024(项/页表) = 4096(项)</p><p>每项表示一个4kb空间，则一共可以表示 4096*4kb = 16Mb。</p><p>一个页表中最后一项地址为 1023 * 4 = 4092，所以 $pg3+4092 表示页表3中的最后一项的地址</p><p>每项的内容是：当前项所映射的物理内存地址 + 该页的标志（此处均为7）</p><p><code>$pg3+4092</code> 中表示最后一项，也即最后一个4kb空间，最后一个4kb空间起始地址为<code>16Mb-4096</code>，在加上页属性<code>7</code>，也就是<code>$0xfff007</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movl $pg3+4092,%edi<br>movl $0xfff007,%eax/*  16Mb - 4096 + 7 (r/w user,p) */<br>std<br>1:stosl/* fill pages backwards - more efficient :-) */<br>subl $0x1000,%eax<br>jge 1b<br></code></pre></td></tr></tbody></table></figure><p>此后，分页就结束了，这个时候只需要开启分页机制的开关就可以了。开关在cr0的最高位，将其置为1，开启了分页机制。一个ret直接返回</p><p>设置pg_dir，到cr3，将cr0的最高位置为1。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xorl %eax,%eax/* pg_dir is at 0x0000 */<br>movl %eax,%cr3/* cr3 - page directory start */<br>movl %cr0,%eax<br>orl $0x80000000,%eax<br>movl %eax,%cr0/* set paging (PG) bit */<br>ret/* this also flushes prefetch-queue */<br></code></pre></td></tr></tbody></table></figure><p><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206090010988.png"></p><p>如何进入main</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">after_page_tables:<br>pushl $0# These are the parameters to main :-)<br>pushl $0<br>pushl $0<br>pushl $L6# return address for main, if it decides to.<br>pushl $main<br>jmp setup_paging<br>L6:<br>jmp L6<br></code></pre></td></tr></tbody></table></figure><p>在after_page_tables 中连着5个push，将数据依次压入栈，最后的结构如下</p><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091558424.png" style="zoom:50%;"><p>注意setup_paging的最后一条命令是ret，ret被叫做返回指令，返回指令的话肯定得有返回的地址，计算机会机械的把栈顶的元素当作返回地址。在具体的说，就是将esp寄存器的值给到eip中，而cs:eip就是CPU要执行的下一条指令的地址。而栈顶此时存放的为main(start)函数的地址，所以ret后就会跳转到main(start)中了。其中<strong>L6会作为main的返回值</strong>，但main(start)是不会返回的，其它<strong>三个值本意是作为main(start)函数的参数</strong>，但没有用到。</p><blockquote><p>关于 ret 指令，其实 Intel CPU 是配合 call 设计的，有关 call 和 ret 指令，即调用和返回指令，可以参考 Intel 手册：</p><p>Intel 1 Chapter 6.4 CALLING PROCEDURES USING CALL AND RET</p></blockquote><p>到此，汇编部分就结束了。主要有如下操作，</p><p><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202204071044648.png"></p><p>整个内存分布如下：</p><img src="https://fastly.jsdelivr.net/gh/Gonglja/imgur/img/202206091610884.png" style="zoom:50%;"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/cx_vaRTcC29h0pWkJPpqQQ">调试 Linux 最早期的代码</a></li><li><a href="https://blog.csdn.net/weixin_45709295/article/details/120007503">Ubuntu20.04编译安装qemu</a></li><li><a href="https://blog.csdn.net/qq_36393978/article/details/118353939">qemu运行虚拟机无反应，只输出一行提示信息:VNC server running on 127.0.0.1:5900</a></li><li><a href="http://blog.chinaunix.net/uid-26833883-id-3746968.html">连接的时候指定-Ttext 和指定-Tmap.lds的区别</a></li><li><a href="https://www.runoob.com/linux/linux-comm-dd.html">Linux dd 命令</a></li><li><a href="http://www.only2fire.com/archives/87.html">BIOS int 13H中断介绍</a></li><li><a href="https://zhuanlan.zhihu.com/p/259625135">汇编指令——用GDB调试汇编</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树</title>
      <link href="/posts/9faa78d2/"/>
      <url>/posts/9faa78d2/</url>
      
        <content type="html"><![CDATA[<h3 id="设备树语法"><a href="#设备树语法" class="headerlink" title="设备树语法"></a>设备树语法</h3><p>设备树示例：<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204290903331.png"></p><h4 id="节点格式"><a href="#节点格式" class="headerlink" title="节点格式"></a>节点格式</h4><p><code>label: node-name@unit-address</code></p><ul><li><p>lable: 标号（可省略，其作用方便引用node，类似汇编中的label）</p></li><li><p>node-name: 节点名字</p></li><li><p>unit-address: 单元地址</p></li></ul><h4 id="属性格式"><a href="#属性格式" class="headerlink" title="属性格式"></a>属性格式</h4><p><code>name=value</code></p><p>value有多种取值方式。</p><ul><li><p>一个32位的数据，用尖括号包围起来，如</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">interrupts = &lt;<span class="hljs-number">17</span>&gt;<br></code></pre></td></tr></tbody></table></figure></li><li><p>一个64位数据（使用2个32位数据表示），用尖括号围起来，如：</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">clock-frequency = &lt;<span class="hljs-number">0x00000001</span> <span class="hljs-number">0x00000000</span>&gt;<br></code></pre></td></tr></tbody></table></figure></li><li><p>一个有结束字符的字符串”disabled”，如</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">status = <span class="hljs-string">"disabled"</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>字节序列，用中括号包起来</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">local-man-address = [<span class="hljs-number">1</span>a <span class="hljs-number">2b</span> <span class="hljs-number">3</span>c <span class="hljs-number">4</span>d <span class="hljs-number">5</span>e <span class="hljs-number">6f</span>] <span class="hljs-comment">//每个byte使用2个16进制数来表示</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>也可以是各种值的组合，用<code>，</code>隔开</p>  <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">compatible = <span class="hljs-string">"samsung,smart210"</span>, <span class="hljs-string">"samsung,s5pv210"</span>;<br></code></pre></td></tr></tbody></table></figure></li></ul><h4 id="一些标准属性"><a href="#一些标准属性" class="headerlink" title="一些标准属性"></a>一些标准属性</h4><h5 id="compatiable-属性"><a href="#compatiable-属性" class="headerlink" title="compatiable 属性"></a>compatiable 属性</h5><p>其本意为“兼容”，对于某个LED，内核中有三个驱动A、B、C支持它。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">led {<br>    compiable = <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>;<br>};<br></code></pre></td></tr></tbody></table></figure><p>内核启动时，就会为这个LED按照A-B-C顺序为它寻找驱动程序。</p><h5 id="model-属性"><a href="#model-属性" class="headerlink" title="model 属性"></a>model 属性</h5><p>model属性与<code>compatiable</code> 有些相似，但又不同。</p><p>compilable是一个字符串序列，表示兼容什么，model指明这个硬件具体是什么。比如：</p><p>单板兼容samsung的smart210和s5pv210，这个板子是基于s5pv210的smart210</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">model = <span class="hljs-string">"SMART210 based on S5PV210"</span>;<br>compatible = <span class="hljs-string">"samsung,smart210"</span>, <span class="hljs-string">"samsung,s5pv210"</span>;<br></code></pre></td></tr></tbody></table></figure><h5 id="status-属性"><a href="#status-属性" class="headerlink" title="status 属性"></a>status 属性</h5><p>status 属性是和设备状态有关的，属性值也是字符串，字符串是设备的状态信息</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204291020891.png"></p><h5 id="address-cells-和-size-cells属性"><a href="#address-cells-和-size-cells属性" class="headerlink" title="#address-cells 和 #size-cells属性"></a>#address-cells 和 #size-cells属性</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">address-cells: address要用多少个<span class="hljs-number">32</span>位数来表示<br>size-cells: size要用多少个<span class="hljs-number">32</span>位数来表示<br></code></pre></td></tr></tbody></table></figure><p>比如一段内存，怎么描述它的起始地址和大小？</p><p>以下示例中，<code>address-cells</code>为1，表示用1个32位数表示地址，即用<code>0x80000000</code>表示起始地址</p><p><code>size-cells</code>为1，表示用1个32位数表示大小，即用<code>0x20000000</code>表示大小</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">/ {   <br>    <span class="hljs-meta"># address-cells = <span class="hljs-string">&lt;1&gt;</span>;   </span><br>    <span class="hljs-meta"># size-cells = <span class="hljs-string">&lt;1&gt;</span>;   </span><br>    memory {   <br>        reg = &lt;<span class="hljs-number">0x20000000</span> <span class="hljs-number">0x20000000</span>&gt;;   <br>    };   <br>};<br></code></pre></td></tr></tbody></table></figure><h5 id="reg-属性"><a href="#reg-属性" class="headerlink" title="reg 属性"></a>reg 属性</h5><p>reg本意是register，用来表示寄存器地址。但在设备树中，用来描述一段空间。对于ARM系统，寄存器和内存是统一编址的，访问寄存器时用某块地址，访问内存时用某块地址，在访问方法上没有区别。</p><p>reg属性的值，是一系列的”address size”，用多少个32位的数来表示address和size，是由#address-cells 和 #size-cells决定的。</p><h5 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h5><p>过时了，建议不用。值是字符串，用来表示节点的名字。在跟platform_driver匹配时，优先级最低。compiable属性在匹配过程中，优先级最高。</p><h4 id="常用的节点"><a href="#常用的节点" class="headerlink" title="常用的节点"></a>常用的节点</h4><h5 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h5><p>用/标识根节点，如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">/ {    <br>        model = <span class="hljs-string">"SMART210 based on S5PV210"</span>;    <br>        compatible = <span class="hljs-string">"samsung,smart210"</span>, <span class="hljs-string">"samsung,s5pv210"</span>;    <br> ...<br>};<br></code></pre></td></tr></tbody></table></figure><h5 id="CPU-节点"><a href="#CPU-节点" class="headerlink" title="CPU 节点"></a>CPU 节点</h5><p>一般不需要我们设置，在dtsi中都设置好了。</p><h5 id="memmory-节点"><a href="#memmory-节点" class="headerlink" title="memmory 节点"></a>memmory 节点</h5><p>厂商不知道板子要用多大的内存，所以此处需要自行设定</p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">memory {   <br>      reg <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0</span>x20000000 <span class="hljs-number">0</span>x20000000&gt;<span class="hljs-comment">;   </span><br>}<span class="hljs-comment">;  </span><br></code></pre></td></tr></tbody></table></figure><p>关于设备树更详细的语法，参考 <a href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.4-rc1/devicetree-specification-v0.4-rc1.pdf">devicetree-specification-v0.4-rc1.pdf</a></p><p>和 <a href="https://www.elinux.org/images/c/cf/Power_ePAPR_APPROVED_v1.1.pdf">Power_ePAPR_APPROVED_v1.1.pdf</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/135280350">【Linux笔记】设备树基础知识</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> device-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp使用chrono获取当前时间</title>
      <link href="/posts/d152f189/"/>
      <url>/posts/d152f189/</url>
      
        <content type="html"><![CDATA[<h1 id="cpp使用chrono获取当前时间"><a href="#cpp使用chrono获取当前时间" class="headerlink" title="cpp使用chrono获取当前时间"></a>cpp使用chrono获取当前时间</h1><p>有时候我们需要测试一个函数的运行时间，可以使用 <code>std</code>中的<code>chrono</code>来完成此功能，示例代码如下。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>测试代码如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>  <span class="hljs-comment">// 获取当前时间</span><br>  std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><br>  <span class="hljs-comment">// 距离1970-01-01 00:00:00的纳秒数</span><br>  std::chrono::nanoseconds d = now.<span class="hljs-built_in">time_since_epoch</span>();<br>  std::cout &lt;&lt;<span class="hljs-string">"current nanoseconds: "</span> &lt;&lt; d.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// 转换为微秒数, 会有精度损失</span><br>  std::chrono::microseconds mcrosec = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(d);<br>  std::cout&lt;&lt;<span class="hljs-string">"current microseconds: "</span> &lt;&lt; mcrosec.<span class="hljs-built_in">count</span>() &lt;&lt;std::endl;<br><br>  <span class="hljs-comment">// 转换为毫秒数, 会有精度损失</span><br>  std::chrono::milliseconds millsec = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(d);<br>  std::cout&lt;&lt;<span class="hljs-string">"current milliseconds: "</span> &lt;&lt; millsec.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>  <br>  <span class="hljs-comment">// 转换为秒数,会有精度损失</span><br>  std::chrono::seconds sec = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(d);<br>  std::cout&lt;&lt;<span class="hljs-string">"current seconds: "</span> &lt;&lt; sec.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// 转换为分,会有精度损失</span><br>  std::chrono::minutes minutes = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(d);<br>  std::cout&lt;&lt;<span class="hljs-string">"current minutes: "</span> &lt;&lt; minutes.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204252009405.png"></p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>测试代码如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>     <span class="hljs-comment">// 计算一段程序运行的时间，单位ms</span><br>    <span class="hljs-keyword">auto</span> t1 = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()).<span class="hljs-built_in">count</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000000</span>;i++);<br>    <span class="hljs-keyword">auto</span> t2 = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()).<span class="hljs-built_in">count</span>();<br>    std::cout &lt;&lt; t2 - t1 &lt;&lt; std::endl;<br>   <br>    <span class="hljs-comment">// 计算一段程序运行的时间，单位us</span><br>    <span class="hljs-type">int64_t</span> t11 = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds &gt;(std::chrono::system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()).<span class="hljs-built_in">count</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000000</span>;i++);<br>    <span class="hljs-type">int64_t</span> t12 = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds &gt;(std::chrono::system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()).<span class="hljs-built_in">count</span>();<br>    std::cout &lt;&lt; t12 - t11 &lt;&lt; std::endl; <br><br>    <span class="hljs-comment">// 计算一段程序运行的时间，单位ns</span><br>    <span class="hljs-type">int64_t</span> t21 = std::chrono::system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000000</span>;i++);<br>    <span class="hljs-type">int64_t</span> t22 = std::chrono::system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>();<br>    std::cout &lt;&lt; t22 - t21 &lt;&lt; std::endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204252012442.png"></p><p><strong>需注意：不同的时间精度用来存储的类型可以不同，但需要满足其条件，否则会溢出。</strong></p><table><thead><tr><th>单位</th><th>长度</th></tr></thead><tbody><tr><td>nanoseconds/纳秒</td><td>至少 64bits 的有符号数</td></tr><tr><td>microseconds/微妙</td><td>至少 55bits 的有符号数</td></tr><tr><td>milliseconds/毫秒</td><td>至少 45bits 的有符号数</td></tr><tr><td>seconds/秒</td><td>至少 35bits 的有符号数</td></tr><tr><td>minutes/分</td><td>至少 29bits 的有符号数</td></tr><tr><td>hours/时</td><td>至少 23bits 的有符号数</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.cplusplus.com/reference/chrono/">cpp reference chrono</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在ubuntu下更新自编译内核</title>
      <link href="/posts/6b3e9b20/"/>
      <url>/posts/6b3e9b20/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在ubuntu下下载源码更新最新的内核呢？"><a href="#如何在ubuntu下下载源码更新最新的内核呢？" class="headerlink" title="如何在ubuntu下下载源码更新最新的内核呢？"></a>如何在ubuntu下下载源码更新最新的内核呢？</h1><h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><p>可以有几种方式获得源码，一种通过apt命令直接安装，也可直接在内核网站下载最新的，本文直接下在最新版内核。</p><h3 id="apt-安装"><a href="#apt-安装" class="headerlink" title="apt 安装"></a>apt 安装</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install linux-source-5.13.0<br></code></pre></td></tr></tbody></table></figure><p>源码会下载到/usr/src下，且不会解压，可以拷贝至用户目录，再解压。</p><p>拷贝到自定义目录</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /usr/src/linux-source-5.13.0 /path/to/anywhere<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接着修改文件权限为当前用户权限</span><br>sudo chown 当前用户组:当前用户 文件（夹）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时就可以直接解压了，不需要root权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如因权限问题解压错误，一定要确保当前文件夹权限为当前用户，否则就得需要root权限解压</span><br>tar -jxvf linux-source-5.13.0.tar.bz2<br><br></code></pre></td></tr></tbody></table></figure><h3 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h3><p>直接在 <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/</a> 下载最新，可能直接下载会比较慢，有能力的还是科学一下。</p><p>也可以使用镜像源，比如阿里云的 <a href="https://mirrors.aliyun.com/linux-kernel/v5.x/">https://mirrors.aliyun.com/linux-kernel/v5.x/</a></p><blockquote><p>小tips</p><p><code>.tar.xz</code>如何解压？</p><p>首先 <code>xz -dk linux-5.17.4.tar.xz</code>然后 <code>tar -xvf linux-5.17.4.tar</code></p><p>或者 <code>tar -Jxvf linux-5.17.4.tar.xz</code></p></blockquote><h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><p>获取当前内核配置并配置</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /boot/config-5.13.0-40-generic ./.config<br></code></pre></td></tr></tbody></table></figure><p>修改配置</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make menuconfig<br></code></pre></td></tr></tbody></table></figure><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>安装依赖</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install libelf-dev dwarves bison flex libssl-dev<br></code></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -j$(nproc)<br>make moudules -j$(proc)<br></code></pre></td></tr></tbody></table></figure><p>报错 <code>&lt;stdin&gt;:1:10: fatal error: libelf.h: No such file or directory</code></p><p>缺少libelf-dev ，apt命令安装</p><p>报错 <code>make[1]: *** No rule to make target 'debian/canonical-certs.pem', needed by 'certs/x509_certificate_list'.  Stop.</code></p><p>在.config中搜索 CONFIG_SYSTEM_TRUSTED_KEYS，删除后面的值。</p><p>下面的那个也要删除。</p><p>错误<code>BTF: .tmp_vmlinux.btf: pahole (pahole) is not available</code></p><p>安装dwarves <code>sudo apt install dwarves</code></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先安装模块</span><br>sudo make modules_install <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在安装内核</span><br>sudo make install <br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新grub</span><br>sudo update-grub2<br></code></pre></td></tr></tbody></table></figure><h2 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h2><p>通过uname -a 查看版本</p><p>安装完成后重启前，</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Linux ubuntu21 5.13.0-40-generic #45-Ubuntu SMP Tue Mar 29 14:48:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></tbody></table></figure><p>重启后， 已经是最新版本的了</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Linux ubuntu21 5.17.4 #2 SMP PREEMPT Sun Apr 24 17:07:59 CST 2022 x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></tbody></table></figure><p>由于是虚拟机，最好重新安装下 <code>open-vm-tools</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sudo apt uninstall open-vm-tools<br></code></pre></td></tr></tbody></table></figure><h2 id="移除旧版内核"><a href="#移除旧版内核" class="headerlink" title="移除旧版内核"></a>移除旧版内核</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/371464316">Ubuntu内核编译</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人为什么会愤怒</title>
      <link href="/posts/d05aad81/"/>
      <url>/posts/d05aad81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自 <a href="https://zhuanlan.zhihu.com/p/27595310">https://zhuanlan.zhihu.com/p/27595310</a></p></blockquote><p>​一个通常的论调认为，人会愤怒是因为无能，无力于改变令自己不满意的现状，故而通过愤怒来表达对自己急于改变现状又不知道如何促成这种改变之窘境的恨意。这种观点无非认为，愤怒是多余的。只要冷静下来，看清楚现实和获得改变的唯一路径，并且正儿八经地去行动，就无需愤怒来激发或促成整个过程——这种观点认为，作为一种情绪化的多余，愤怒是对解决问题的最有效过程的一种惰性的阻碍。人们应当学会谦抑，时刻控制自己的怒火，从而全身心投入在解决问题的过程中，哪怕处于没有解决方案和通向胜利的希望，也不应当把精力浪费在情绪的宣泄中，只有如此，人类才能以最高的效率和最快的速度获得成功。</p><p>​然而，问题是，人类要获得的成功是哪种成功？更进一步，人类能获得任何意义上的成功吗？只要考虑到死亡的必然性，上面两个唐突的发问就立刻显得和蔼可亲了。既然人类的一切努力最终都面临不可调和的僵局，那么为什么要把那个愚蠢的终点称作成功呢？亲身经历和体验者无论如何都无法使他的一切努力所兑换的回报得到保存，他和他所获得的一切都必须被强迫着离去、消失、毁灭，最后被遗忘，他所获得的结局越美好，这个结局之后的结局，就越唏嘘，越令人愤恨。</p><p>​对于死亡的设定，我们除了为造物主的无情表示愤怒之外，别无他术。在此，愤怒即是绝对无能者内在抗议的外部迸发。这种抗议当然是负面的、无用的、多余的，因为它所搦战的对象恰恰是比它本身更负面、无用、多余的东西。愤怒的多余，在于它是那绝对多余的愚蠢秩序在心灵上制造了伤害的延宕，心灵以一种反抗的姿态，将这种创伤扭转为意志本身的迸发，而非单纯被动的痛苦，在这个意义上，愤怒之无用、愤怒之多余，恰恰是它的意义和价值，即将那曾经现身的整体秩序的残暴、无用和多余给标示出来，它在严格的康德哲学的意义上，将一个特殊而不合理的普遍秩序，扭转为一个普遍秩序中的不合理的特殊现象，并且以此来宣告一个更为合理的普遍秩序的预先在场。“事情本来可以更好！”愤怒者如是说道。尽管在现实的时间中，事情本来（在不可更改的过去）就变得很糟糕了，但理性通过愤怒宣告了一个虚拟的时间维度的存在，它关乎一种新的价值，但却显示为事情原本应当存在的样式，这种新的价值存在于宇宙秩序尚未在现实中蛮横地获得其合法性的本体论意义上的起源性的过去，事情本来——在这种建基于比现存制度更原初的根基的新价值意义上——可以变得更好。这种“本来”，不适合被简单地理解为“应当”，因为“应当”吁求的是现存秩序的背书，即按照现存的价值秩序，事情应当怎样，但由于某些不重要的偏差，它不太幸运地没有获得其在价值秩序中应当获得的地位而已——这种和实然相对立的所谓应然，早已在流俗的道德说教中被招安而失去了反思力。与它恰恰相反，愤怒所吁求的那种“本来”表明，有问题的不是那些不重要的偏差和偶然，而是这些自我标榜为秩序、必然性的“应当”本身，这些价值秩序失去了反思其秩序运行根基的能力，并且将所有悲剧性的创伤归咎于偶然的巧合、该死的他者和理性的懈怠。</p><p>​因此，愤怒本身是一种行动，他向他者彰显他对于既定秩序的拒绝臣服和蔑视，并且以挑衅的姿态回应秩序代言人对他进行毁灭的威胁。严格意义上讲，愤怒只能被压抑，而无法被消解，除非它依循自己的逻辑形成一整套新的秩序，并将之运用于现实，暴力地调整整个现实在象征系统中的运行模式。</p><p> 既然愤怒有所吁求，那么我们尽可以在此想象一下它所要求的最根本的改变会是什么样的，这涉及一系列宇宙和心灵生成过程中被随意设定的本体论框架，而愤怒，作为理性的话语，认为这些框架是彻头彻尾的愚蠢。</p><p>​首先，是心灵不得不整个地接受痛苦和快乐的肤浅的表象模式、僵死的赏罚机制和残忍的内在暴力的操纵。心灵对于宇宙强加于其上的苦乐定义是不设防的，它的可怜的武器仅剩下两个，一个是在符号和幻想所构建的象征系统里无止境地循环，并满足于少得可怜的剩余快感，另一个即彻底放弃抵抗，彻底放弃在游戏中获胜的所有机会，彻底成为任由自己被迫享乐和受尽折磨的活死人。这一僵局的根源就是没有任何根源，它自我设立为生存的基本法则，一些特定的情境化体验将带来快乐、信念、希望和价值，另一些则会带来毁灭和痛苦，两者的差异优先于一切意识结构、主导着生存。自由的个体是这一结构中永恒的奴仆，在辛勤而自由的劳动中倾尽一生来追求快乐减去痛苦所获得的剩余快感，标准的打着希望幌子的意识形态总是这样提倡：未来的快乐和过去的痛苦，是数学上正负数的关系，它们具备同种本体论形态的实存，可以在这一意识形态提供的幻想框架下相互抵消、清零，从而在死亡到来前获得总体为正的剩余快感，这一剩余快感就等于个体的死亡的价值和意义。这种关于死亡、价值、苦乐的意识形态主流，现在支配着人类人口中的大多数个体的内在反思，剩余快感和剩余价值，和资本主义的逻辑实际上是同一个东西，我们臣服于这一套生命的价值论，当然我们也自愿臣服于资本主义。</p><p>​除非我们选择第二条道路，即除非我们彻底放弃抵抗，彻底放弃在苦乐清零获得盈余的游戏中获胜的希望，我们才能开始抵抗。这意味着什么？意味着我们必须首先不仅仅给予痛苦和快乐同样的本体论地位：它们同样真实地发生了、被我体验了、在历史中占据了时间，我们更要给它们同样的伦理学地位：它们同样善良、同样邪恶、同样恰如其分、同样多余。它们都在同一个象征系统中占据了位置，并且依凭这个系统设置的位置来发挥特定的功能，意识无法直接调节这个系统的运作和设置，它或许可以通过艰苦而又长期的训练来取得一定的改变，但在一开始，没有任何迹象和线索表明，哪种类型的特定努力将导向整个系统的改善而非恶化，此外，即便特定努力导致了较为理想的改变，这整个系统依然是僵死的，它总是要求巨大的成本才能获得一丁点的进展。总的看来，它似乎以人的欲望的投入和快感的支付为它的目的，是一个邪恶的深渊。</p><p>​经过艰苦的艺术训练的艺术家最能够感受这一深渊的荒谬和邪恶，它逼迫你必须通过无数青春岁月的付出，才能获得对一个愚蠢道具，以及听觉、乐感、肌肉控制等等的彻底掌握，从而在表演中获得快感，建构其对这一愚蠢道具和演奏行为的“爱”。好似这个系统将你投入其中的无数快感当做存款一样，在许多年之后终于抽取了利息支付给你。你获得的仅仅是非常微薄的利息，它并不保证你作为一个，例如，器乐演奏者，还能进一步获得作曲灵感、把音乐内涵化为思想性艺术品的形而上能力、从音乐中获取对生活进行反思的智慧等等，除了音乐在社会审美谱系中的既定价格表下的愚蠢回报之外，这个系统不保证你获得任何属于你自己的东西，尽管它宣称塑造了你的毅力、品格和高雅的品味，那些玩意除了投入到进一步的自我榨取之外，毫无颠覆整个奖惩机制的意义。</p><p>​因此我们必须对框架内的价值秩序，进行一次彻底的抽离，把我们自身从系统中抽离出来，把重要性首先预设成全部归零的状态，亦即康德意义上背叛自身所归属的象征序列的主体性“启蒙”，这一把将内在热情完全熄灭的抽离，是自由的纯粹形式化的起点，它看上去是彻底的虚无主义，因为它通常导向的是彻底的自我放弃和随波逐流。抵达这一地点的个人，往往沉浸在犬儒式的最低限度的自我反思的挣扎中，并且把荒谬和愚蠢现实本身具有的真实性抽离出来，浇筑在主体心灵的内在不协调当中，这样的个体必须依靠反讽、幽默和隐藏在规规矩矩的冷静表情后面的狂野而又倒错的各种爱欲结构（性、冥想、施虐、犯罪），才能够实现包含他心灵在内的整个系统的动态和谐。矛盾会不断地依照康德的从“特殊的普遍性框架”到“普遍框架下的特殊现象”这一逻辑，转移并投射为各种具象化的情感固着，譬如消费主义恋物、迷信偶像、原教旨主义等等。</p><p>​那么如何在这个全部归零的基础上，不走向一种爱欲投射的倒错呢，即如何不把外部的系统性僵局再反过来接纳为内在心灵的固有缺陷，并以一种“爱”的姿态错误地包容它，并任由它从我们的内在出发，投射出多余的幻象和意识形态来进一步迷惑我们呢？</p><p> 在回答这个问题之前，首先要弄清楚犬儒的道路如何偏离了它的起点：坚持主体从价值秩序中的抽离本身，就已经设定了犬儒式的视角的不可能性。既然一种外在的上帝般的全能是不可能的，那么同样的，犬儒所具有的冷眼旁观一切外部世界的荒谬和愚蠢的做法，这种把内在灵魂的纯洁性建立在对外部丑陋世界的凝视过程的反射机制本身，也是彻彻底底的荒谬。为什么？因为犬儒的凝视本身，按照它自身的逻辑，即在无条件的自我反思活动中，也应当被凝视为愚蠢的，所以犬儒看到的自己的内心，自己的高人一等的愚蠢模样，一样令人作呕，他并无任何内在空间可以逃遁、可以保持超然、可以表明自身具有最低限度的反思性和维护诗性正义的余地。在严格意义上，犬儒等同于那些把世界看做是善良美丽而加以大肆毁坏以获取快感的恶棍，他们的力比多机制都是从善恶的结构性差异和抗争的定向运动中汲取一种嘲笑他者无能的快感，并通过这种嘲笑，来模拟和看顾整个世界的父性权威进行对话、进行灵魂交媾的肛欲层面的乱伦式享乐。</p><p>​这样，我们可以顺理成章地回答之前的问题，如何不成为犬儒：即拒绝一切从善恶的结构性差异中汲取凝视的快感。善恶之间的结构性差异当然存在，它也当然是愚蠢的、僵死的、自相矛盾的，为什么？因为它处在受灵魂的挣扎和抗争的变革之中，它本身是愚蠢的和僵死的，不是因为它的背后有一个无法主动、直接地实现它的欲望的被阉割的父性神灵在那里鞭笞着宇宙中的所有灵魂，这是一种被害妄想。恰恰相反，善恶的结构性差异，人内在意识被迫接纳外部世界中苦乐二元的各种事物的象征化秩序，的背后，并没有任何形而上、超然的存在者在那里，为它的意义作出任何保障。人类在严格意义上是自由的，他完全可以通过他所能尝试的任何途径，去改变整个结构的愚蠢性，让它变得更加合理、开放、自由，人类可以站出来扮演象征秩序背后的那个神灵般的角色，而且，强制的享乐主义国家机器也确实在做着这样的事情，以催动整个资本主义剥削系统的持久运行。问题并不是那个创造了整个痛苦和快乐的生存系统的上帝已经死了，问题在于，这个已经死了的上帝，还没有意识到他自身的死亡。他从未获得一种实体性的存在，却始终停留在象征秩序的层面，使得整个系统的运作看上去一直有他在那里支撑着。上帝的意识，在现象学的层面，严格意义上等同于所有信仰上帝（不仅仅局限于宗教意义上的上帝，而是指所有具备支撑整个苦乐二元的象征机制的本体性力量的具象化）的个体的意识，这些个体并不具备对他们自己的意识的所有权，相反，他们只有在这些由他们自己的意识组建起来的意识形态机器的征召下，才成为他们心目中带着最低限度负罪感的以自由行动的主体。</p><p>​因此，我们作为并非这种主体的重新清醒过来的个人，必须对上帝所在的超越性维度说“不”，必须从整个象征系统中把一个特定的词抽离出来，并将它运用在对整个表象背后的本质、苦乐二元的流变世界背后的永恒宁静上，并单单将这个词，作为一个新的生存视角的构成性例外道出来，“不”。在这一运动完成之前，绝对的抽离意味着将固有视角中的普遍的否定性夸大为整体的肯定性的虚无，在这个肯定中起作用的，是整个框架自我拯救的垂死挣扎——框架努力使得自身具有整体性、具有完整一致的外在边界，即便是将所有内容忍受为虚无也在所不惜。恰恰是这一自我拯救的绝望尝试，暴露了框架本身的绝对脆弱，而我们，恰恰要反其道而行之。我们必须努力从这种绝对的抽离中回转过来，将否定性的“不”坚持到底。不是迷恋于“虚无”的整体图像，迷恋于我们制作这一图像所显现出来的犬儒式全能，相反，我们需要对这一图像本身说“不”，重新回到荒谬而愚蠢的苦乐游戏和价值序列中去，去寻找那个绝对的“不”，那个为整个框架所不能忍受的构成性例外，那个多余而又令人恶心的事物，并抓着框架所自我吹嘘的普遍性不放，向它下达命令，要求框架将那些例外强行归并为自身的一部分，要求框架将它所不能包容、并排除在外的原则的具象化客体，凄楚而又羞涩地崇拜为它的至爱，从而震荡出系统本身的精神分裂。在这一过程中人们将会见证到系统最淫荡而又性无能地对它的例外进行自作多情的调情，从而把对系统的恐惧和愤怒，化作一种深刻的鄙视和轻蔑。</p><p>​癌症所带来的痛苦，无非是神经系统屈服于永生者的谄媚，并且把一切递质的快感经济学价值贬损为负数的零。同样的，降生于各个愚蠢时代的清醒的灵魂所遭遇的痛苦和悲伤，无非代表了整个历史结构对于作为永生者的象征链条和资本主义的自我驱动的内在谄媚，这种内在谄媚提醒我们，作为反叛者，时刻保留一个暴力性的空间，在它之中储藏足以焚毁一切“历史性”成就的火焰，并随时随地回到系统存在之前，回到随机状态被莫名其妙约定为律法之前，来铭刻这一切早已死亡的印记。这一行动不仅仅是回溯性的，它对于通过回忆建构真实图像的时间性，态度是粗鲁的，印象是负面的。这一行动应当被描述为，强迫历史重新开始，在严格的意义上重新开始，以解决那些尚未解决的、尚未被意识到需要解决的、尚未出现的问题。愤怒本身成为新问题，它通过创造新问题来拯救问题本身。就像上帝=存在一样，愤怒=不。正因如此，沉默，纯粹的无所表示的沉默，以循规蹈矩和不加张扬来维持的无所表示的动态平衡着的沉默，才是愤怒的唯一形式。我们在表象为无穷无尽的怒吼中的愤怒，不过是逼迫他人聆听内在的沉默，不过是在逼迫自己去聆听到他人的内在沉默，不过是在通过自我和他人的反射性的镜像关系，使得沉默，在愤怒和恐惧的层级差异的共鸣中，发出声来。意识到这点后，那么，真正的愤怒，真正的沉默，本身就震耳欲聋了。在无限的内心宁静中，真正的烈焰般的愤怒才得以涌起。</p><p>​当然，只要说了“不”，后面可以说任何话。“不，我对整个世界整个历史整个苦乐存亡的生存论结构不满意，重来！”——严肃的承担这个命题的重量，你的心灵就获得了承受痛苦和悲伤的某种能力，它完全来自你的自由本身，你的处于永久下坠之中不知何时粉身碎骨的自由本身。相反，另外，通过不说“不”，人类事实上可以在无穷倒退的恶的无限中永生（成为一种非人的邪恶灵魂），即不持斗争的立场，对一切恶心的现实表示热爱和接纳，在死亡来临前，把所有的心力投注在回忆自己对现实的热爱和臣服之中，弃绝一切否定的可能，在回忆这种普遍的爱中，发现那个正在回忆着什么的自己，爱他，进一步爱他的回忆，在爱着这整个单调无聊的神圣的重复过程中，单纯的爱本身成为了意识的“活”的形式，“爱那个爱着爱的自己，爱那个爱着自己的爱”，就这样，死亡来临了，不，我指的不是肉体的死亡，而是作为有尊严的存在形式的灵魂，早已经死了，在那个濒死的人的脑壳里住着的，是循环着的回忆机器，外部差异和时间流变已经全部停止，他在他的濒死的爱中永生，他被化约为匿名的巨大精神实体的无关紧要的部分，他被吞噬为一个重复播放的回忆画面，严格意义上，他不过是这个宇宙在神经层面进行物理运动的逆时推演的数据流的忠诚的记录单元，简单说，他是一台自动摄像-放映机，拍摄的是它播放的画面本身。这时他的灵魂又如何说“不”呢？谁来逼迫他的肉体说不呢？让他的肉体死亡吧！“不！”</p><p>​难道这不是实情吗？每一个邪恶、狠毒的灵魂，在死前都会试图用他的微不足道的死亡，来向那个想象中永恒却又贪鄙的宇宙灵魂兑换永久享乐的赎罪券，他在拼命的忏悔同时又拼命的算计，努力把自己卖出一个伟大的价格来令虚无中的买家满意。让我们在此本着人道主义的热情和赤诚，真心祝愿这些优良品质的魂灵，能够得偿所愿，早日找到志同道合的买主，在一个公道的市场秩序下，兑换成功！</p>]]></content>
      
      
      <categories>
          
          <category> 好文转载 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu21.04及以上开启nfs(包括v2支持)</title>
      <link href="/posts/b176ed63/"/>
      <url>/posts/b176ed63/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu21-04-及以上-开启nfs-包括v2支持"><a href="#ubuntu21-04-及以上-开启nfs-包括v2支持" class="headerlink" title="ubuntu21.04 及以上 开启nfs(包括v2支持)"></a>ubuntu21.04 及以上 开启nfs(包括v2支持)</h1><p>为方便调试arm板卡，开启ubuntu21.04 及以上系统的下的nfs服务，并添加<code>nfsv2</code>支持</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装nfs-kernel-server服务</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install nfs-kernel-server<br></code></pre></td></tr></tbody></table></figure><h2 id="添加共享目录"><a href="#添加共享目录" class="headerlink" title="添加共享目录"></a>添加共享目录</h2><p>首先创建一个需要共享的目录 比如<code>/share</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /share<br>sudo gedit /etc/exports <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件最后添加要共享的目录</span><br>----------------------------------------------------------------<br>/share *(rw,sync,no_root_squash) <br></code></pre></td></tr></tbody></table></figure><h2 id="开启v2支持"><a href="#开启v2支持" class="headerlink" title="开启v2支持"></a>开启v2支持</h2><p>通过命令查看当前支持的nfs版本</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cat /proc/fs/nfsd/versions<br></code></pre></td></tr></tbody></table></figure><p><code>-2 +3 +4 +4.1 +4.2</code>可以看到，默认是不支持v2版本的。</p><p><strong>ubuntu21.04及以前，配置文件是在</strong> <code>/etc/default/nfs-kernel-server</code></p><p>所以在<code>/etc/default/nfs-kernel-server</code>的最后，添加<code>RPCNFSDOPTS="--nfs-version 2,3,4 --debug --syslog"</code>重启nfs就可以了。</p><p><strong>但是在ubuntu21.04以后，配置文件路径在<code>/etc/nfs.conf</code>下，需要将 <code>vers2=n</code>改为<code>vers2=y</code>，</strong>具体可查看下 <a href="https://gonglja.github.io/posts/d78cdbc6/#NFS%E9%85%8D%E7%BD%AE">Arch中配置nfs</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/etc/nfs.conf</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">udp=n</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">tcp=y</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">vers2=n</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">vers3=y</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">vers4=y</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">vers4.0=y</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">###########################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改成以下即可</span><br>udp=y<br>tcp=y<br>vers2=y<br>vers3=y<br>vers4=y<br></code></pre></td></tr></tbody></table></figure><h2 id="重启nfs"><a href="#重启nfs" class="headerlink" title="重启nfs"></a>重启nfs</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /etc/init.d/nfs-kernel-server restart<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ubuntu 21.04 以后最好使用</span><br>sudo systemctl restart nfs-kernel-server<br></code></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/baidu_33032485/article/details/114496376">Ubuntu20.04搭建 NFS 服务</a></li><li><a href="https://blog.csdn.net/Qiuoooooo/article/details/112601940">Ubuntu添加NFS v2支持</a></li><li><a href="https://groups.google.com/g/linux.debian.bugs.dist/c/0I8crqQNoRw?pli=1">Bug#1006650: nfs-kernel-server: Warn that NFSv2 is no longer supported</a></li><li><a href="https://gonglja.github.io/posts/d78cdbc6/#NFS%E9%85%8D%E7%BD%AE">Arch下的NFS配置</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> nfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言中给定一个函数地址如何调用呢？</title>
      <link href="/posts/3b31c731/"/>
      <url>/posts/3b31c731/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在u-boot代码中有时会给出一个函数的地址（<code>0x123456789xx</code>），比如下面这种</p><p>然后告诉参数类型和返回值类型，那么我们要怎么使用呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111603563.png"></p><p>首先先了解一下c语言中的函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fun call\r\n"</span>);<br>} <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun:%p\r\n"</span>,fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun:%p\r\n"</span>,&amp;fun);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译运行结果如下，可以看到二者地址是一致的，但是其意义却大不相同</p><ul><li><code>fun</code> 是<code>fun</code>函数的首地址，类型是 <code>void ()</code>。</li><li><code>&amp;fun</code>表示指向函数<code>fun</code>这个对象的地址，类型是<code>void (*)()</code>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111608478.png"></p><p>继续在了解一下<strong>函数指针类型</strong></p><p>其本身是一个指针，只不过该指针指向函数。</p><p>其格式如：<strong>函数返回值数据类型 （*指针变量名）（函数的实际参数或者函数参数的类型），</strong>其中指针变量名可以省略。</p><p>形如<code>void * (*f) (void *) </code>，意思是f是一个指针，其指向一个函数（可以是 <code>void* fun(void *)</code>等），函数的返回值为<code>void *</code>，函数的参数为<code>void *</code>。</p><p>做一个简单的实验去验证一下，写了5个函数，其中</p><table><thead><tr><th>函数</th><th>返回值类型</th><th>参数类型</th></tr></thead><tbody><tr><td><code>fun</code></td><td><code>void</code></td><td>无参数</td></tr><tr><td><code>fun1</code></td><td><code>void</code></td><td><code>(int )</code>一个<code>int</code>型参数</td></tr><tr><td><code>fun2</code></td><td><code>void</code></td><td><code>(int , int )</code>两个<code>int</code>型参数</td></tr><tr><td><code>fun3</code></td><td><code>int</code></td><td><code>(int ,char *)</code>一个<code>int</code>型和一个<code>char*</code>型参数</td></tr><tr><td><code>fun4</code></td><td><code>int*</code></td><td><code>(int *)</code>一个<code>int *</code>型参数</td></tr></tbody></table><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fun call\r\n"</span>);<br>} <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>{<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fun1 call:%d\r\n"</span>,a);<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">char</span> *b)</span>{<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fun2 call:%d %p\r\n"</span>,a,b);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun3</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>{<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fun3 call:%d\r\n"</span>,a);<br>    <span class="hljs-keyword">return</span> a;<br>}<br><br><span class="hljs-type">int</span>* <span class="hljs-title function_">fun4</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> {<br>    *a += <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fun4 call:%d\r\n"</span>,*a);<br>    <span class="hljs-keyword">return</span> a;<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun:%p\r\n"</span>,fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun:%p\r\n"</span>,&amp;fun);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun1:%p\r\n"</span>,&amp;fun1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun2:%p\r\n"</span>,&amp;fun2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun3:%p\r\n"</span>,&amp;fun3);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun4:%p\r\n"</span>,&amp;fun4);<br>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> add = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> )&amp;fun;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> add1 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> )&amp;fun1;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> add2 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> )&amp;fun2;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> add3 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> )&amp;fun3;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> add4 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> )&amp;fun4;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun:%x\r\n"</span>,add);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun1:%x\r\n"</span>,add1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun2:%x\r\n"</span>,add2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun3:%x\r\n"</span>,add3);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address fun4:%x\r\n"</span>,add4);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> dd = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address dd:%p\r\n"</span>,&amp;dd);    <br>    <span class="hljs-type">int</span> ff = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address ff:%p\r\n"</span>,&amp;ff);<br>    ((<span class="hljs-type">void</span> (*)())add)();<br>    ((<span class="hljs-type">void</span> (*)(<span class="hljs-type">int</span> ))add1)(<span class="hljs-number">10</span>);<br>    ((<span class="hljs-type">void</span> (*)(<span class="hljs-type">int</span> ,<span class="hljs-type">char</span> *))add2)(<span class="hljs-number">10</span>,&amp;dd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"add3 return val:%d\r\n"</span>,((<span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span> ))add3)(<span class="hljs-number">11</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"add4 return val:%d\r\n"</span>,*((<span class="hljs-type">int</span> *(*)(<span class="hljs-type">int</span> *))add4)(&amp;ff));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在代码中先打印指向函数<code>fun*</code>的地址，再将地址赋值给<code>add*</code>，其二者地址是一致的。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111636195.png"></p><p>接着我们通过地址<code>add*</code>来调用函数<code>fun*</code>。先看<code>add</code>中存的是一个地址，其地址是fun的首地址，类型为(<code>void (*)()</code>)，所以通过地址<code>add*</code>来调用函数时，首先将类型转为 (<code>void (*)()</code>)，<code>(void (*)())add</code>，没有参数直接调用<code>((void (*)())add)()</code></p><p>后面的也是类似，看下<code>add4</code>，其地址是<code>fun4</code>的首地址，类型为(<code>int *(*)(int *) </code>)（第一个<code>int *</code>表示返回值类型，<code>(int *)</code>表示参数类型为<code>int *</code>）,所以通过地址调用时，先类型转化 <code>(int *(*)(int *))add4</code>，有函数参数和返回值，<code>int *p = ((int *(*)(int *))add4)(&amp;ff)</code>。其结果和预期保持一致。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111548715.png"></p><p>所以，<strong>使用函数地址完成函数调用时，首先转换类型，然后有参数传入参数，有返回值用对应类型来接</strong>。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://blog.csdn.net/Q_1849805767/article/details/107391572">C/C++ 获取函数地址</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEST</title>
      <link href="/posts/eeea93b8/"/>
      <url>/posts/eeea93b8/</url>
      
        <content type="html"><![CDATA[<pre><code class=" mermaid">graph TD    开始--&gt; 结束</code></pre><pre><code class=" mermaid">graph BT   开始--&gt; 结束</code></pre><pre><code class=" mermaid">graph RL开始 --&gt; 结束</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【源码分析】u-boot-2014.04 分析（未完待续）</title>
      <link href="/posts/f88e6d17/"/>
      <url>/posts/f88e6d17/</url>
      
        <content type="html"><![CDATA[<h1 id="u-boot-2014-04-分析"><a href="#u-boot-2014-04-分析" class="headerlink" title="u-boot-2014.04 分析"></a>u-boot-2014.04 分析</h1><p>​由于要移植一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。</p><p>本文使用的版本是 <del><a href="ttps://ftp.denx.de/pub/u-boot/u-boot-2022.04-rc4.tar.bz2">u-boot-2022.04-rc4.tar.bz2</a></del> <a href="https://github.com/Gonglja/u-boot-smart210">u-boot-2014.04</a>（因作者能力不够，遂从2014.04开始）</p><h2 id="s5pv210"><a href="#s5pv210" class="headerlink" title="s5pv210"></a>s5pv210</h2><h3 id="芯片启动流程"><a href="#芯片启动流程" class="headerlink" title="芯片启动流程"></a>芯片启动流程</h3><p>由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iROM中，BL1和BL2运行在SRAM中，但在实际项目中使用的比较通用的启动流程与官方流程有较大差异，为什么呢？因为编译的u-boot过大，超过最大80k限制。所以BL2在SDRAM中运行，而三星官方是放在内部SRAM中运行。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png"></p><h4 id="BL0"><a href="#BL0" class="headerlink" title="BL0"></a>BL0</h4><ul><li>运行在iROM上</li><li>代码固定在s5pv210的IROM中，无法修改。上电后直接从IROM中开始执行</li><li>主要工作<ul><li>初始化系统时钟、特殊设备控制器、启动设备、看门狗、SRAM等</li><li>验证BL1镜像</li><li>从存储介质上（比如SD/eMMC/nand flash）等加载BL1镜像到内部SRAM中</li><li>跳转到BL1镜像所在地址</li></ul></li></ul><h4 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h4><ul><li>运行在SRAM上</li><li>BL1代码在BL0段被加载到SRAM中</li><li>主要工作<ul><li>初始化部分时钟（SDRAM相关）</li><li>初始化DDR（外部SDRAM）</li><li>从存储介质上将BL2镜像加载到SDRAM中</li><li>验证BL2镜像合法性</li><li>跳转到BL2镜像所在的地址上</li></ul></li></ul><h4 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h4><ul><li>运行在SDRAM上</li><li>BL2代码在BL1段被加载到SDRAM中</li><li>BL2就是传统意义上的bootloader，主要负责加载OS和启动OS</li></ul><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082025672.png"></p><table><thead><tr><th>起始地址</th><th>结束地址</th><th>长度</th><th>映射区域描述</th></tr></thead><tbody><tr><td><strong>0x0000_0000</strong></td><td><strong>0x1FFF_FFFF</strong></td><td><strong>512MB</strong></td><td><strong>Boot area（取决于启动模式）</strong></td></tr><tr><td><strong>0x2000_0000</strong></td><td><strong>0x3FFF_FFFF</strong></td><td><strong>512MB</strong></td><td><strong>DRAM 0</strong></td></tr><tr><td><strong>0x4000_0000</strong></td><td><strong>0x7FFF_FFFF</strong></td><td><strong>1024MB</strong></td><td><strong>DRAM 1</strong></td></tr><tr><td>0x8000_0000</td><td>0x87FF_FFFF</td><td>128MB</td><td>SROM Bank 0</td></tr><tr><td>0x8800_0000</td><td>0x8FFF_FFFF</td><td>128MB</td><td>SROM Bank 1</td></tr><tr><td>0x9000_0000</td><td>0x97FF_FFFF</td><td>128MB</td><td>SROM Bank 2</td></tr><tr><td>0x9800_0000</td><td>0x9FFF_FFFF</td><td>128MB</td><td>SROM Bank 3</td></tr><tr><td>0xA000_0000</td><td>0xA7FF_FFFF</td><td>128MB</td><td>SROM Bank 4</td></tr><tr><td>0xA800_0000</td><td>0xAFFF_FFFF</td><td>128MB</td><td>SROM Bank 5</td></tr><tr><td>0xB000_0000</td><td>0xBFFF_FFFF</td><td>256MB</td><td>OneNAND/NAND Controller and SFR</td></tr><tr><td>0xC000_0000</td><td>0xCFFF_FFFF</td><td>256MB</td><td>MP3_SRAM output buffer</td></tr><tr><td><strong>0xD000_0000</strong></td><td><strong>0xD000_FFFF</strong></td><td><strong>64KB</strong></td><td><strong>IROM</strong></td></tr><tr><td>0xD001_0000</td><td>0xD001_FFFF</td><td>64KB</td><td>Reserved</td></tr><tr><td><strong>0xD002_0000</strong></td><td><strong>0xD003_7FFF</strong></td><td><strong>96KB</strong></td><td><strong>IRAM</strong></td></tr><tr><td>0xD800_0000</td><td>0xDFFF_FFFF</td><td>128MB</td><td>DMZ ROM</td></tr><tr><td>0xE000_0000</td><td>0xFFFF_FFFF</td><td>512MB</td><td>SFR region</td></tr></tbody></table><p>s5pv210芯片上电之后，CPU会直接从0x0地址取指令，也就是直接运行BL0。</p><table><thead><tr><th>起始地址</th><th>结束地址</th><th>长度</th><th>映射区域描述</th></tr></thead><tbody><tr><td>0x0000_0000</td><td>0x0000_FFFF</td><td>64KB</td><td>Internal ROM</td></tr></tbody></table><p>BL1运行在IRAM中，IRAM空间如下</p><table><thead><tr><th>起始地址</th><th>结束地址</th><th>长度</th><th>映射区域描述</th></tr></thead><tbody><tr><td>0xD002_0000</td><td>0xD003_7FFF</td><td>96KB</td><td>IRAM</td></tr></tbody></table><p>但需注意：BL1运行在IRAM上，但并不意味着就从0xD002_0000开始。其实0xD002_0000开头的16B被用做BL1的header，BL1真正是从<strong>0xD002_0010</strong>开始运行的。前16字节被用来验证BL1镜像的完整性，其格式如下：</p><table><thead><tr><th>地址</th><th>数据</th></tr></thead><tbody><tr><td>0xD002_0000</td><td>BL1镜像包括header的长度</td></tr><tr><td>0xD002_0004</td><td>保留，设置为0</td></tr><tr><td>0xD002_0008</td><td>BL1镜像除去header的校验和</td></tr><tr><td>0xD002_000c</td><td>保留，设置为0</td></tr></tbody></table><p>BL2运行地址在SDRAM中， smart210使用的是DRAM0，所以地址为</p><table><thead><tr><th>起始地址</th><th>结束地址</th><th>长度</th><th>映射区域描述</th></tr></thead><tbody><tr><td>0x2000_0000</td><td>0x3FFF_FFFF</td><td>512MB</td><td>DRAM 0</td></tr></tbody></table><h2 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h2><p>由以上可知，上电后首先运行BL0阶段（BL0段代码起始地址为<code>0</code>）。</p><p>BL0 阶段运行的代码为IROM中自带的，其主要功能为 初始化系统时钟、特殊设备控制器、启动设备、看门狗、SRAM等，验证BL1镜像是否完整（<code>0xD002_0000</code>处存在长度和校验）然后跳转到BL1处（<code>0xD002_0010</code>）执行。</p><p>BL1 阶段运行在IRAM中，其主要功能是初始化部分时钟和DDR，拷贝BL2段代码到SDRAM中，验证BL2并跳转执行。</p><blockquote><p>那么，BL1段代码是怎么被拷贝到SRAM中的？</p><p>答：在BL0段将BL1的代码拷贝到SRAM中（参考<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code> 中 <code>2.2 iROM(BL0) boot-up sequence (Refer 2.3 V210 boot-up diagram)</code>），由于BL0三星不开源，所以我我们只能按照三星的要求存放BL1的位置（参考<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code> 中<code>2.8 Boot Block Assignment Guide</code>），如果从SD卡启动，也即从SD卡的第<code>1</code>个块开始；如果从NAND Flash启动，就放到Flash中的<code>0</code>块处。拷贝多少呢？这个不知道，有人说是<code>16k</code>也有人说是<code>8k</code>，尽可能将BL1的代码控制在<code>8K</code>以内。</p></blockquote><p>BL2 阶段运行在SDRAM中，就是传统意义上的bootloader，主要负责加载OS和启动OS</p><p>u-boot代码中有两部分：u-boot-spl、u-boot，其中u-boot-spl与芯片启动流程中的BL1对应、u-boot与BL2对应。</p><p>那么问题来了，u-boot-spl是如何生成的？u-boot又是怎么生成的?</p><p>spl的编译时编译uboot的一部分，和uboot.bin走的是两条编译流程。</p><p>一般来说，会先编译主体uboot，也就是uboot.bin，在编译uboot-spl，也就是uboot-spl.bin，两个流程。</p><p>编译成功后有几个文件名需要注意下，</p><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>u-boot-spl</td><td>初步链接后得到的spl文件</td></tr><tr><td>u-boot-spl-nodtb.bin</td><td>在u-boot-spl的基础上，经过objcopy去除符号表信息之后的可执行程序</td></tr><tr><td>u-boot-spl.bin</td><td>在不需要dtb的情况下，直接由u-boot-spl-nodtb.bin复制而来，也就是编译spl的最终目标</td></tr><tr><td>smart210-spl.bin</td><td>由s5pv210平台决定，需要在u-boot-spl.bin的基础上加上16B的header用作校验</td></tr><tr><td>u-boot-spl.lds</td><td>spl的连接脚本</td></tr><tr><td>u-boot-spl.map</td><td>连接之后的符号表文件</td></tr><tr><td>u-boot-spl.cfg</td><td>由spl配置生成的文件</td></tr></tbody></table><p><strong>框架</strong></p><blockquote><p>一般情况下，u-boot采用”board–&gt;machine–&gt;arch–&gt;cpu”框架，如图：</p></blockquote><blockquote><p><img src="http://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201605/29bd3da4b061810a74093c33d3292b4320160519144243.gif"></p></blockquote><blockquote><p>基于这个架构，u-boot和平台有关的初始化流程就很清晰了。</p><ol><li>u-boot 启动后，会先执行CPU（如armv8）的初始化代码</li><li>CPU相关的代码， 会调用ARCH的公共代码（如arch/arm）</li><li>ARCH的公共代码，在适当的时候，调用board有关的接口。u-boot的功能逻辑，大多是由common代码实现，部分和平台有关的部分，则由公共代码声明，由board代码实现。</li><li>board代码在需要的时候，会调用machine(arch/arm/mach-xxx)提供的接口，实现特定的功能。因此machine的定位是提供一些基础的代码支持，不会直接参与到u-boot的逻辑功能中去。</li></ol></blockquote><p>由此可知，当u-boot上电后，首先执行的是CPU的初始化代码。板卡型号为smart210，CPU型号为s5pv210，armv7指令集。</p><p>通过 <code>u-boot-spl.lds</code>（<code>arch/arm/cpu/u-boot-spl.lds</code>） 和 <code>u-boot.lds</code>（arch/arm/cpu/u-boot.lds） 中 <code>ENTRY(_start)</code>可知，不管是u-boot-spl还是u-boot都是从<code>_start</code>开始的。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先解决编译问题，其次是分析代码，在分析代码的过程中遇到不会的指令和寄存器及时记录下来，防止下次还是不会。</p><h3 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h3><h4 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h4><p>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</p><p>dirname: missing operand</p><p>具体如下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash">glj0@glj0-ubuntu21:~/worksapce/os/smart210/u-boot-2014.04$ ./make.sh <br>make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br><span class="hljs-built_in">dirname</span>: missing operand<br>Try <span class="hljs-string">'dirname --help'</span> <span class="hljs-keyword">for</span> more information.<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br><span class="hljs-built_in">dirname</span>: missing operand<br>Try <span class="hljs-string">'dirname --help'</span> <span class="hljs-keyword">for</span> more information.<br>make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br><span class="hljs-built_in">dirname</span>: missing operand<br>Try <span class="hljs-string">'dirname --help'</span> <span class="hljs-keyword">for</span> more information.<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br><span class="hljs-built_in">dirname</span>: missing operand<br>Try <span class="hljs-string">'dirname --help'</span> <span class="hljs-keyword">for</span> more information.<br>Configuring <span class="hljs-keyword">for</span> smart210 board...<br>make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br><span class="hljs-built_in">dirname</span>: missing operand<br>Try <span class="hljs-string">'dirname --help'</span> <span class="hljs-keyword">for</span> more information.<br>  GEN     include/autoconf.mk.dep<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br>  GEN     include/autoconf.mk<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br>  CHK     include/config/uboot.release<br>  CHK     include/generated/timestamp_autogenerated.h<br>  UPD     include/generated/timestamp_autogenerated.h<br>  UPD     include/config/uboot.release<br>  HOSTCC  scripts/basic/fixdep<br>  CHK     include/generated/version_autogenerated.h<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-ld: not found<br>  UPD     include/generated/version_autogenerated.h<br>  CC      lib/asm-offsets.s<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br>make[1]: *** [/home/glj0/worksapce/os/smart210/u-boot-2014.04/./Kbuild:35: lib/asm-offsets.s] Error 127<br>make[1]: *** Waiting <span class="hljs-keyword">for</span> unfinished <span class="hljs-built_in">jobs</span>....<br>  CC      <span class="hljs-built_in">arch</span>/arm/lib/asm-offsets.s<br>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found<br>make[1]: *** [/home/glj0/worksapce/os/smart210/u-boot-2014.04/./Kbuild:84: <span class="hljs-built_in">arch</span>/arm/lib/asm-offsets.s] Error 127<br>make: *** [Makefile:999: prepare0] Error 2<br><br></code></pre></td></tr></tbody></table></figure><p>缺少32位库，安装就可以了。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install libgl1-mesa-dri:i386<br></code></pre></td></tr></tbody></table></figure><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><blockquote><p>32位处理器能同时处理32位的数据，所以对应寄存器为32位的</p><p>64位处理器能同时处理32位的数据，所以对应寄存器为64位的</p><p>ARM处理器用到的指令集分为ARM 和 THUMB两种。</p><p>ARM指令集长度固定为32bit，THUMB指令集长度固定为16bit。ARM64指令集长度也是32bit。</p></blockquote><table><thead><tr><th>类别</th><th>寄存器</th><th>APCS(ARM 过程调用标准)</th><th>说明</th></tr></thead><tbody><tr><td>通用寄存器/不分组寄存器</td><td>r0</td><td>a1</td><td>用作传入函数参数，传出函数返回值。在子程序调用之间，可以将r0-r3用于任何用途</td></tr><tr><td></td><td>r1</td><td>a2</td><td>同上</td></tr><tr><td></td><td>r2</td><td>a3</td><td>同上</td></tr><tr><td></td><td>r3</td><td>a4</td><td>同上</td></tr><tr><td></td><td>r4</td><td>v1</td><td><strong>存放函数的局部变量</strong>如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值</td></tr><tr><td></td><td>r5</td><td>v2</td><td>同上</td></tr><tr><td></td><td>r6</td><td>v3</td><td>同上</td></tr><tr><td></td><td>r7</td><td>v4</td><td>同上</td></tr><tr><td>通用寄存器/分组寄存器</td><td>r8</td><td>v5</td><td>同上</td></tr><tr><td></td><td>r9</td><td>v6</td><td>同上</td></tr><tr><td></td><td>r10</td><td>sl (stack limit)</td><td>同上</td></tr><tr><td></td><td>r11</td><td>fp ()</td><td>同上</td></tr><tr><td></td><td>r12</td><td>ip (intra-prpcedure-call scratch regiser)</td><td>内部调用暂时寄存器。</td></tr><tr><td></td><td>r13</td><td>sp (stack pointer)</td><td>栈指针sp，存放的值在退出被调用函数时必须与进入时的值相同。</td></tr><tr><td></td><td>r14</td><td>lr (link register)</td><td>通常被用作子程序链接寄存器，也称lr,指向函数的返回地址。通常用来保存子程序执行的下一条指令。</td></tr><tr><td>通用寄存器/程序计数器</td><td>r15</td><td>pc (program counter)</td><td>程序计数器，保留下一条CPU即将执行的指令。不能用于其它用途。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>程序状态字寄存器</td><td>cpsr</td><td></td><td></td></tr><tr><td></td><td>spsr</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>协处理器</td><td>cp15</td><td></td><td>在基于ARM的嵌入式应用系统中，存储系统的操作通常是由协处理器CP15完成的。CP15包含16个32位的寄存器，其编号为0～15。</td></tr></tbody></table><p><strong>CP15</strong>的寄存器列表如表所示：</p><table><thead><tr><th>寄存器编号</th><th>基本作用</th><th>在MMU中的作用</th><th>在PU中的作用</th></tr></thead><tbody><tr><td>0</td><td>ID 编码（只读）</td><td>ID 编码和 cache 类型</td><td></td></tr><tr><td>1</td><td>控制位（可读写）</td><td>各种控制位</td><td></td></tr><tr><td>2</td><td>存储保护和控制</td><td>地址转换表基地址</td><td>Cachability 的控制位</td></tr><tr><td>3</td><td>存储保护和控制</td><td>域访问控制位</td><td>Bufferablity 控制位</td></tr><tr><td>4</td><td>存储保护和控制</td><td>保留</td><td>保留</td></tr><tr><td>5</td><td>存储保护和控制</td><td>内存失效状态</td><td>访问权限控制位</td></tr><tr><td>6</td><td>存储保护和控制</td><td>内存失效地址</td><td>保护区域控制</td></tr><tr><td>7</td><td>高速缓存和写缓存</td><td>高速缓存和写缓存控制</td><td></td></tr><tr><td>8</td><td>存储保护和控制</td><td>TLB 控制</td><td>保留</td></tr><tr><td>9</td><td>高速缓存和写缓存</td><td>高速缓存锁定</td><td></td></tr><tr><td>10</td><td>存储保护和控制</td><td>TLB 锁定</td><td>保留</td></tr><tr><td>11</td><td>保留</td><td></td><td></td></tr><tr><td>12</td><td>保留</td><td></td><td></td></tr><tr><td>13</td><td>进程标识符</td><td>进程标识符</td><td></td></tr><tr><td>14</td><td>保留</td><td></td><td></td></tr><tr><td>15</td><td>因不同设计而异</td><td>因不同设计而异</td><td>因不同设计而异</td></tr></tbody></table><h3 id="negative-squared-cross-mark-指令"><a href="#negative-squared-cross-mark-指令" class="headerlink" title=":negative_squared_cross_mark:指令"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>指令</h3><p><strong>指令集二进制编码</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204271909384.png"></p><p><strong>条件码</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131656507.png"></p><p><strong>指令</strong></p><table><thead><tr><th>类别</th><th>指令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>条件（有符号数）</td><td>GE</td><td>大于等于</td><td></td></tr><tr><td></td><td>LE</td><td>小于等于</td><td></td></tr><tr><td></td><td>GT</td><td>大于</td><td></td></tr><tr><td></td><td>LT</td><td>小于</td><td></td></tr><tr><td>条件（用于无符号数）</td><td>HS</td><td>大于等于</td><td></td></tr><tr><td></td><td>LS</td><td>小于等于</td><td></td></tr><tr><td></td><td>HI</td><td>大于</td><td></td></tr><tr><td></td><td>LO</td><td>小于</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>STR{cond} 源寄存器，&lt;存储器地址&gt;</td><td>从源寄存器中将一个32位的字数据传送到存储器中</td><td><code>STR r1, [r0]</code>将r1里面值复制到以r0里面的值作为地址的内存中</td></tr><tr><td></td><td>STRLO 源寄存器，&lt;存储器地址&gt;</td><td>当满足条件小于时，从源寄存器中将一个32位的字数据传送到存储器中</td><td><code>CMP r0，r1;STRLO r2，[r0];</code> 首先r0=r0-r1,当满足条件r0&lt;r1时，将r2中的值复制到以r0里面的值作为地址的内存中。</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>地址读取伪指令</td><td>ADR{cond}目的寄存器，相对地址或标签</td><td>将基于PC相对偏移的地址值或基于寄存器相对地址值传送到目的寄存器中（小范围）</td><td><code>ADR r0, here;here: ....</code>将标签here处的相对地址传递给寄存器r0</td></tr><tr><td></td><td>LDR{cond}目的寄存器，&lt;存储器地址&gt;</td><td>从存储器中将一个32位的字数据传送到目的寄存器中（大范围）</td><td><code>LDR r0, [r1]</code>将r1里面的值作为地址，将地址里面的值复制给寄存器r0</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>跳转指令</td><td>B{cond} 目标地址</td><td>跳转指令</td><td><code>B Label</code>程序无条件跳转到标号Label处执行</td></tr><tr><td></td><td>BL{cond} 目标地址</td><td>带返回的跳转指令（跳转之前，将PC内容存到R14中）</td><td><code>BL Label</code>程序将当前PC值存到R14中，程序无条件跳转至标号Label中执行</td></tr><tr><td></td><td>BX{cond} Rm</td><td>带状态切换的跳转指令，最低位为1时，切换到Thumb指令执行，为0时，解释为ARM指令执行（最低位指的是Rm的第0位）</td><td></td></tr><tr><td></td><td>BLX</td><td>带返回和状态切换的跳转指令</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>算术运算指令</td><td>SUB 寄存器1，寄存器2，寄存器3</td><td>寄存器1=寄存器2-寄存器3</td><td><code>SUB r0，r1,#1</code> r0=r1-1</td></tr><tr><td></td><td>SUBS 寄存器1，寄存器2，寄存器3</td><td>寄存器1=寄存器2-寄存器3;S表示并将进位结果写到CPSR中</td><td><code>SUBS r0，r1,#1</code> r0=r1-1，并将进位结果写道CPSR</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>CMP 寄存器1，寄存器2</td><td>寄存器1=寄存器1-寄存器2</td><td><code>CMP r0，r1</code> 也就是<code>r0=r0-r1</code></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>多数据传输条件</td><td>IA（Increase After）</td><td>每次传送后地址加4,其中的寄存器<strong>从左到右执行</strong>,例如:STMIA R0,{R1,LR} 先存R1,再存LR</td><td></td></tr><tr><td></td><td>IB（Increase Before）</td><td>每次传送前地址加4,同上</td><td></td></tr><tr><td></td><td>DA（Decrease After）</td><td>每次传送后地址减4,其中的寄存器<strong>从右到左执行</strong>,例如:STMDA R0,{R1,LR} 先存LR,再存R1</td><td></td></tr><tr><td></td><td>DB（Decrease Before）</td><td>每次传送前地址减4,同上</td><td></td></tr><tr><td></td><td>FD</td><td>满递减堆栈 (每次传送前地址减4)</td><td></td></tr><tr><td></td><td>FA</td><td>满递增堆栈 (每次传送后地址减4)</td><td></td></tr><tr><td></td><td>ED</td><td>空递减堆栈 (每次传送前地址加4)</td><td></td></tr><tr><td></td><td>EA</td><td>空递增堆栈 (每次传送后地址加4)</td><td></td></tr><tr><td>多数据传输（加载）</td><td>LDM{cond} Rn{!},reglist{^}</td><td>多数据加载，将地址上的值加载到寄存器中。Rn：基址寄存器，装有传送数据的起始地址，Rn不允许为R15；！：表示最后的地址写回到Rn中；reglist：可包含多于一个寄存器范围，用“，”隔开，如{R1，R2，R6-R9}，寄存器由小到大顺序排列；^：不允许在用户模式和系统模式下运行</td><td><code>LDR R0,=0x100000;LDMIA R0!,{R1-R8}</code>也就是从左往右加载，首先将0x100000中的数据加载到R1,然后R0=R0+4，然后将0x1000004中的数据加载到R2,然后R0=R0+4….</td></tr><tr><td>多数据传输（存储）</td><td>STM{cond} mode Rn{!}, reglist{^}</td><td>多数据存储，将寄存器的值存到地址上。同上</td><td></td></tr><tr><td>协处理器CP15操作</td><td>MRC{cond} p15,<opcode1>,<rd>,<crn>,<crm>,<opcode2></opcode2></crm></crn></rd></opcode1></td><td>协处理器寄存器到ARM处理器寄存器的数据传送指令（读出协处理器寄存器）。cond为指令执行条件码，当忽略时无条件执行。Opcode1:协处理器的特性操作码，对于CP15来说，其为0。Rd：源寄存器的ARM寄存器，其值被传送到协处理器中或者将协处理器的值传送到该寄存器中。CRn:目标寄存器的的协处理器寄存器，C~C15。CRm：协处理器中附件的目标寄存器或源操作数寄存器，默认为c0。Opcode2：可选的协处理器特定操作码。</td><td><code>mrc p15, 0, r0, c1, c0, 0</code>                将CP15的寄存器C1的值读到r0中</td></tr><tr><td></td><td>MCR{cond} p15,<opcode1>,<rd>,<crn>,<crm>,<opcode2></opcode2></crm></crn></rd></opcode1></td><td>ARM处理器寄存器到协处理器寄存器的数据传送指令（写入协处理器寄存器）</td><td><code>mcr p15, 0, r0, c7, c7, 0</code>            关闭ICaches和DCachesmcr <br><code>p15, 0, r0, c8, c7, 0</code>                 使无效整个数据TLB和指令TLB</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>.globl</td><td>伪指令，声明一个全局变量</td><td><code>.globl _start</code>声明_start，下面调用时才不会出现链接错误。类似c语言中的extern。</td></tr></tbody></table><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="x-2022中的-start不看"><a href="#x-2022中的-start不看" class="headerlink" title=":x:2022中的_start不看"></a><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><del>2022中的_start不看</del></h4><p><del>所以首先会执行armv7中的start.S代码，但是呢，通过代码，我们没有发现start.S中有 <code>_start</code>相关的定义，而且也没有一些向量表的处理，这就很奇怪了，代码放哪呢了呢？没有<code>_start</code>又要怎么启动呢？带着问题，我们接着往下走。</del></p><p>由于我们的代码是最新的，但有印象在2014版本中是有这一部分的，所以我们直接去查找git上这个文件的history</p><p>于是有了找到了以下</p><p><a href="https://source.denx.de/u-boot/u-boot/-/commit/41623c91b09a0c865fab41acdaff30f060f29ad6">https://source.denx.de/u-boot/u-boot/-/commit/41623c91b09a0c865fab41acdaff30f060f29ad6</a></p><p>在这个链接右上角可以看到，删除了2426行，新增了313行。看了下发现删除的都是 下面这种代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ass">.global _start<br>_start: b    reset <br>...<br>.balignl 16,0xdeadbeef<br></code></pre></td></tr></tbody></table></figure><p>那这些代码去哪了呢？</p><p>接着搜索armv7，发现也是这种代码被删除。</p><p>接着走，看看新增了什么，在u-boot-spl.lds和u-boot.lds中 代码中新增了一个 *(vectors)并且位置比start.o靠前，什么意思？中断向量表存到这个地方了嘛？是的，接着往下看，一切都会真相大白</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203291016583.png"></p><p>终于看到vector.S了，这部分代码是存在 arch/arm/lib下，有没有发现很熟悉，没错，就是上面删掉的代码，而且 <code>.global _start</code>也在这，由此可以猜测，<strong>开发人员将各个处理器的公共代码抽离，最终以vector.S体现</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203291030263.png"></p><p>借助 u-boot.lds（arch/arm/cpu/u-boot.lds）可知，<code>ENTRY(_start)</code>，整个u-boot的开始依然是<code>_start</code>，由以上分析可知，<code>_start</code>在vectors.S中定义，所以整个U-boot的入口为vector.S中的<code>_start</code>，接着 ARM_VECTORS 是一个宏，展开就是 <code>.macro/.endm</code>之间包裹的。接着往下走，就会走入<code>b reset</code>，调用reset。 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* arch/arm/lib/vectors.S */<br>.globl _start<br><br>.section ".vectors", "ax"<br><br>#if defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)<br>#include &lt;asm/arch/boot0.h&gt;<br>#else   /*走这个分支 (怎么确认的呢？在此处随便加个乱七八糟的字符，然后编译，如果编译过，则说明走的不是此分支)*/<br>_start: /*U-boot程序入口*/<br>#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG<br>.wordCONFIG_SYS_DV_NOR_BOOT_CFG<br>#endif<br>ARM_VECTORS /* 一个宏*/<br>#endif /* !defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) */<br>/* 在.macro 和 .endm 中的为*/<br>    .macro ARM_VECTORS<br>#ifdef CONFIG_ARCH_K3<br>ldr     pc, _reset<br>#else<br>breset// 走这个分支<br>#endif<br>ldrpc, _undefined_instruction<br>ldrpc, _software_interrupt<br>ldrpc, _prefetch_abort<br>ldrpc, _data_abort<br>ldrpc, _not_used<br>ldrpc, _irq<br>ldrpc, _fiq<br>.endm<br><br><br></code></pre></td></tr></tbody></table></figure><p>reset标签在哪呢？<code>arch/arm/cpu/armv7/start.S</code>中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* arch/arm/cpu/armv7/start.S */<br><br>reset:<br>/* Allow the board to save important registers */<br>bsave_boot_params<br>save_boot_params_ret:<br><br>/*<br> * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,<br> * except if in HYP mode already<br> * 禁用中断，同时设置CPU模式，除非已经处于HYP模式下<br> */<br>    mrsr0, cpsr;读取寄存器cpsr中的值，并保存到r0寄存器中。<br>    andr1, r0, #0x1f@ mask mode bits<br>    teqr1, #0x1a@ test for HYP mode<br>    bicner0, r0, #0x1f@ clear all mode bits<br>    orrner0, r0, #0x13@ set SVC mode<br>    orrr0, r0, #0xc0@ disable FIQ and IRQ<br>    msrcpsr,r0<br><br>ENTRY(save_boot_params)<br>bsave_boot_params_ret@ back to my caller<br>ENDPROC(save_boot_params)<br></code></pre></td></tr></tbody></table></figure><p><code>mrsr0, cpsr</code> ;读取寄存器cpsr中的值，并保存到r0寄存器中。</p><p><code>andr1, r0, #0x1f</code>寄存器r0中的值与0X1F进行与运算，结果保存到r1寄存器中，目的就是提取cpsr的bit0~bit4这5位，这5位为M4 M3 M2 M1 M0，M[4:0]这五位用来设置处理器的工作模式</p><p>以上为 u-boot-2022.04中的内容</p><hr><h4 id="代码函数调用图"><a href="#代码函数调用图" class="headerlink" title="代码函数调用图"></a><strong>代码函数调用图</strong></h4><p><a href="https://www.zhixi.com/view/18da9b99">https://www.zhixi.com/view/18da9b99</a></p><h4 id="start"><a href="#start" class="headerlink" title="_start"></a>_start</h4><p>由于我们的处理器使用的指令集为armv7，所以**_start**的路径为<code>arch/arm/cpu/armv7/start.S</code></p><p>其实对于u-boot的<code>start.S</code>，主要做的几件事就是系统各方面的初始化。</p><p>从大的方面分，可分为以下部分</p><ul><li><p>设置 CPU 模式</p></li><li><p>关闭看门狗</p></li><li><p>关闭中断</p></li><li><p>设置堆栈 sp 指针</p></li><li><p>清除 bss 段</p></li><li><p>异常中断处理</p></li></ul><p>接着我们看代码，</p><p><code>.globl _start</code> 声明<code>_start</code>标号对全局可见，类似于c语言中的<code>extern</code></p><p><code>_start: breset</code> <code>_start</code>后加一个冒号，表示其实一个Label。而同时<code>_start</code>的值，也就是代码的最开始的位置，相对是<code>0</code>。在u-boot-spl中其地址是<code>0</code>，在u-boot中，由于经过了relocate之后，代码的运行地址是我们定义的基地址（也就是重定位后的偏移地址<code>gd-&gt;relocaddr</code>）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/cpu/armv7/start.S<br>.globl _start   /* .globl指示告诉汇编器，_start是一个全局符号*/<br>_start: breset/* 跳转到reset符号处*/<br>ldrpc, _undefined_instruction/* 未定义指令异常*/<br>ldrpc, _software_interrupt/* 软中断，Linux系统调用*/<br>ldrpc, _prefetch_abort/* 预取址中止，取不到下一条指令*/<br>ldrpc, _data_abort<br>ldrpc, _not_used<br>ldrpc, _irq/* 中断*/<br>ldrpc, _fiq/* 快中断*/<br>...<br>reset:<br>        blsave_boot_params       //跳转到save_boot_params符号处<br>/*<br> * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,<br> * except if in HYP mode already<br> */<br>        mrsr0, cpsr//将cpsr寄存器的值读到r0中<br>        andr1, r0, #0x1f @ mask mode bits<br>        teq r1,      #0x1a    @ test for HYP mode<br>        bicne r0, r0, #0x1f   @ clear all mode bits  <br>        orrne r0, r0, #0x13  @ set SVC mode //更改处理器模式为SVC模式<br>        orr r0, r0, #0xc0  @ disable FIQ and IRQ//将I、F位（7、6位）置1 也即0xc0，关闭快中断和中断<br>        msrcpsr,r0      //将r0的内容写入cpsr寄存器<br><br><br>ENTRY(save_boot_params)<br>bxlr@ back to my caller<br>ENDPROC(save_boot_params)<br>.weaksave_boot_params<br></code></pre></td></tr></tbody></table></figure><p>这一段，首先会跳转到 <strong>save_boot_params</strong> 标号处，而 <code>ENTRY(save_boot_params)</code> 表示 <code>save_boot_params</code> 入口，进入后就一句 <code>bx lr</code>，其作用为 跳转到 <code>lr</code> 中存放的地址处。而<code>lr</code>的用途：当通过BL或者BLX调用<strong>子程序</strong>时，硬件将自动将子程序返回地址保存在R14寄存器中，在子程序返回时，把LR的值复制到程序计数器就可以实现子程序返回。所以这段代码的意思就是跳转到调用者处。也就是接着执行<code>bl save_boot_params</code>后面的代码。</p><p><code>mrsr0, cpsr</code>读取寄存器cpsr中的值，并保存到<code>r0</code>寄存器中。</p><p><code>andr1, r0, #0x1f</code>寄存器<code>r0</code>中的值与<code>0X1F</code>进行与运算，结果保存到<code>r1</code>寄存器中，目的就是提取<code>cpsr</code>的bit0~bit4这5位，这5位为M4 M3 M2 M1 M0，M[4:0]这五位用来设置处理器的工作模式。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101725592.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101726017.png"></p><p>如果<code>r1</code>和<code>0X1A(0b11010)</code>不相等，也就是CPU不处于Hyp模式的话就将<code>r0</code>寄存器的bit0~5进行清零，其实就是清除模式位。</p><p>如果处理器不处于Hyp模式的话就将r0的寄存器的值与<code>0x13</code>进行或运算，<code>0x13(0b10011)</code>，也就是设置处理器进入管理模式（SVC）。</p><p><code>r0</code>寄存器的值再与<code>0xC0(0b1100_0000)</code>进行或运算，那么r0寄存器此时的值就是<code>0xD3(0b1101_0000)</code>，cpsr的I位和F位分别控制IRQ和FIQ这两个中断的开关，设置为1就关闭了FIQ和IRQ！</p><p>将<code>r0</code>寄存器写回到<code>cpsr</code>寄存器中。完成设置CPU处于SVC32模式，并且关闭FIQ和IRQ这两个中断。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/cpu/armv7/start.S<br>/*<br> * Setup vector:<br> * (OMAP4 spl TEXT_BASE is not 32 byte aligned.<br> * Continue to use ROM code vector only in OMAP4 spl)<br> */<br>#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))<br>/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */<br>mrcp15, 0, r0, c1, c0, 0@ Read CP15 SCTRL Register<br>bicr0, #CR_V@ V = 0<br>mcrp15, 0, r0, c1, c0, 0@ Write CP15 SCTRL Register<br><br>/* Set vector address in CP15 VBAR register */<br>ldrr0, =_start<br>mcrp15, 0, r0, c12, c0, 0@Set VBAR<br>#endif<br></code></pre></td></tr></tbody></table></figure><p>这部分代码通过对协处理器CP15进行操作，设置了处理器的异常向量入口地址为<code>_start</code>。</p><p>这是因为ARM默认的异常向量表入口在0x0地址，然而S5PV210中0x0地址存放的是IROM，不可修改，自然不可能存放异常向量表，所以需要修改异常向量表入口，将它们映射到其他位置上去。</p><p>接着是三个跳转，每个跳转后都会返回到当前位置的下一条地址处。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/cpu/armv7/start.S<br>/* the mask ROM code should have PLL and others stable */<br>#ifndef CONFIG_SKIP_LOWLEVEL_INIT<br>blcpu_init_cp15<br>blcpu_init_crit<br>#endif<br><br>bl_main<br></code></pre></td></tr></tbody></table></figure><h4 id="cpu-init-cp15"><a href="#cpu-init-cp15" class="headerlink" title="cpu_init_cp15"></a>cpu_init_cp15</h4><p>首先跳转到 <strong>cpu_init_cp15</strong> 中，我们可以看到在<code>ENDPROC(cpu_init_cp15)</code>之前，有一条 <code>mov pc, lr</code>，此命令作用和<code>bx lr</code>相同，跳转回子函数调用的地方。在 <code>cpu_init_cp15</code> 中，主要是失效L1、I/D、关闭 MMU 等</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/cpu/armv7/start.S<br>ENTRY(cpu_init_cp15)<br>...<br>movpc, lr@ back to my caller //子过程运行结束，跳转回去<br>ENDPROC(cpu_init_cp15)<br></code></pre></td></tr></tbody></table></figure><h4 id="cpu-init-crit"><a href="#cpu-init-crit" class="headerlink" title="cpu_init_crit"></a>cpu_init_crit</h4><p>接着跳转到 <strong>cpu_init_crit</strong> 中，里面又一个跳转 <code>lowlevel_init</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/cpu/armv7/start.S<br>ENTRY(cpu_init_crit)<br>blowlevel_init@ go setup pll,mux,memory<br>ENDPROC(cpu_init_crit)<br></code></pre></td></tr></tbody></table></figure><hr><h4 id="x-lowlevel-init-分析错误"><a href="#x-lowlevel-init-分析错误" class="headerlink" title=":x:lowlevel_init(分析错误)"></a><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><del>lowlevel_init(分析错误)</del></h4><p><strong>注意：以下分析错误，请直接看下一个 lowlevel_init</strong> </p><p><del><strong>lowlevel_init</strong> 位于 <code>arch/arm/cpu/armv7/lowlevel_init.S</code></del>，主要是设置栈顶指针为 CONFIG_SYS_INIT_SP_ADDR ，然后栈顶指针8字节对齐。如果在SPL，设置r9数据为 gdata 地址，否则为GD数据分配空间，并将分配后的栈顶指针给r9。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ENTRY(lowlevel_init)<br>/*<br> * Setup a temporary stack<br> */<br>ldrsp, =CONFIG_SYS_INIT_SP_ADDR<br>bicsp, sp, #7 /* 8-byte alignment for ABI compliance */<br>#ifdef CONFIG_SPL_BUILD<br>ldrr9, =gdata<br>#else<br>subsp, sp, #GD_SIZE<br>bicsp, sp, #7<br>movr9, sp<br>#endif<br>/*<br> * Save the old lr(passed in ip) and the current lr to stack<br> */<br>push{ip, lr}<br><br>/*<br> * go setup pll, mux, memory<br> */<br>bls_init<br>pop{ip, pc}<br>ENDPROC(lowlevel_init)<br></code></pre></td></tr></tbody></table></figure><p><strong>CONFIG_SYS_INIT_SP_ADDR</strong> 在 <code>include/configs/smart210.h</code>，也就是说设置栈顶指针为SDRAM结束的高地址处。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#define CONFIG_SYS_INIT_SP_ADDR(CONFIG_SYS_LOAD_ADDR + PHYS_SDRAM_1_SIZE)<br>...<br>#define CONFIG_SYS_LOAD_ADDRCONFIG_SYS_SDRAM_BASE<br>...<br>/* DRAM Base */<br>#define CONFIG_SYS_SDRAM_BASE0x20000000<br>...<br>#define PHYS_SDRAM_1_SIZE(512 &lt;&lt; 20)/* 0x2000_0000, 512 MB Bank #1 */<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101814781.png"></p><p>其中 gddata 定义在 <code>arch/arm/lib/spl.c</code>中，这里需要补充一个高级用法。具体用法查看 <a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html</a> ，这里则是将 gdata 位置存放到 .data 段中。</p><blockquote><p>_<em>attribute</em>_</p><p>该关键字允许您指定变量、函数参数或结构体、联合体以及类成员的特殊属性</p><p>而 _<em>attribute</em>_ ((section(“.data”))) </p><p>则说明将 前者定义的放入<code>.data</code>段中</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Pointer to as well as the global data structure for SPL */</span><br>DECLARE_GLOBAL_DATA_PTR;<br><span class="hljs-type">gd_t</span> gdata __attribute__ ((section(<span class="hljs-string">".data"</span>)));<br>...<br><span class="hljs-comment">// 在 arch/arm/include/asm/global_data.h 中</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_GLOBAL_DATA_PTRregister volatile gd_t *gd asm (<span class="hljs-string">"r9"</span>)</span><br></code></pre></td></tr></tbody></table></figure><p>此时需要注意下 DECLARE_GLOBAL_DATA_PTR 这个宏，这个宏的意思是定义了全局数据结构gd（<strong>寄存器r9来表示全局数据结构gd</strong>）</p><p><code>register volatile gd_t *gd asm ("r9")</code> 其中register关键字是必须的，asm (“r9”)为嵌入式汇编，表示用r9寄存器存储gd指针，r9和CPU体系结构相关。寄存器变量。</p><p>所以不管 <code>ldrr9, =gdata</code>还是<code>movr9, sp</code>都是更新 gd 的地址，不同的是在SPL下，gd结构体空间被分配在 <code>.data</code>段中，在u-boot中，gd结构体空间被分配在<code>CONFIG_SYS_INIT_SP_ADDR - GD_SIZE</code> （需要8字节对齐）处。</p><p>接着往下走，<code>push{ip, lr}</code>用stack的形式保存<code>lr</code>(返回指针)，将ip和lr入栈</p><p>然后一个跳转到<code>bls_init</code>中。</p><p>下面 <code>pop{ip, pc}</code> 恢复到<code>ip</code>、<code>pc</code>，意思是改变pc的指向，将lr内容恢复到pc中，也即返回到lr指向的地方，在此处应为<code>blcpu_init_crit</code>的下方，也即<code>bl_main</code>。</p><p>接着分析 <code>s_init</code>，在与smart210相关的任何地方找不到与s_init相关的定义，也找不到与s5pv210任何相关的，所以此处应该是有问题的，通过在指令间添加一些异常数据，编译，编译通过，得知在调用 lowlevel_init时并不是找的此处。</p><p><strong>以上分析错误，请直接查看下一个 lowlevel_init</strong> </p><hr><h4 id="lowlevel-init"><a href="#lowlevel-init" class="headerlink" title="lowlevel_init"></a>lowlevel_init</h4><p><strong>lowlevel_init</strong> 位于 <code>board/samsung/smart210/lowlevel_init.S</code> ，这个相对简单，但还是说一下，首先将<code>lr</code>返回地址保存到<code>r9</code>中（此处不应该使用r9，或者说在使用r9前先保存r9的值），如果在SPL下，则需要初始化时钟和ddr，并配置串口寄存器<code>PA0CON</code>值为<code>0x00002222</code>（查看手册 <code>S5PV210_UM_REV1.1.pdf</code>中<code>2.2.2.1 Port Group GPA0 Control Register (GPA0CON, R/W, Address = 0xE020_0000)</code> ），也即配置<code>GPA0CON</code>功能为串口UART1。之后，恢复<code>pc</code>值为<code>lr</code>，返回到调用 <code>lowlevel_init</code> 的地方。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; board/samsung/smart210/lowlevel_init.S<br><br>        .globl lowlevel_init<br>lowlevel_init:<br>movr9, lr<br><br>#ifdef CONFIG_SPL_BUILD<br>bl clock_init                   /* clock init */<br>bl ddr_init                     /* DDR init */<br><br>/* add by Flinn, for uart */<br>ldr r0, =0xE0200000     /* GPA0_CON */<br>ldr r1, =0x22222222<br>str r1, [r0]<br><br>#endif<br>mov pc, r9                /* return */<br></code></pre></td></tr></tbody></table></figure><p>返回到<code>bl cpu_init_crit</code>的下一句指令，也即执行 <code>bl _main</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/cpu/armv7/start.S<br><br>/* the mask ROM code should have PLL and others stable */<br>#ifndef CONFIG_SKIP_LOWLEVEL_INIT<br>blcpu_init_cp15<br>blcpu_init_crit<br>#endif<br>bl_main<br></code></pre></td></tr></tbody></table></figure><h4 id="main"><a href="#main" class="headerlink" title="_main"></a>_main</h4><p><strong>_main</strong>位于<code>arch/arm/lib/crt0.S</code>中，具体代码一会回来分析。</p><p>终于来到<code>_main</code>中了，首先如果定义了<code>CONFIG_SPL_BUILD</code>和<code>CONFIG_SPL_STACK</code>，也即SPL时，sp值为<code>CONFIG_SPL_STACK</code>，但经过验证没有走这个分支；所以sp的值只可能为<code>CONFIG_SYS_INIT_SP_ADDR</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br>/*<br> * entry point of crt0 sequence<br> */<br><br>ENTRY(_main)<br><br>/*<br> * Set up initial C runtime environment and call board_init_f(0).<br> */<br><br>#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)<br>ldrsp, =(CONFIG_SPL_STACK)<br>#else<br>ldrsp, =(CONFIG_SYS_INIT_SP_ADDR)<br>#endif<br>...<br>ENDPROC(_main)<br></code></pre></td></tr></tbody></table></figure><p><strong>CONFIG_SYS_INIT_SP_ADDR</strong> 在 <code>include/configs/smart210.h</code>，也就是说设置栈顶指针为SDRAM结束的高地址处。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* include/configs/smart210.h */<br>#define CONFIG_SYS_INIT_SP_ADDR   (CONFIG_SYS_LOAD_ADDR + PHYS_SDRAM_1_SIZE)<br>...<br>#define CONFIG_SYS_LOAD_ADDRCONFIG_SYS_SDRAM_BASE<br>...<br>/* DRAM Base */<br>#define CONFIG_SYS_SDRAM_BASE0x20000000<br>...<br>#define PHYS_SDRAM_1_SIZE (512 &lt;&lt; 20)/* 0x2000_0000, 512 MB Bank #1 */<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101814781.png"></p><p>接着往下走，是给<code>gd</code>数据结构分配空间。gd是什么？</p><blockquote><p>gd是一个寄存器变量。此时需要注意下 DECLARE_GLOBAL_DATA_PTR 这个宏，这个宏的意思是定义了全局数据结构gd（<strong>寄存器r9来表示全局数据结构gd</strong>）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-comment">// board/samsung/smart210/smart210.c</span><br>&gt;DECLARE_GLOBAL_DATA_PTR;<br>&gt;---------------------------------------------------------------------------------------<br>&gt;<span class="hljs-comment">// arch/arm/include/asm/global_data.h </span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_GLOBAL_DATA_PTRregister volatile gd_t *gd asm (<span class="hljs-string">"r9"</span>)</span><br></code></pre></td></tr></tbody></table></figure><p><code>register volatile gd_t *gd asm ("r9")</code> 其中<code>register</code>关键字是必须的，<code>asm ("r9")</code>为嵌入式汇编，表示用<code>r9</code>寄存器存储<code>gd</code>指针，<code>r9</code>和CPU体系结构相关。</p></blockquote><p>先8字节对齐，然后给<code>gd</code>结构分配大小为<code>GD_SIZE</code>的空间，然后继续8字节对齐。<code>GD_SIZE</code>是一个宏，在<code>include/generated/generic-asm-offsets.h</code>中定义为<code>160</code>（<code>sizeof(struct global_data)</code>），该文件也是生成的。</p><p>更新<code>r9</code>值为<code>sp</code>，此时<code>r9 = sp = [CONFIG_SYS_INIT_SP_ADDR - GD_SIZE]</code>（<code>[CONFIG_SYS_INIT_SP_ADDR - GD_SIZE]</code>为对应地址处的值），接着给<code>r0</code>清零</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br>bicsp, sp, #7/* 8-byte alignment for ABI compliance */<br>subsp, sp, #GD_SIZE/* allocate one GD above SP */<br>bicsp, sp, #7/* 8-byte alignment for ABI compliance */<br>movr9, sp/* GD is above SP */<br>movr0, #0<br></code></pre></td></tr></tbody></table></figure><p>接着往下走，分为两种情况，第一种SPL下，跳转到 <code>copy_bl2_to_ram</code>（完成BL2阶段镜像校验并拷贝到SDRAM中），执行结束后返回，更改PC指针为<code>CONFIG_SYS_SDRAM_BASE</code>，也即跳转到 BL2阶段（SDRAM中）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br>#ifdef CONFIG_SPL_BUILD<br>        bl       copy_bl2_to_ram<br>        ldr pc,=CONFIG_SYS_SDRAM_BASE<br>#else<br>        bl       board_init_f<br>#endif<br>-----------------------------------------------<br>; include/configs/smart210.h<br>#define CONFIG_SYS_SDRAM_BASE0x20000000<br></code></pre></td></tr></tbody></table></figure><h4 id="copy-bl2-to-ram"><a href="#copy-bl2-to-ram" class="headerlink" title="copy_bl2_to_ram"></a>copy_bl2_to_ram</h4><p><code>copy_bl2_to_ram</code>函数在 <code>board/samsung/smart210/smart210.c</code> 中</p><p>首先是几个宏定义，让我们看一下是什么东东？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* board/samsung/smart210/smart210.c */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从SD/MMC拷贝（加载）块到内存中的函数 </span><br><span class="hljs-comment">** ch:  通道号</span><br><span class="hljs-comment">** sb:  起始块号</span><br><span class="hljs-comment">** bs:  块数量</span><br><span class="hljs-comment">** dst: 要拷贝到内存的什么位置上</span><br><span class="hljs-comment">** i:   是否需要初始化</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CopySDMMCtoMem(ch, sb, bs, dst, i) \</span><br><span class="hljs-meta">        (((u8(*)(int, u32, unsigned short, u32*, u8))\</span><br><span class="hljs-meta">        (*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP0_1CON  (*(volatile u32 *)0xE02002E0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP0_3CON  (*(volatile u32 *)0xE0200320)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP0_6CON  (*(volatile u32 *)0xE0200380) </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NF8_ReadPage_Adv(a,b,c) (((int(*)(u32, u32, u8*))(*((u32 *)0xD0037F90)))(a,b,c))</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CopySDMMCtoMem(ch, sb, bs, dst, i) \</span><br><span class="hljs-meta">(((u8(*)(int, u32, unsigned short, u32*, u8))(*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))   </span><br></code></pre></td></tr></tbody></table></figure><p>这个宏定义分为三段来看，分别对应着 <strong>函数返回值数据类型 （*指针变量名）（函数的实际参数或者函数参数的类型）</strong><br>第一段：<code>((u8 (*)(int, u32, unsigned short, u32*, u8))</code> 是一个函数类型强制类型转换，其中<code>u8</code>为返回值，<code>(int, u32, unsigned short, u32*, u8)</code>为传入参数类型。<br>第二段：<code>(*((u32 *)0xD0037F98)))</code> ，在地址<code>0xD0037F98</code>中存放了一个名字叫<code>CopySDMMCtoMem</code>的函数，armv7 为32位cpu，所以先转成<strong>指针类型为u32*<strong>，然后再把这个地址</strong>解引用</strong>，就得到了地址中存在的值也就是CopySDMMCtoMem</p><p>第三段：将函数的实际参数传入即可<code>(ch, sb, bs, dst, i)</code>，最外层加上一个大括号。</p><p>接着三个宏表示 将对<strong>对应地址处的值</strong>操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP0_1CON  (*(volatile u32 *)0xE02002E0) <span class="hljs-comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.25.1*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP0_3CON  (*(volatile u32 *)0xE0200320) <span class="hljs-comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.27.1*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP0_6CON  (*(volatile u32 *)0xE0200380) <span class="hljs-comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.30.1*/</span></span><br></code></pre></td></tr></tbody></table></figure><p><code>NF8_ReadPage_Adv(a,b,c)</code>与<code>CopySDMMCtoMem(ch, sb, bs, dst, i)</code>一致，不在讲解。</p><table><thead><tr><th>宏</th><th>作用</th></tr></thead><tbody><tr><td>CopySDMMCtoMem(ch, sb, bs, dst, i)</td><td>从SD/MMC拷贝（加载）块到内存中的函数 （从通道ch的sb块处，加载bs块内存到以dst起始的地方）</td></tr><tr><td>NF8_ReadPage_Adv(a,b,c)</td><td>从nand flash拷贝（加载）页到内存中的函数（a：要复制的源块地址号，b：要复制的源页地址号，c：目标缓冲区指针，返回值成功或失败）</td></tr></tbody></table><p>接着就进入到<code>copy_bl2_to_ram</code>，整个<code>copy_bl2_to_ram</code>框架如下。也就是上来先定义bl2的大小为250k（编译结束后生成u-boot.bin大小为240k），所以此处最好大小调大一些（建议512k）。OM为寄存器<code>0xE0000004</code>中存储的值，通过手册（<code>SIAP</code> 中<code>3 Boot configuration</code>）可知OM低5位控制着从哪里启动，所以下面两个分支也就是选择从哪边启动。0x2（0b0010）也即<code>Nand 2KB,5cycle X-TAL</code>；0xc（0b1100）也即<code>SD/MMC X-TAL</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* board/samsung/smart210/smart210.c */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">copy_bl2_to_ram</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    u32 bl2Size = <span class="hljs-number">250</span> * <span class="hljs-number">1024</span>;         <span class="hljs-comment">// 250K</span><br>    u32 OM = *(<span class="hljs-keyword">volatile</span> u32 *)(<span class="hljs-number">0xE0000004</span>); <span class="hljs-comment">// OM Register</span><br>    OM &amp;= <span class="hljs-number">0x1F</span>;                                    <span class="hljs-comment">// 取出低5位OM[4:0]</span><br>    <span class="hljs-keyword">if</span> (OM == <span class="hljs-number">0x2</span>) {       <span class="hljs-comment">// Nand 2KB,5cycle X-TAL</span><br>        ...<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (OM == <span class="hljs-number">0xC</span>) {           <span class="hljs-comment">// SD/MMC X-TAL</span><br>        ...<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204112027872.png"></p><p>先分析SD/MMC下的代码（SD卡下的代码），首先取出当前boot的<code>V210_SDMMC_BASE</code>基地址（查看手册<code>SIAP</code> 中<code>2.6 Global Variable</code> ），接着看手册<code>S5PV210_UM_REV1.1.pdf</code>中的<code>7.9.1 REGISTER MAP</code> 找出对应地址的channel，然后从对应channel的SD卡中将以<code>32块开始的250k数据</code>拷贝到SDRAM中的<code>CONFIG_SYS_SDRAM_BASE</code> （<code>0x20000000</code>）中去。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* board/samsung/smart210/smart210.c */</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (OM == <span class="hljs-number">0xC</span>) {<br>    u32 V210_SDMMC_BASE = *(<span class="hljs-keyword">volatile</span> u32 *)(<span class="hljs-number">0xD0037488</span>);    <span class="hljs-comment">// V210_SDMMC_BASE</span><br>            u8 ch = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">/* 7.9.1 SD/MMC REGISTER MAP */</span><br>            <span class="hljs-keyword">if</span> (V210_SDMMC_BASE == <span class="hljs-number">0xEB000000</span>)<br>                    ch = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (V210_SDMMC_BASE == <span class="hljs-number">0xEB200000</span>)<br>                    ch = <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 将BL2 从SD卡（32块开始的250k区域数据）拷贝到SDRAM中</span><br>            CopySDMMCtoMem(ch, <span class="hljs-number">32</span>, bl2Size / <span class="hljs-number">512</span>, (u32 *)CONFIG_SYS_SDRAM_BASE, <span class="hljs-number">0</span>);<br>        }<br></code></pre></td></tr></tbody></table></figure><p>接着分析如果u-boot在nand中是怎样将BL2拷贝到内存中的？</p><p>首先初始化配置，将配置写入到 <code>nand_reg-&gt;nfconf</code> 和 <code>nand_reg-&gt;nfcont</code> 中，接着配置GPIO。<code>pages = bl2Size/2048</code>，看一下BL2一共有多少页。下一个<code>offset = 0x4000/2048</code>，意思是BL2在nand的页偏移。<code>0x4000/512 = 32blocks</code>，也就是在nand中第32个block开始，后256k</p><blockquote><p><code>void writel(unsigned char data, unsigned short addr)</code> 往内存映射的IO空间上写数据</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* board/samsung/smart210/smart210.c */</span><br><span class="hljs-keyword">if</span> (OM == <span class="hljs-number">0x2</span>) {<br>            u32 cfg = <span class="hljs-number">0</span>;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s5pv210_nand</span> *<span class="hljs-title">nand_reg</span> =</span> (<span class="hljs-keyword">struct</span> s5pv210_nand *)(<span class="hljs-keyword">struct</span> s5pv210_nand *)samsung_get_base_nand();<br><br>            <span class="hljs-comment">/* initialize hardware */</span><br>            <span class="hljs-comment">/* HCLK_PSYS=133MHz(7.5ns) */</span><br>            cfg =   (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">23</span>) |   <span class="hljs-comment">/* Disable 1-bit and 4-bit ECC */</span><br>                       (<span class="hljs-number">0x3</span> &lt;&lt; <span class="hljs-number">12</span>) |   <span class="hljs-comment">/* 7.5ns * 2 &gt; 12ns tALS tCLS */</span><br>                       (<span class="hljs-number">0x2</span> &lt;&lt; <span class="hljs-number">8</span>) |    <span class="hljs-comment">/* (1+1) * 7.5ns &gt; 12ns (tWP) */</span><br>                       (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">4</span>) |    <span class="hljs-comment">/* (0+1) * 7.5 &gt; 5ns (tCLH/tALH) */</span><br>                       (<span class="hljs-number">0x0</span> &lt;&lt; <span class="hljs-number">3</span>) |    <span class="hljs-comment">/* SLC NAND Flash */</span><br>                       (<span class="hljs-number">0x0</span> &lt;&lt; <span class="hljs-number">2</span>) |    <span class="hljs-comment">/* 2KBytes/Page */</span><br>                       (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>);     <span class="hljs-comment">/* 5 address cycle */</span><br><br>            writel(cfg, &amp;nand_reg-&gt;nfconf);<br><br>            writel((<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) | (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">0</span>), &amp;nand_reg-&gt;nfcont);<br>            <span class="hljs-comment">/* Disable chip select and Enable NAND Flash Controller */</span><br><br>            <span class="hljs-comment">/* Config GPIO */</span><br>            MP0_1CON &amp;= ~(<span class="hljs-number">0xFFFF</span> &lt;&lt; <span class="hljs-number">8</span>);<br>            MP0_1CON |= (<span class="hljs-number">0x3333</span> &lt;&lt; <span class="hljs-number">8</span>);<br>            MP0_3CON = <span class="hljs-number">0x22222222</span>;<br>            MP0_6CON = <span class="hljs-number">0x22222222</span>;<br><br>            <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> pages = bl2Size / <span class="hljs-number">2048</span>;             <span class="hljs-comment">//</span><br>            <span class="hljs-type">int</span> offset = <span class="hljs-number">0x4000</span> / <span class="hljs-number">2048</span>;             <span class="hljs-comment">// u-boot.bin</span><br>            u8 *p = (u8 *)CONFIG_SYS_SDRAM_BASE;<br>            <span class="hljs-keyword">for</span> (; i &lt; pages; i++, p += <span class="hljs-number">2048</span>, offset += <span class="hljs-number">1</span>)<br>            NF8_ReadPage_Adv(offset / <span class="hljs-number">64</span>, offset % <span class="hljs-number">64</span>, p);<br>        }<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204112111124.png"></p><h4 id="board-init-f"><a href="#board-init-f" class="headerlink" title="board_init_f"></a>board_init_f</h4><p><code>board_init_f</code> 在<code>arch/arm/lib/board.c</code>中，天哪，这是个什？这么多代码。</p><p>一点点分析吧，首先定义一堆变量，指针等。将<code>gd</code>（<code>global data</code>）中清零，什么，gd又是个什？gd是在什么时候赋值？什么时候分配空间的呢？</p><p>在<a href="#_main">_main</a>中通过<code>sub sp,sp,#GD_SIZE</code>给gd分配了空间，后面通过 <code>mov r9，sp</code>更新gd指针，使之指向分配的空间。所以此处直接清零没有任何问题。</p><h5 id="global-data"><a href="#global-data" class="headerlink" title="global_data"></a>global_data</h5><blockquote><p>在某些情况下，uboot运行在某些只读存储器上，在uboot被重定向到RAM（可读可写）之前，我们都无法写入数据，更无法通过全局变量来传递数据。而global_data则是为了解决这个问题。</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include/asm-generic/global_data.h */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">global_data</span> {</span><br><span class="hljs-type">bd_t</span> *bd;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baudrate;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cpu_clk;<span class="hljs-comment">/* CPU clock in Hz!*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bus_clk;<br><span class="hljs-comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pci_clk;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mem_clk;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fb_base;<span class="hljs-comment">/* Base address of framebuffer mem */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> post_log_word;  <span class="hljs-comment">/* Record POST activities */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> post_log_res; <span class="hljs-comment">/* success of POST test */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> post_init_f_time;  <span class="hljs-comment">/* When post_init_f started */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BOARD_TYPES</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> board_type;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> have_console;<span class="hljs-comment">/* serial_init() was called */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PRE_CONSOLE_BUFFER</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> precon_buf_idx;<span class="hljs-comment">/* Pre-Console buffer index */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> do_mdm_init;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> be_quiet;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> env_addr;<span class="hljs-comment">/* Address  of Environment struct */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> env_valid;<span class="hljs-comment">/* Checksum of Environment valid? */</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ram_top;<span class="hljs-comment">/* Top address of RAM used by U-Boot */</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> relocaddr;<span class="hljs-comment">/* Start address of U-Boot in RAM */</span><br><span class="hljs-type">phys_size_t</span> ram_size;<span class="hljs-comment">/* RAM size */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mon_len;<span class="hljs-comment">/* monitor len */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> irq_sp;<span class="hljs-comment">/* irq stack pointer */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_addr_sp;<span class="hljs-comment">/* start_addr_stackpointer */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> reloc_off;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">global_data</span> *<span class="hljs-title">new_gd</span>;</span><span class="hljs-comment">/* relocated global data */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DM</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>*<span class="hljs-title">dm_root</span>;</span><span class="hljs-comment">/* Root instance for Driver Model */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">uclass_root</span>;</span><span class="hljs-comment">/* Head of core tree */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">void</span> *fdt_blob;<span class="hljs-comment">/* Our device tree, NULL if none */</span><br><span class="hljs-type">void</span> *new_fdt;<span class="hljs-comment">/* Relocated FDT */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fdt_size;<span class="hljs-comment">/* Space reserved for relocated FDT */</span><br><span class="hljs-type">void</span> **jt;<span class="hljs-comment">/* jump table */</span><br><span class="hljs-type">char</span> env_buf[<span class="hljs-number">32</span>];<span class="hljs-comment">/* buffer for getenv() before reloc. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TRACE</span><br><span class="hljs-type">void</span>*trace_buff;<span class="hljs-comment">/* The trace buffer */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SYS_I2C)</span><br><span class="hljs-type">int</span>cur_i2c_bus;<span class="hljs-comment">/* current used i2c bus */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timebase_h;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timebase_l;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arch_global_data</span> <span class="hljs-title">arch</span>;</span><span class="hljs-comment">/* architecture-specific data */</span><br>} <span class="hljs-type">gd_t</span>;<br></code></pre></td></tr></tbody></table></figure><p>重点说明</p><ul><li><code>bd_t *bd</code>：board info数据结构定义,位于文件 include/asm-arm/u-boot.h定义,主要是保存开发板的相关参数。</li><li><code>unsigned long env_addr</code>：环境变量的地址。</li><li><code>unsigned long ram_top</code>：RAM空间的顶端地址</li><li><code>unsigned long relocaddr</code>：UBOOT重定向后地址</li><li><code>phys_size_t ram_size</code>：物理ram的size</li><li><code>unsigned long irq_sp</code>：中断的堆栈地址</li><li><code>unsigned long start_addr_sp</code>：堆栈地址</li><li><code>unsigned long reloc_off</code>：uboot的relocation的偏移</li><li><code>struct global_data *new_gd</code>：重定向后的struct global_data结构体</li><li><code>const void *fdt_blob</code>：设备的dtb地址</li><li><code>void *new_fdt</code>：relocation之后的dtb地址</li><li><code>unsigned long fdt_size</code>：dtb的长度</li><li><code>struct udevice *cur_serial_dev</code>：当前使用的串口设备。</li></ul><p>计算监视区（monitor）长度（<code>__bss_end</code> - <code>_start</code>）并给<code>gd-&gt;mon_len</code></p><p>从环境变量中查找<code>fdtcontroladdr</code>，如果存在则更新<code>gd-&gt;fdt_blob</code></p><blockquote><p><code>ulong getenv_ulong(const char *name, int base, ulong default_val)</code>从环境变量中查找name，存在返回name对应的数值，不存在返回default_val。其中base为进制，例如10、16等。</p><p>环境变量的存储用hash表实现</p></blockquote><p>这一段的意思遍历<code>init_sequence</code>，<code>init_sequence</code>存放的是一系列的函数首地址，通过循环不断将函数地址取出<code>解引用</code>并调用。如果函数返回不为0，表示有错误则一直在此循环。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch/arm/lib/board.c */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_f</span><span class="hljs-params">(ulong bootflag)</span>{<br>...<br><span class="hljs-keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {<br><span class="hljs-keyword">if</span> ((*init_fnc_ptr)() != <span class="hljs-number">0</span>) {<br>hang ();<br>}<br>}<br>        ...<br> }<br>----------------------------------------------------------------------------<br>    <span class="hljs-type">init_fnc_t</span> *init_sequence[] = {<br>arch_cpu_init,<span class="hljs-comment">/* basic arch cpu dependent setup */</span><br>mark_bootstage,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_OF_CONTROL</span><br>fdtdec_check_fdt,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_BOARD_EARLY_INIT_F)</span><br>board_early_init_f,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>timer_init,<span class="hljs-comment">/* initialize timer */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BOARD_POSTCLK_INIT</span><br>board_postclk_init,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FSL_ESDHC</span><br>get_clocks,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>env_init,<span class="hljs-comment">/* initialize environment */</span><br>init_baudrate,<span class="hljs-comment">/* initialze baudrate settings */</span><br>serial_init,  <span class="hljs-comment">/* serial communications setup */</span><br>console_init_f,  <span class="hljs-comment">/* stage 1 init of console */</span><br>display_banner,<span class="hljs-comment">/* say that we are here */</span><br>print_cpuinfo,<span class="hljs-comment">/* display cpu info (and speed) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_DISPLAY_BOARDINFO)</span><br>checkboard,<span class="hljs-comment">/* display board info */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span><br>init_func_i2c,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>dram_init,<span class="hljs-comment">/* configure available RAM banks */</span><br><span class="hljs-literal">NULL</span>,<br>};<br></code></pre></td></tr></tbody></table></figure><p>让我们一个个的看看这些函数都是干什么的。</p><h5 id="arch-cpu-init"><a href="#arch-cpu-init" class="headerlink" title="arch_cpu_init"></a>arch_cpu_init</h5><p>这个函数做的是针对特定CPU的初始化，u-boot支持很多CPU，不同CPU的初始化也不尽相同，因此u-boot提供了arch_cpu_init用于CPU初始化。这个函数由移植者根据自己的硬件（CPU）的情况来提供，如果不提供，则默认的是一个仅返回0的函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch/arm/lib/board.c */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">arch_cpu_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((weak, alias(<span class="hljs-string">"__arch_cpu_init"</span>)))</span>;<br><br><span class="hljs-type">int</span> __arch_cpu_init(<span class="hljs-type">void</span>)<br>{<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="mark-bootstage"><a href="#mark-bootstage" class="headerlink" title="mark_bootstage"></a>mark_bootstage</h5><p>其中<code>bootstage_mark_name（id,name）</code>用于标记当前运行的id和名字。这个函数也就是用来标记当前运行的函数为<code>board_init_f</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch/arm/lib/board.c */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mark_bootstage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, <span class="hljs-string">"board_init_f"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="fdtdec-check-fdt"><a href="#fdtdec-check-fdt" class="headerlink" title="fdtdec_check_fdt"></a>fdtdec_check_fdt</h5><p>由于未配置<code>CONFIG_OF_CONTROL</code>，所以不会检查fdt。</p><p>这个函数的功能是，在 控制台未准备好之前必须有一个FDT，否则会panic。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* lib/fdtdec.c */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fdtdec_check_fdt</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We must have an FDT, but we cannot panic() yet since the console</span><br><span class="hljs-comment"> * is not ready. So for now, just assert(). Boards which need an early</span><br><span class="hljs-comment"> * FDT (prior to console ready) will need to make their own</span><br><span class="hljs-comment"> * arrangements and do their own checks.</span><br><span class="hljs-comment"> */</span><br>assert(!fdtdec_prepare_fdt());<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="board-early-init-f"><a href="#board-early-init-f" class="headerlink" title="board_early_init_f"></a>board_early_init_f</h5><p>由于未配置<code>CONFIG_BOARD_EARLY_INIT_F</code>，不会执行</p><h5 id="timer-init"><a href="#timer-init" class="headerlink" title="timer_init"></a>timer_init</h5><p>这个配置貌似跟cpu有关系，在每个不同的cpu有不同的 <code>timer_init</code>，另外在 <code>lib/time.c</code> 中也有一个弱空实现。</p><p>s5pv210芯片的在 <code>arch/arm/cpu/armv7/s5p-common/time.c</code>中。</p><p>使用SOC的<code>Pwm Timer4</code>作为定时器，Timer4 没有输出引脚，不耽误其Pwm功能。设置Pwm Timer4 4分频，设置占空比为100000ns、周期为100000ns,开启定时器4。</p><p>接着将<code>gd-&gt;arch.timer_reset_value</code>复位。更新<code>gd-&gt;arch.lastinc</code>，复位<code>gd-&gt;arch.lastinc = readl(&amp;timer-&gt;tcnto4);</code>，<code>gd-&gt;arch.tbl = 0;</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/cpu/armv7/s5p-common/time.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-comment">/* PWM Timer 4 */</span><br>pwm_init(<span class="hljs-number">4</span>, MUX_DIV_4, <span class="hljs-number">0</span>);<br>pwm_config(<span class="hljs-number">4</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">100000</span>);<br>pwm_enable(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">/* Use this as the current monotonic time in us */</span><br>gd-&gt;arch.timer_reset_value = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* Use this as the last timer value we saw */</span><br>gd-&gt;arch.lastinc = timer_get_us_down();<br>reset_timer_masked();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="board-postclk-init"><a href="#board-postclk-init" class="headerlink" title="board_postclk_init"></a>board_postclk_init</h5><p>由于未配置<code>CONFIG_BOARD_POSTCLK_INIT</code>，不会执行</p><h5 id="get-clocks"><a href="#get-clocks" class="headerlink" title="get_clocks"></a>get_clocks</h5><p>由于未配置<code>CONFIG_FSL_ESDHC</code>，不会执行</p><h5 id="env-init"><a href="#env-init" class="headerlink" title="env_init"></a>env_init</h5><p>通过SI在Symbols中搜索发现有多个<code>env_init</code>,猜测是不同的板子可能存到不同的存储设备上。</p><blockquote><ol><li><p>环境变量可能位于很多地方，比如EEPROM、FLASH等地方，枚举<code>enum env_location</code>定义了一些常量用于标识环境变量的位置。这些常量有ENVL_EEPROM、ENVL_EXT4等</p></li><li><p>uboot获取环境变量的位置时，有一个先后顺序，比如优先看环境变量是否在EEPROM中。这个优先顺序实现很简单：定义一个数组<code>env_locations</code>，<strong>数组里存的是环境变量各个的位置，存的顺序就是优先顺序，</strong>然后只要从下标为0开始访问这个数组，即可按照数组指定的优先顺序来获取环境变量的位置。</p></li><li><p>对于存在于不同位置的环境变量，u-boot会使用<code>U_BOOT_ENV_LOCATION</code>定义一个相应的<code>struct env_driver</code>类型的entry，多个entry在内存中连续分布，因此可以向遍历数组元素那样遍历这些entry。而实现内存连续分布的关键在于<strong>自定义段</strong>，</p> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">在链接脚本中将这些段按照段名的字母顺序排列:</span><br><span class="hljs-comment">.u_boot_list : {</span><br><span class="hljs-comment">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="hljs-comment"> }</span><br><span class="hljs-comment">因此可用u_boot_list_2_env_driver_1标记这些entry的起始地址</span><br><span class="hljs-comment">而使用u_boot_list_2_env_driver_3标记相应的结束地址</span><br><span class="hljs-comment">*/</span><br>.u_boot_list_2_env_driver_1<br>.u_boot_list_2_env_driver_2_eeprom<br>.u_boot_list_2_env_driver_2_ext4<br>.u_boot_list_2_env_driver_3<br></code></pre></td></tr></tbody></table></figure></li></ol></blockquote><p>smart210这个板子在执行<code>saveenv</code>是直接存储环境变量到<code>NAND</code>的0x60000处。实际上通过编译脚本来说更有说服力，首先，看下<code>common/Makefile</code>，要编译对应的文件，需要使能相关宏后才会编译。再次查看<code>include/configs/smart210.h</code>，其定义了<code>#define CONFIG_ENV_IS_IN_NAND 1</code>，所以env_init的路径为<code>common/env_nand.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># environment</span><br>obj-y += env_attr.o<br>obj-y += env_callback.o<br>obj-y += env_flags.o<br>obj-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o<br>obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o<br>extra-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o<br>obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_embedded.o<br>extra-$(CONFIG_ENV_IS_IN_FLASH) += env_embedded.o<br>obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_embedded.o<br>obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o<br>obj-$(CONFIG_ENV_IS_IN_MMC) += env_mmc.o<br>obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o<br>obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o<br>obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o<br>obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o<br>obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o<br>obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o<br>obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o<br>obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o<br></code></pre></td></tr></tbody></table></figure><p>所以我们只关心<code>common/env_nand.c</code>中的，别看代码这么长。实际上<code>ENV_IS_EMBEDDED</code>与<code>CONFIG_NAND_ENV_DST</code>我们都没有定义，所以真正的代码只有两句。</p><p>从注释就基本可以看出这个函数的作用，因为<code>env_init</code>要早于静态存储器的初始化，所以无法进行<code>env</code>的读写，这里将<code>gd</code>中的<code>env</code>相关变量进行配置，默认设置<code>env</code>为<code>valid</code>。<code>default_environment</code>是什么？<strong>TODO:待分析</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gd-&gt;env_addr= (ulong)&amp;default_environment[<span class="hljs-number">0</span>];<br>gd-&gt;env_valid  = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/env_nand.c</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is called before nand_init() so we can't read NAND to</span><br><span class="hljs-comment"> * validate env data.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Mark it OK for now. env_relocate() in env_common.c will call our</span><br><span class="hljs-comment"> * relocate function which does the real validation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When using a NAND boot image (like sequoia_nand), the environment</span><br><span class="hljs-comment"> * can be embedded or attached to the U-Boot image in NAND flash.</span><br><span class="hljs-comment"> * This way the SPL loads not only the U-Boot image from NAND but</span><br><span class="hljs-comment"> * also the environment.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ENV_IS_EMBEDDED) || defined(CONFIG_NAND_ENV_DST)</span><br><span class="hljs-type">int</span> crc1_ok = <span class="hljs-number">0</span>, crc2_ok = <span class="hljs-number">0</span>;<br><span class="hljs-type">env_t</span> *tmp_env1;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ENV_OFFSET_REDUND</span><br><span class="hljs-type">env_t</span> *tmp_env2;<br><br>tmp_env2 = (<span class="hljs-type">env_t</span> *)((ulong)env_ptr + CONFIG_ENV_SIZE);<br>crc2_ok = crc32(<span class="hljs-number">0</span>, tmp_env2-&gt;data, ENV_SIZE) == tmp_env2-&gt;crc;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>tmp_env1 = env_ptr;<br>crc1_ok = crc32(<span class="hljs-number">0</span>, tmp_env1-&gt;data, ENV_SIZE) == tmp_env1-&gt;crc;<br><br><span class="hljs-keyword">if</span> (!crc1_ok &amp;&amp; !crc2_ok) {<br>gd-&gt;env_addr= <span class="hljs-number">0</span>;<br>gd-&gt;env_valid= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (crc1_ok &amp;&amp; !crc2_ok) {<br>gd-&gt;env_valid = <span class="hljs-number">1</span>;<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ENV_OFFSET_REDUND</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!crc1_ok &amp;&amp; crc2_ok) {<br>gd-&gt;env_valid = <span class="hljs-number">2</span>;<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-comment">/* both ok - check serial */</span><br><span class="hljs-keyword">if</span> (tmp_env1-&gt;flags == <span class="hljs-number">255</span> &amp;&amp; tmp_env2-&gt;flags == <span class="hljs-number">0</span>)<br>gd-&gt;env_valid = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp_env2-&gt;flags == <span class="hljs-number">255</span> &amp;&amp; tmp_env1-&gt;flags == <span class="hljs-number">0</span>)<br>gd-&gt;env_valid = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp_env1-&gt;flags &gt; tmp_env2-&gt;flags)<br>gd-&gt;env_valid = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp_env2-&gt;flags &gt; tmp_env1-&gt;flags)<br>gd-&gt;env_valid = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">/* flags are equal - almost impossible */</span><br>gd-&gt;env_valid = <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-keyword">if</span> (gd-&gt;env_valid == <span class="hljs-number">2</span>)<br>env_ptr = tmp_env2;<br><span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">if</span> (gd-&gt;env_valid == <span class="hljs-number">1</span>)<br>env_ptr = tmp_env1;<br><br>gd-&gt;env_addr = (ulong)env_ptr-&gt;data;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */</span></span><br>gd-&gt;env_addr= (ulong)&amp;default_environment[<span class="hljs-number">0</span>];<br>gd-&gt;env_valid= <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */</span></span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="init-baudrate"><a href="#init-baudrate" class="headerlink" title="init_baudrate"></a>init_baudrate</h5><p>上面我们介绍了<code>getenv_ulong</code>，从环境变量中获取参数，所以本函数的作用是从环境变量中取出<code>baudrate</code>对应的值给<code>gd</code>，以10进制，如果没有，默认为<code>115200</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch/arm/lib/board.c */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">init_baudrate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>gd-&gt;baudrate = getenv_ulong(<span class="hljs-string">"baudrate"</span>, <span class="hljs-number">10</span>, CONFIG_BAUDRATE);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="serial-init"><a href="#serial-init" class="headerlink" title="serial_init"></a>serial_init</h5><p>获取当前的串口设备，并调用当前串口设备的start成员函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* drivers/serial/serial.c */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">serial_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-keyword">return</span> get_current()-&gt;start();<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于此时重定位还没做，GD_FLG_RELOC标志未设置，因此条件满足，会进入第一个分支，因此<code>dev = default_serial_console();</code>后面调用start。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* drivers/serial/serial.c */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> serial_device *<span class="hljs-title function_">get_current</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span> *<span class="hljs-title">dev</span>;</span><br><br><span class="hljs-keyword">if</span> (!(gd-&gt;flags &amp; GD_FLG_RELOC))<br>dev = default_serial_console();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!serial_current)<br>dev = default_serial_console();<br><span class="hljs-keyword">else</span><br>dev = serial_current;<br><br><span class="hljs-comment">/* We must have a console device */</span><br><span class="hljs-keyword">if</span> (!dev) {<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SPL_BUILD</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Cannot find console\n"</span>);<br>hang();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>panic(<span class="hljs-string">"Cannot find console\n"</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br><br><span class="hljs-keyword">return</span> dev;<br>}<br></code></pre></td></tr></tbody></table></figure><p>后面在重定位完成后，且当前<code>serial_current</code>也不为空，会进入第三个分支，而第三个分支的<code>dev = serial_current;</code>serial_current是怎么确认是哪个串口的呢？</p><p><code>board_init_r</code>中会有一个串口初始化 <code>serial_initialize</code>函数，这个函数中前面的都是初始化各种串口，比如我们板卡对应型号的为 <code>s5p_serial_initialize</code>，最后一个是设置要使用串口。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers/serial/serial.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_initialize</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>         ...<br>s5p_serial_initialize();<br>        ...<br>serial_assign(default_serial_console()-&gt;name);<br>}<br></code></pre></td></tr></tbody></table></figure><p>进去看下，四个注册函数，对应着我们板卡上的串口0-3</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers/serial/serial_s5p.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">s5p_serial_initialize</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>serial_register(&amp;s5p_serial0_device);<br>serial_register(&amp;s5p_serial1_device);<br>serial_register(&amp;s5p_serial2_device);<br>serial_register(&amp;s5p_serial3_device);<br>}<br></code></pre></td></tr></tbody></table></figure><p>而这个注册函数，则是把当前注册的串口添加到链表的最前面。哦对，所有注册的设备节点都串在一个链表中，该链表的头部，也就是<code>最近</code>注册过的。</p><p>所以上面初始化函数实际上就是将所有串口设备串到同一个链表中<code>serial_devices</code>。那么，如何知道使用哪个串口呢？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers/serial/serial.c</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span> *<span class="hljs-title">serial_devices</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span> *<span class="hljs-title">serial_current</span>;</span><br>...<br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> serial_device *dev)</span><br>{<br>dev-&gt;next = serial_devices;<br>serial_devices = dev;<br>}<br></code></pre></td></tr></tbody></table></figure><p>实际上，我们在其定义的结构中也许能看出一些端倪。其结构中有一个<code>name</code>成员，正是通过这个来确定是哪个串口的。那怎么确定的呢？名字又是从哪里来的呢？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/serial.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span> {</span><br><span class="hljs-comment">/* enough bytes to match alignment of following func pointer */</span><br><span class="hljs-type">char</span>name[<span class="hljs-number">16</span>];<br><br><span class="hljs-type">int</span>(*start)(<span class="hljs-type">void</span>);<br><span class="hljs-type">int</span>(*stop)(<span class="hljs-type">void</span>);<br><span class="hljs-type">void</span>(*setbrg)(<span class="hljs-type">void</span>);<br><span class="hljs-type">int</span>(*getc)(<span class="hljs-type">void</span>);<br><span class="hljs-type">int</span>(*tstc)(<span class="hljs-type">void</span>);<br><span class="hljs-type">void</span>(*putc)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c);<br><span class="hljs-type">void</span>(*<span class="hljs-built_in">puts</span>)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_POST &amp; CONFIG_SYS_POST_UART</span><br><span class="hljs-type">void</span>(*loop)(<span class="hljs-type">int</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span>*<span class="hljs-title">next</span>;</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>别忘记，我们在<code>serial_initialize</code>还有另一个函数，<code>serial_assign(default_serial_console()-&gt;name);</code>，没错，这个就是决定你使用哪个串口的关键。首先我们看下这个函数，之后在去<code>default_serial_console()</code>。代码很少，看着就很喜欢，其意思是什么呢？遍历上面我们初始化时注册的那些串口设备的链表，然后拿出名字来与传进来的名字比较，如果一致，<code>strcmp</code>返回<code>0</code>，条件不成立，继续往下走，<code>serial_current = s</code>就把从链表中获取的要使用串口描述符地址取出来了然后赋值给<code>serial_current</code>，所以后面通过<code>get_current</code>返回的地址为我们设定的串口描述符的地址。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">serial_assign</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span> *<span class="hljs-title">s</span>;</span><br><br><span class="hljs-keyword">for</span> (s = serial_devices; s; s = s-&gt;next) {<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(s-&gt;name, name))<br><span class="hljs-keyword">continue</span>;<br>serial_current = s;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-keyword">return</span> -EINVAL;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们看下 <code>default_serial_console()</code>，在serial_s5p中存在一个弱实现，<code>CONFIG_OF_CONTROL</code>我们没定义，所以选择另一个分支，<code>config.enable=1</code>，然后我们在<code>smart210.h中</code>定义了<code>CONFIG_SERIAL0</code>为1，所以此处<code>return &amp;s5p_serial0_device;</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers/serial/serial_s5p.c</span><br>__weak <span class="hljs-keyword">struct</span> serial_device *<span class="hljs-title function_">default_serial_console</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_OF_CONTROL</span><br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> ((!config.base_addr) &amp;&amp; (fdtdec_decode_console(&amp;index, &amp;config))) {<br>debug(<span class="hljs-string">"Cannot decode default console node\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br><br><span class="hljs-keyword">switch</span> (config.port_id) {<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> &amp;s5p_serial0_device;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-keyword">return</span> &amp;s5p_serial1_device;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">return</span> &amp;s5p_serial2_device;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-keyword">return</span> &amp;s5p_serial3_device;<br><span class="hljs-keyword">default</span>:<br>debug(<span class="hljs-string">"Unknown config.port_id: %d"</span>, config.port_id);<br><span class="hljs-keyword">break</span>;<br>}<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>config.enabled = <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SERIAL0)</span><br><span class="hljs-keyword">return</span> &amp;s5p_serial0_device;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SERIAL1)</span><br><span class="hljs-keyword">return</span> &amp;s5p_serial1_device;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SERIAL2)</span><br><span class="hljs-keyword">return</span> &amp;s5p_serial2_device;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SERIAL3)</span><br><span class="hljs-keyword">return</span> &amp;s5p_serial3_device;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">"CONFIG_SERIAL? missing."</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br></code></pre></td></tr></tbody></table></figure><p>在同文件中，<code>s5p_serial0_device</code> 是这样被定义的，也就是上面这三行，实际上定义了一堆函数，并把函数与结构体对应起来</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">DECLARE_S5P_SERIAL_FUNCTIONS(<span class="hljs-number">0</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span> <span class="hljs-title">s5p_serial0_device</span> =</span><br>INIT_S5P_SERIAL_STRUCTURE(<span class="hljs-number">0</span>, <span class="hljs-string">"s5pser0"</span>);<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_S5P_SERIAL_STRUCTURE(port, __name) {  \</span><br><span class="hljs-meta">.name= __name,\</span><br><span class="hljs-meta">.start= s5p_serial##port##_init,     \</span><br><span class="hljs-meta">.stop= NULL, \</span><br><span class="hljs-meta">.setbrg= s5p_serial##port##_setbrg,  \</span><br><span class="hljs-meta">.getc= s5p_serial##port##_getc,\</span><br><span class="hljs-meta">.tstc= s5p_serial##port##_tstc,  \</span><br><span class="hljs-meta">.putc= s5p_serial##port##_putc,       \</span><br><span class="hljs-meta">.puts= s5p_serial##port##_puts,       \</span><br><span class="hljs-meta">}</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_S5P_SERIAL_FUNCTIONS(port) \</span><br><span class="hljs-meta">static int s5p_serial##port##_init(void) { return serial_init_dev(port); } \</span><br><span class="hljs-meta">static void s5p_serial##port##_setbrg(void) { serial_setbrg_dev(port); } \</span><br><span class="hljs-meta">static int s5p_serial##port##_getc(void) { return serial_getc_dev(port); } \</span><br><span class="hljs-meta">static int s5p_serial##port##_tstc(void) { return serial_tstc_dev(port); } \</span><br><span class="hljs-meta">static void s5p_serial##port##_putc(const char c) { serial_putc_dev(c, port); } \</span><br><span class="hljs-meta">static void s5p_serial##port##_puts(const char *s) { serial_puts_dev(s, port); }</span><br>    <br>------------------------------------------------------------------------------------------<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">s5p_serial0_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> { <span class="hljs-keyword">return</span> serial_init_dev(port); } <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">s5p_serial0_setbrg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> { serial_setbrg_dev(port); } <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">s5p_serial0_getc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> { <span class="hljs-keyword">return</span> serial_getc_dev(port); } <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">s5p_serial0_tstc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> { <span class="hljs-keyword">return</span> serial_tstc_dev(port); } <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">s5p_serial0_putc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c)</span> { serial_putc_dev(c, port); } <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">s5p_serial0_puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> { serial_puts_dev(s, port); }<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span> <span class="hljs-title">s5p_serial0_device</span> =</span> {<br>        .name= <span class="hljs-string">"s5pser0"</span>,\<br>.start    = s5p_serial0_init    \<br>.stop  = <span class="hljs-literal">NULL</span>, \<br>.setbrg   = s5p_serial0_setbrg,    \<br>        .getc  = s5p_serial0_getc,              \<br>.tstc   = s5p_serial0_tstc,   \<br>.putc = s5p_serial0_putc,      \<br>.<span class="hljs-built_in">puts</span> = s5p_serial0_puts,      \<br> }<br></code></pre></td></tr></tbody></table></figure><h5 id="console-init-f"><a href="#console-init-f" class="headerlink" title="console_init_f"></a>console_init_f</h5><p>将<code>gd</code>中<code>have_console</code>置为1，然后打印Pre-Console Buffer中的数据。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* common/console.c */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">console_init_f</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>gd-&gt;have_console = <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SILENT_CONSOLE</span><br><span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">"silent"</span>) != <span class="hljs-literal">NULL</span>)<br>gd-&gt;flags |= GD_FLG_SILENT;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>print_pre_console_buffer();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="display-banner"><a href="#display-banner" class="headerlink" title="display_banner"></a>display_banner</h5><p>上面我们已经配置好串口，现在可以输出信息到终端了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch/arm/lib/board.c */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">display_banner</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n\n%s\n\n"</span>, version_string);<br>debug(<span class="hljs-string">"U-Boot code: %08lX -&gt; %08lX  BSS: -&gt; %08lX\n"</span>,(ulong)&amp;_start,(ulong)&amp;__bss_start, (ulong)&amp;__bss_end);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span><br>debug(<span class="hljs-string">"Modem Support enabled\n"</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_USE_IRQ</span><br>debug(<span class="hljs-string">"IRQ Stack: %08lx\n"</span>, IRQ_STACK_START);<br>debug(<span class="hljs-string">"FIQ Stack: %08lx\n"</span>, FIQ_STACK_START);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此处就是打印，如果定义了宏 <code>DEBUG</code>，将输出更多信息。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>U-Boot 2014.04-g8819fbf-dirty (Apr 12 2022 - 10:19:11) for SMART210<br><br></code></pre></td></tr></tbody></table></figure><h5 id="print-cpuinfo"><a href="#print-cpuinfo" class="headerlink" title="print_cpuinfo"></a>print_cpuinfo</h5><p>打印CPU信息，所以该函数位置为 <code>arch/arm/cpu/armv7/s5p-common/cpu_info.c</code></p><p>输出CPU名字、ID、频率信息。如</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CPU:S5PC110@1000MHz<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch/arm/cpu/armv7/s5p-common/cpu_info.c */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">print_cpuinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"CPU:\t%s%X@%sMHz\n"</span>,<br>s5p_get_cpu_name(), s5p_cpu_id,<br>strmhz(buf, get_arm_clk()));<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="checkboard"><a href="#checkboard" class="headerlink" title="checkboard"></a>checkboard</h5><p>配置了宏<code>CONFIG_DISPLAY_BOARDINFO</code>,位于<code>board/samsung/smart210/smart210.c</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Board:SMART210<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* board/samsung/smart210/smart210.c */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">checkboard</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Board:\tSMART210\n"</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="init-func-i2c"><a href="#init-func-i2c" class="headerlink" title="init_func_i2c"></a>init_func_i2c</h5><p>似乎没有配置，暂不分析。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* board/samsung/smart210/smart210.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">init_func_i2c</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"I2C:   "</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYS_I2C</span><br>i2c_init_all();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"ready\n"</span>);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></tbody></table></figure><h5 id="negative-squared-cross-mark-dram-init"><a href="#negative-squared-cross-mark-dram-init" class="headerlink" title=":negative_squared_cross_mark: dram_init"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> dram_init</h5><p>更新<code>gd</code>中的内存大小，其值为<code> get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE)</code>。<code>get_ram_size</code>又是什么呢？是用来检测内给定范围内的内存是否有效的一个小函数，在当前函数中检测范围为<code>[PHYS_SDRAM_1, PHYS_SDRAM_1+PHYS_SDRAM_1_SIZE]</code>。如果没有问题，返回<code>PHYS_SDRAM_1_SIZE</code>。<code>TODO:剩下的下次在分析</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// board/samsung/smart210.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dram_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>gd-&gt;ram_size = get_ram_size((<span class="hljs-type">long</span> *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/memsize.c</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">get_ram_size</span><span class="hljs-params">(<span class="hljs-type">long</span> *base, <span class="hljs-type">long</span> maxsize)</span><br>{<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> *addr;<br><span class="hljs-type">long</span>           save[<span class="hljs-number">32</span>];<br><span class="hljs-type">long</span>           cnt;<br><span class="hljs-type">long</span>           val;<br><span class="hljs-type">long</span>           size;<br><span class="hljs-type">int</span>            i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (cnt = (maxsize / <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">long</span>)) &gt;&gt; <span class="hljs-number">1</span>; cnt &gt; <span class="hljs-number">0</span>; cnt &gt;&gt;= <span class="hljs-number">1</span>) {<br>addr = base + cnt;<span class="hljs-comment">/* pointer arith! */</span><br>sync ();<br>save[i++] = *addr;<br>sync ();<br>*addr = ~cnt;<br>}<br><br>addr = base;<br>sync ();<br>save[i] = *addr;<br>sync ();<br>*addr = <span class="hljs-number">0</span>;<br><br>sync ();<br><span class="hljs-keyword">if</span> ((val = *addr) != <span class="hljs-number">0</span>) {<br><span class="hljs-comment">/* Restore the original data before leaving the function.</span><br><span class="hljs-comment"> */</span><br>sync ();<br>*addr = save[i];<br><span class="hljs-keyword">for</span> (cnt = <span class="hljs-number">1</span>; cnt &lt; maxsize / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>); cnt &lt;&lt;= <span class="hljs-number">1</span>) {<br>addr  = base + cnt;<br>sync ();<br>*addr = save[--i];<br>}<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>}<br><br><span class="hljs-keyword">for</span> (cnt = <span class="hljs-number">1</span>; cnt &lt; maxsize / <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">long</span>); cnt &lt;&lt;= <span class="hljs-number">1</span>) {<br>addr = base + cnt;<span class="hljs-comment">/* pointer arith! */</span><br>val = *addr;<br>*addr = save[--i];<br><span class="hljs-keyword">if</span> (val != ~cnt) {<br>size = cnt * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">long</span>);<br><span class="hljs-comment">/* Restore the original data before leaving the function.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (cnt &lt;&lt;= <span class="hljs-number">1</span>; cnt &lt; maxsize / <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">long</span>); cnt &lt;&lt;= <span class="hljs-number">1</span>) {<br>addr  = base + cnt;<br>*addr = save[--i];<br>}<br><span class="hljs-keyword">return</span> (size);<br>}<br>}<br><br><span class="hljs-keyword">return</span> (maxsize);<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p>上文我们将那一个初始化列表讲完了。下面接着对board_init_f分析。根据打印日志，删除没有用的宏开关，方便我们分析代码。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">U-Boot 2014.04-g8819fbf-dirty (Apr 12 2022 - 10:16:10) for SMART210<br><br>U-Boot code: 20000000 -&gt; 2003A2D0  BSS: -&gt; 200706D0<br>CPU:S5PC110@1000MHz<br>Board:SMART210<br>monitor len: 000706D0<br>ramsize: 20000000<br>TLB table from 3fff0000 to 3fff4000<br>Top of RAM usable for U-Boot at: 3fff0000<br>Reserving 449k for U-Boot at: 3ff7f000<br>Reserving 1280k for malloc() at: 3fe3f000<br>Reserving 32 Bytes for Board Info at: 3fe3efe0<br>Reserving 160 Bytes for Global Data at: 3fe3ef40<br>New Stack Pointer is: 3fe3ef30<br>RAM Configuration:<br>Bank #0: 20000000 512 MiB<br>relocation Offset is: 1ff7f000<br>WARNING: Caches not enabled<br></code></pre></td></tr></tbody></table></figure><p>接着打印<code>gd-&gt;mon_len</code>和<code>gd-&gt;ram_size</code>，然后<code>addr=CONFIG_SYS_SDRAM_BASE+get_effective_memsize();</code> ，其中<code>CONFIG_SYS_SDRAM_BASE</code>为SDRAM起始地址，也就是<code>0x20000000</code>，<code>get_effective_memsize</code>在 <code>common/memsize.c</code> 有一个弱实现，其余与板级相关的地方没有发现该函数。</p><p>所以确认调用为<code>common/memsize.c</code>中<code>get_effective_memsize()</code>，其实也就是判断定义内存大小是否超过了最大界限，超过则返回最大值，否则<code>gd-&gt;ram_size</code>。而<code>gd-&gt;ram_size</code>在<a href="#dram_init">dram_init</a>中得到的大小为<code>PHYS_SDRAM_1_SIZE</code>，所以addr此时为<code>CONFIG_SYS_SDRAM_BASE+PHYS_SDRAM_1_SIZE</code>。</p><p>然后更新<code>gd-&gt;arch.tlb_size</code> 值为<code>PGTABLE_SIZE</code>（<code>4096*4</code>，也就是4k），然后下面一个64kb对齐（换句话说<code>PGTABLE_SIZE</code>最大可设置为64kb），接着更新<code>gd-&gt;arch.tlb_addr</code>。然后4kb对齐，<code>addr -= gd-&gt;mon_len</code>，继续4kb对齐。</p><p>最终内存分布是这样的。</p><p>总结一下，这段代码首先用来<code>更新gd结构体</code>中的内容，然后将<code>gd</code>结构体在拷贝到内存中对应位置。</p><p>此处需要注意下，当前代码还没有重定位，所以<code>_start</code>还是在起始位置，也就是<code>0x20000000</code>处，</p><p><code>gd-&gt;relocaddr = addr</code>，<code>gd-&gt;reloc_off = addr - (ulong)&amp;_start</code>，<code>gd-&gt;relocaddr</code>存储的为重定位后的地址，所以<code>gd-&gt;reloc_off</code>存储的是重定位前后<code>_start</code>的绝对值。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131359579.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* arch/arm/lib/board.c */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_f</span><span class="hljs-params">(ulong bootflag)</span><br>{<br><span class="hljs-type">bd_t</span> *bd;<br><span class="hljs-type">init_fnc_t</span> **init_fnc_ptr;<br><span class="hljs-type">gd_t</span> *id;<br>ulong addr, addr_sp;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PRAM</span><br>ulong reg;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">void</span> *new_fdt = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">size_t</span> fdt_size = <span class="hljs-number">0</span>;<br><br>...<br>debug(<span class="hljs-string">"monitor len: %08lX\n"</span>, gd-&gt;mon_len);<br>debug(<span class="hljs-string">"ramsize: %08lX\n"</span>, gd-&gt;ram_size);<br>addr = CONFIG_SYS_SDRAM_BASE + get_effective_memsize();<span class="hljs-comment">/* CONFIG_SYS_SDRAM_BASE+PHYS_SDRAM_1_SIZE */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF))</span><br><span class="hljs-comment">/* reserve TLB table */</span><br>gd-&gt;arch.tlb_size = PGTABLE_SIZE;<br>addr -= gd-&gt;arch.tlb_size;<br><br><span class="hljs-comment">/* round down to next 64 kB limit */</span><br>addr &amp;= ~(<span class="hljs-number">0x10000</span> - <span class="hljs-number">1</span>);<br><br>gd-&gt;arch.tlb_addr = addr;<br>debug(<span class="hljs-string">"TLB table from %08lx to %08lx\n"</span>, addr, addr + gd-&gt;arch.tlb_size);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* round down to next 4 kB limit */</span><br>addr &amp;= ~(<span class="hljs-number">4096</span> - <span class="hljs-number">1</span>);<br>debug(<span class="hljs-string">"Top of RAM usable for U-Boot at: %08lx\n"</span>, addr);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * reserve memory for U-Boot code, data &amp; bss</span><br><span class="hljs-comment"> * round down to next 4 kB limit</span><br><span class="hljs-comment"> */</span><br>addr -= gd-&gt;mon_len;<br>addr &amp;= ~(<span class="hljs-number">4096</span> - <span class="hljs-number">1</span>);<br><br>debug(<span class="hljs-string">"Reserving %ldk for U-Boot at: %08lx\n"</span>, gd-&gt;mon_len &gt;&gt; <span class="hljs-number">10</span>, addr);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SPL_BUILD</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * reserve memory for malloc() arena</span><br><span class="hljs-comment"> */</span><br>addr_sp = addr - TOTAL_MALLOC_LEN;<br>debug(<span class="hljs-string">"Reserving %dk for malloc() at: %08lx\n"</span>,<br>TOTAL_MALLOC_LEN &gt;&gt; <span class="hljs-number">10</span>, addr_sp);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * (permanently) allocate a Board Info struct</span><br><span class="hljs-comment"> * and a permanent copy of the "global" data</span><br><span class="hljs-comment"> */</span><br>addr_sp -= <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">bd_t</span>);<br>bd = (<span class="hljs-type">bd_t</span> *) addr_sp;<br>gd-&gt;bd = bd;<br>debug(<span class="hljs-string">"Reserving %zu Bytes for Board Info at: %08lx\n"</span>,<br><span class="hljs-keyword">sizeof</span> (<span class="hljs-type">bd_t</span>), addr_sp);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MACH_TYPE</span><br>gd-&gt;bd-&gt;bi_arch_number = CONFIG_MACH_TYPE; <span class="hljs-comment">/* board id for Linux */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>addr_sp -= <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">gd_t</span>);<br>id = (<span class="hljs-type">gd_t</span> *) addr_sp;<br>debug(<span class="hljs-string">"Reserving %zu Bytes for Global Data at: %08lx\n"</span>,<br><span class="hljs-keyword">sizeof</span> (<span class="hljs-type">gd_t</span>), addr_sp);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ARM64</span><br><span class="hljs-comment">/* setup stackpointer for exeptions */</span><br>gd-&gt;irq_sp = addr_sp;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_USE_IRQ</span><br>addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);<br>debug(<span class="hljs-string">"Reserving %zu Bytes for IRQ stack at: %08lx\n"</span>,<br>CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* leave 3 words for abort-stack    */</span><br>addr_sp -= <span class="hljs-number">12</span>;<br><br><span class="hljs-comment">/* 8-byte alignment for ABI compliance */</span><br>addr_sp &amp;= ~<span class="hljs-number">0x07</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span><span class="hljs-comment">/* CONFIG_ARM64 */</span></span><br><span class="hljs-comment">/* 16-byte alignment for ABI compliance */</span><br>addr_sp &amp;= ~<span class="hljs-number">0x0f</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span><span class="hljs-comment">/* CONFIG_ARM64 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>addr_sp += <span class="hljs-number">128</span>;<span class="hljs-comment">/* leave 32 words for abort-stack   */</span><br>gd-&gt;irq_sp = addr_sp;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>debug(<span class="hljs-string">"New Stack Pointer is: %08lx\n"</span>, addr_sp);<br><br>gd-&gt;bd-&gt;bi_baudrate = gd-&gt;baudrate;<br><span class="hljs-comment">/* Ram ist board specific, so move it to board code ... */</span><br>dram_init_banksize(); <span class="hljs-comment">// 更新gd-&gt;bd-&gt;bi_dram[0] 的start(PHYS_SDRAM_1)和size(PHYS_SDRAM_1_SIZE)</span><br>display_dram_config();<span class="hljs-comment">/* and display it */</span><br><br>gd-&gt;relocaddr = addr;<br>gd-&gt;start_addr_sp = addr_sp;<br>gd-&gt;reloc_off = addr - (ulong)&amp;_start;<br>debug(<span class="hljs-string">"relocation Offset is: %08lx\n"</span>, gd-&gt;reloc_off);<br><span class="hljs-keyword">if</span> (new_fdt) {<br><span class="hljs-built_in">memcpy</span>(new_fdt, gd-&gt;fdt_blob, fdt_size);<br>gd-&gt;fdt_blob = new_fdt;<br>}<br><span class="hljs-built_in">memcpy</span>(id, (<span class="hljs-type">void</span> *)gd, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">gd_t</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="main-继续，接上文"><a href="#main-继续，接上文" class="headerlink" title="_main 继续，接上文"></a>_main 继续，接上文</h4><p>在非SPL下，接着就是更新<code>sp</code>和<code>gd</code>，然后重定位代码。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br>...<br>#if ! defined(CONFIG_SPL_BUILD)<br>ldrsp, [r9, #GD_START_ADDR_SP]/* sp = gd-&gt;start_addr_sp */<br>bicsp, sp, #7/* 8-byte alignment for ABI compliance */<br>ldrr9, [r9, #GD_BD]/* r9 = gd-&gt;bd */<br>subr9, r9, #GD_SIZE/* new GD is below bd */<br>...<br>#endif<br></code></pre></td></tr></tbody></table></figure><p><code>GD_START_ADDR_SP</code>在 <code>include/generated/generic-asm-offsets.h</code>中定义，其值为 <code>start_addr_sp</code> 在  <code>global_data</code> 结构中的相对偏移，同样是编译后才生成的。</p><p>由上面的代码可知，刚刚为<code>gd</code>也就是<code>global_data</code>分配了大小为<code>GD_SIZE</code>的空间，现在<code>r9</code>和<code>sp</code>内的数据为地址<code>CONFIG_SYS_INIT_SP_ADDR - GD_SIZE</code> （需要8字节对齐）中的数据。换句话说此时<code>r9</code>中为<code>gd</code>的地址，那么再加上 <code>GD_START_ADDR_SP</code>，也就是<code>gd+GD_START_ADDR_SP</code>，将<code>gd+GD_START_ADDR_SP</code>地址中的值（<code>gd-&gt;start_addr_sp</code>）传递给<code>sp</code>，接着8字节对齐。</p><p>然后更新<code>r9</code>的值为<code>[r9 + GD_BD]</code>，也就是<code>r9 = gd-&gt;bd</code>。</p><p>然后又分配一个大小为<code>GD_SIZE</code>的空间。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br>...<br>#if ! defined(CONFIG_SPL_BUILD)<br>...<br>adrlr, here<br>ldrr0, [r9, #GD_RELOC_OFF]/* r0 = gd-&gt;reloc_off */<br>addlr, lr, r0<br>ldrr0, [r9, #GD_RELOCADDR]/* r0 = gd-&gt;relocaddr */<br>brelocate_code<br><br>here:<br>/* Set up final (full) environment */<br>blc_runtime_cpu_setup/* we still call old routine here */<br>...<br><br>#endif<br></code></pre></td></tr></tbody></table></figure><p>将<code>here</code>处的<code>相对地址</code>复制给<code>lr</code>，将<code>gd</code>结构中的<code>reloc_off</code>值（其相对于<code>gd</code>偏移为<code>GD_RELOC_OFF</code>）给<code>r0</code>。</p><p><code>lr</code>与<code>r0</code>相加给<code>lr</code>,即<code>lr = lr + r0</code>，将<code>gd</code>结构中的<code>relocaddr</code>值（其相对于<code>gd</code>偏移为<code>GD_RELOCADDR</code>）给<code>r0</code>。</p><p>此时<code>lr = here + gd-&gt;reloc_off</code>，<code>r0 = gd-&gt;relocaddr</code>，然后调用<code>relocate_code</code>。</p><h4 id="relocate-code"><a href="#relocate-code" class="headerlink" title="relocate_code"></a>relocate_code</h4><p>其定义位于 <code>include/common.h</code>中，由于定义了宏<code>CONFIG_ARM</code>，所以其声明为如下代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/common.h</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">relocate_code</span><span class="hljs-params">(ulong)</span>;<br></code></pre></td></tr></tbody></table></figure><p>其实现位于 <code>arch/arm/lib/relocate.S</code>中</p><p>是一个比较麻烦的地方，并且需要函数传参。</p><p>看代码，进入到<code>relocate_code</code>后，此时r0寄存器中数据为<code>gd-&gt;relocaddr</code>，也就是为重定位后的u-boot程序地址。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/relocate.S<br>ENTRY(relocate_code)<br>ldrr1, =__image_copy_start/* r1 &lt;- SRC &amp;__image_copy_start */<br>subsr4, r0, r1/* r4 &lt;- relocation offset */<br>beqrelocate_done/* skip relocation */<br>ldrr2, =__image_copy_end/* r2 &lt;- SRC &amp;__image_copy_end */<br><br>copy_loop:<br>ldmiar1!, {r10-r11}/* copy from source address [r1]    */<br>stmiar0!, {r10-r11}/* copy to   target address [r0]    */<br>cmpr1, r2/* until source end address [r2]    */<br>blocopy_loop<br><br>/*<br> * fix .rel.dyn relocations<br> */<br>ldrr2, =__rel_dyn_start/* r2 &lt;- SRC &amp;__rel_dyn_start */<br>ldrr3, =__rel_dyn_end/* r3 &lt;- SRC &amp;__rel_dyn_end */<br>fixloop:<br>ldmiar2!, {r0-r1}/* (r0,r1) &lt;- (SRC location,fixup) */<br>andr1, r1, #0xff<br>cmpr1, #23/* relative fixup? */<br>bnefixnext<br><br>/* relative fix: increase location by offset */<br>addr0, r0, r4<br>ldrr1, [r0]<br>addr1, r1, r4<br>strr1, [r0]<br>fixnext:<br>cmpr2, r3<br>blofixloop<br><br>relocate_done:<br><br>#ifdef __XSCALE__<br>/*<br> * On xscale, icache must be invalidated and write buffers drained,<br> * even with cache disabled - 4.2.7 of xscale core developer's manual<br> */<br>mcrp15, 0, r0, c7, c7, 0/* invalidate icache */<br>mcrp15, 0, r0, c7, c10, 4/* drain write buffer */<br>#endif<br><br>/* ARMv4- don't know bx lr but the assembler fails to see that */<br><br>#ifdef __ARM_ARCH_4__<br>mov        pc, lr<br>#else<br>bx        lr<br>#endif<br><br>ENDPROC(relocate_code)<br></code></pre></td></tr></tbody></table></figure><p>在进入第一句代码之前，我们先了解一下<code>__image_copy_start</code>和<code>__image_copy_end</code>，在<code>arch/arc/lib/sections.c</code>定义，并通过<code>__attribute__</code>放到了对应段中。在编译之后，这些段有什么用呢？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arc/lib/sections.c</span><br><span class="hljs-type">char</span> __bss_start[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__bss_start"</span>)));<br><span class="hljs-type">char</span> __bss_end[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__bss_end"</span>)));<br><span class="hljs-type">char</span> __image_copy_start[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__image_copy_start"</span>)));<br><span class="hljs-type">char</span> __image_copy_end[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__image_copy_end"</span>)));<br><span class="hljs-type">char</span> __rel_dyn_start[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__rel_dyn_start"</span>)));<br><span class="hljs-type">char</span> __rel_dyn_end[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__rel_dyn_end"</span>)));<br><span class="hljs-type">char</span> __text_start[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__text_start"</span>)));<br><span class="hljs-type">char</span> __text_end[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__text_end"</span>)));<br><span class="hljs-type">char</span> __init_end[<span class="hljs-number">0</span>] __attribute__((section(<span class="hljs-string">".__init_end"</span>)));<br></code></pre></td></tr></tbody></table></figure><p>查看<code>u-boot.lds</code>，在 <code>arch/arm/cpu/u-boot.lds</code>，但这个并不是最终的，最终的链接脚本是在此基础上生成的。需要编译u-boot后会在根目录下才会生成u-boot.lds。</p><blockquote><p>GNU编译器生成的目标文件缺省为elf格式，elf文件由若干段（section）组成，如不特殊指明，由C源程序生成的目标代码中包含如下段：</p><ul><li>.text(正文段)包含程序的指令代码；</li><li>.data(数据段)包含固定的数据，如常量、字符串；</li><li>.bss(未初始化数据段)包含未初始化的变量、数组等。</li></ul><p>C++源程序生成的目标代码中还包括</p><ul><li>.fini(析构函数代码)</li><li>.init(构造函数代码)等.<br>  链接器的任务就是将多个目标文件的.text、.data和.bss等段链接在一起，而链接脚本文件是告诉链接器从什么地址开始放置这些段.简而言之，由于一个工程中有多个.c文件，当它们生成.o文件后如何安排它们在可执行文件中的顺序，这就是链接脚本的作用.</li></ul><p>这里以u-boot的lds为例说明uboot的链接过程，首先看一下GNU官方网站上对.lds文件形式的完整描述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;SECTIONS {<br>&gt;...<br>&gt;secname start <span class="hljs-title function_">BLOCK</span><span class="hljs-params">(align)</span> <span class="hljs-params">(NOLOAD)</span> : <span class="hljs-title function_">AT</span> <span class="hljs-params">( ldadr )</span><br>&gt;{ contents } &gt;region :phdr =fill<br>&gt;...<br>&gt;}<br></code></pre></td></tr></tbody></table></figure><p>其中，secname和contents是必须的，前者用来命名这个段，后者用来确定代码中的什么部分放在这个段，以下是对这个描述中的一些关键字的解释。</p><ul><li>secname：段名</li><li>contents：决定哪些内容放在本段，可以是整个目标文件（如start.o），也可以是目标- 文件中的某段（代码段、数据段等）（如start.o (.text .rodata)）</li><li>start：是段的重定位地址，本段链接（运行）的地址，如果代码中有位置无关指令，程序运行时这个段必须放在这个地址上。start可以用任意一种描述地址的符号来描述。<br>  AT（ldadr）：定义本段存储（加载）的地址，如果不使用这个选项，则加载地址等于运行地址，通过这个选项可以控制各段分别保存于输出文件中不同的位置。</li></ul></blockquote><p>上面我们了解到lds文件的格式之后，就可以直接阅读下面的lds文件， <code>. = 0x00000000;</code>定义当前位置为<code>0x00000000</code>; 紧接着<code>.text:{...}</code>，所以.text的相对地址也是0，而在.text中<code>*(.__image_copy_start)</code>又在开始的位置，也就是说把我们前面定义的<code>.__image_copy_start</code>段在链接的时候挪到这个位置当前位置（0x0），紧接着<code>arch/arm/cpu/armv7/start.o (.text*)</code> 将<code>arch/arm/cpu/armv7/start.o</code>中的<code>.text*</code>段全部挪到当前位置（当前位置为 0x0 + <code>.__image_copy_start</code>大小），后面也是如此。</p><p>…</p><p>将<code>.__image_copy_end</code>挪到<code>.image_copy_end</code>段。所以从<code>.__image_copy_start</code>到<code>.__image_copy_end</code>包括了代码段、只读数据段、读写数据段、<code>.u_boot_list</code>(uboot的命令)。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c">OUTPUT_FORMAT(<span class="hljs-string">"elf32-littlearm"</span>, <span class="hljs-string">"elf32-littlearm"</span>, <span class="hljs-string">"elf32-littlearm"</span>)<br>OUTPUT_ARCH(arm)<br>ENTRY(_start)<br>SECTIONS<br>{<br> . = <span class="hljs-number">0x00000000</span>;<br> . = ALIGN(<span class="hljs-number">4</span>);<br> .text :<br> {<br>  *(.__image_copy_start)<br>  arch/arm/cpu/armv7/start.o (.text*)<br>  *(.text*)<br> }<br> . = ALIGN(<span class="hljs-number">4</span>);<br> .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }<br> . = ALIGN(<span class="hljs-number">4</span>);<br> .data : {<br>  *(.data*)<br> }<br> . = ALIGN(<span class="hljs-number">4</span>);<br> . = .;<br> . = ALIGN(<span class="hljs-number">4</span>);<br> .u_boot_list : {<br>  KEEP(*(SORT(.u_boot_list*)));<br> }<br> . = ALIGN(<span class="hljs-number">4</span>);<br> .image_copy_end :<br> {<br>  *(.__image_copy_end)<br> }<br> .rel_dyn_start :<br> {<br>  *(.__rel_dyn_start)<br> }<br> .rel.dyn : {<br>  *(.rel*)<br> }<br> .rel_dyn_end :<br> {<br>  *(.__rel_dyn_end)<br> }<br> .end :<br> {<br>  *(.__end)<br> }<br> _image_binary_end = .;<br> . = ALIGN(<span class="hljs-number">4096</span>);<br> .mmutable : {<br>  *(.mmutable)<br> }<br> .bss_start __rel_dyn_start (OVERLAY) : {<br>  KEEP(*(.__bss_start));<br>  __bss_base = .;<br> }<br> .bss __bss_base (OVERLAY) : {<br>  *(.bss*)<br>   . = ALIGN(<span class="hljs-number">4</span>);<br>   __bss_limit = .;<br> }<br> .bss_end __bss_limit (OVERLAY) : {<br>  KEEP(*(.__bss_end));<br> }<br> .dynsym _image_binary_end : { *(.dynsym) }<br> .dynbss : { *(.dynbss) }<br> .dynstr : { *(.dynstr*) }<br> .dynamic : { *(.dynamic*) }<br> .plt : { *(.plt*) }<br> .interp : { *(.interp*) }<br> .gnu.hash : { *(.gnu.hash) }<br> .gnu : { *(.gnu*) }<br> .ARM.exidx : { *(.ARM.exidx*) }<br> .gnu.linkonce.armexidx : { *(.gnu.linkonce.armexidx.*) }<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们回到代码<code>ldrr1, =__image_copy_start</code>则是将<code>__image_copy_start</code>的地址取出给到r1，<code>r4=r0-r1</code>,r0为重定位后的代码位置，r1为当前<code>__image_copy_start</code>的位置，那么r4为代码重定位前后的差，也就是<code>重定位的偏移</code>。<code>beq</code>实际上是一个跳转指令<code>b</code>和一个条件变量<code>eq</code>组合起来的，其意思也就是如果相等则跳转到<code>relocate_done</code>。什么意思呢？这个地方怎么可能会相等呢？不对，你在想想，当前代码的起始位置是<code>__image_copy_start</code>，重定位后代码的位置是r0即<code>gd-&gt;relocaddr</code>，当重定位后，当前代码的起始位置是哪呢？不就是<code>gd-&gt;relocaddr</code>，所以此时<code>r0-r1</code>为<code>0</code>，也即满足相等的条件，跳转到<code>relocate_done</code>，不需要重定位（<strong>此处有疑问？该代码上电后会执行两次吗？如果不会执行两次，那么相等这个条件也就不会满足，也就不会有跳转这个分支了。。。。</strong>）。重定位完成后执行xxxxxxx操作后跳出。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/relocate.S<br>ENTRY(relocate_code)<br>ldrr1, =__image_copy_start  /* r1 &lt;- SRC &amp;__image_copy_start */<br>subsr4, r0, r1       /* r4 &lt;- relocation offset */<br>beqrelocate_done   /* skip relocation */<br>ldrr2, =__image_copy_end    /* r2 &lt;- SRC &amp;__image_copy_end */<br>...<br><br>relocate_done:<br>#ifdef __XSCALE__<br>/*<br> * On xscale, icache must be invalidated and write buffers drained,<br> * even with cache disabled - 4.2.7 of xscale core developer's manual<br> */<br>mcrp15, 0, r0, c7, c7, 0/* invalidate icache */<br>mcrp15, 0, r0, c7, c10, 4/* drain write buffer */<br>#endif<br>...<br>ENDPROC(relocate_code)<br></code></pre></td></tr></tbody></table></figure><p>建议先去寄存器中查看LDM、STM命令以及模式的用法。此时<code>r0=gd-&gt;relocaddr</code>，<code>r1=&amp;__image_copy_start</code>，<code>r2=&amp;__image_copy_end</code></p><p>此处从r1地址开始，将数据拷贝r10、r11，每次拷贝后r1地址加4，结束后r1的值为刚开始的值+8。</p><p>然后此处从r0地址开始，将r10、r11寄存器中的值拷贝到r0地址处，每次拷贝结束后r0地址加4，所以，结束后r0的值为刚开始的值+8。</p><p>比较r1和r2的值，当r1&lt;r2时，跳转到 <code>copy_loop</code>，继续拷贝。直到r1&gt;=r2时，拷贝结束。此时<code>__image_copy_start</code>至<code>__image_copy_end</code>地址的数据已经拷贝到<code>gd-&gt;relocaddr</code>处了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/relocate.S<br>ENTRY(relocate_code)<br>...<br>copy_loop:<br>ldmiar1!, {r10-r11}/* copy from source address [r1]    */<br>stmiar0!, {r10-r11}/* copy to   target address [r0]    */<br>cmpr1, r2          /* until source end address [r2]    */<br>blocopy_loop<br>...<br>ENDPROC(relocate_code)<br></code></pre></td></tr></tbody></table></figure><p>接着 <code>r2=__rel_dyn_start</code>，<code>r3=__rel_dyn_end</code>，从r2处加载数据到r0和r1中，取出r1中数据的低8位，与23比较，如果不相等，跳转到<code>fixnext</code>，比较r2、r3，如果r2&lt;r3，说明没修正结束，接着修正；如果相等，<code>r0=r0+r4</code>，停，r4是什么？大家还有印象不，前面我们在刚进入<code>relocate_code</code>，r4为重定位前后的代码的相对地址偏移。所以代码的意思就是r0=r0+r4，然后以r0中存的值为地址取出 已拷贝到新地址的.text段中的值；将该值加上新旧.text段的偏移，在写回到 新的.text段中。这样就完成了重定位。<strong>此处需明白重定位，到底重定位的是什么？</strong></p><p>代码解释完了，但是这又是什么意思啊？完全不理解，从<code>.rel.dyn</code>取出的是什么值啊，接下来我们了解了解<code>.rel.dyn</code>段，之后在回来看这段代码，应该就一目了然了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/relocate.S<br>ENTRY(relocate_code)<br>...<br>/*<br> * fix .rel.dyn relocations<br> */<br>ldrr2, =__rel_dyn_start/* r2 &lt;- SRC &amp;__rel_dyn_start */<br>ldrr3, =__rel_dyn_end/* r3 &lt;- SRC &amp;__rel_dyn_end */<br>fixloop:<br>ldmiar2!, {r0-r1}/* (r0,r1) &lt;- (SRC location,fixup) */<br>andr1, r1, #0xff<br>cmpr1, #23/* relative fixup? */<br>bnefixnext<br><br>/* relative fix: increase location by offset */<br>addr0, r0, r4<br>ldrr1, [r0]<br>addr1, r1, r4<br>strr1, [r0]<br>fixnext:<br>cmpr2, r3<br>blofixloop<br><br>relocate_done:<br>...<br>ENDPROC(relocate_code)<br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>.rel.dyn</code>  存放<code>.text</code>段中需要重定位地址的集合</p><p>接下来我们来说明一个很重要的概念。</p><p>　u-boot在启动过程中，会把自己拷贝到RAM的顶端去执行。这一拷贝带来的问题是执行地址的混乱。代码的执行地址通常都是在编译时有链接地址指定的，如何保证拷贝前后都可以执行呢？<br>　　一个办法是使用拷贝到RAM后的地址作为编译时的链接地址，拷贝前所有函数与全局变量的调用都增加偏移量。（如VxWorks的bootloader）尽量减少拷贝前需要执行的代码量。<br>　　另一个办法是把image编译成与地址无关的程序，也就是PIC - Position independent code。编译器无法保证代码的独立性，它需要与加载器配合起来。U-boot自己加载自己，所以它自己就是加载器。PIC依赖于下面两种技术：<br>1） 使用相对地址<br>2） 加载器可以自动更新涉及到绝对地址的指令<br>　　对于PowerPC架构，u-boot只是在编译时使用了-fpic，这种方式会生成一个.got段来存储绝对地址符号。对于ARM架构，则是在编译时使用-mword-relocations，生成与位置无关代码，链接时使用-pie生成.rel.dyn段，该段中的每个条目被称为一个LABEL，用来存储绝对地址符号的地址。</p><p>为了理解地址表的概念我们分析一段代码。</p><p>借助两个工具 <code>readelf</code>、<code>objdump</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131923808.png"></p><p>通过readelf的<code>-r</code>选项查看<code>relocate段</code>，<code>readelf -r u-boot | less</code>打开，看到类型是可重定位段，其中有了<code>offset、info、type</code>以及后面没有为空的项。m每个需要修改地址的信息占用8个字节，第一个为可重定位的地址，第二个为0x17，0x17对应的是Arm32位。那么让我们看一下第一条可重定位地址处（0x20000020）放的是什么？<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204132024704.png"></p><p>通过命令 <code>objdump -S u-boot | less</code> ，看到此处存的正是 start.S 中<code>_undefined_instruction: .word undefined_instruction</code>入口地址。</p><p>因为这个入口地址如果直接.text段拷贝过去，将来执行跳转的还是旧的uboot里面的undefined_instruction，而不是我们新uboot里面的undefined_instruction，所以这个要修改。</p><p>即要修改所有位置有关码的地址。</p><p>如何修改？</p><p>很简单，<strong>旧的地址的值是什么我们取出来加上 新地址和旧地址的偏移，然后存入新的地址就可以了</strong>。</p><p>因为编译器已经帮我们剥离出来要修改的地址和它所属的类型，存放进了rel.dyn段，所以我们只要修改新地址的就可以。<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131932905.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131936214.png"></p></blockquote><p>未定义__ARM_ARCH_4__，所以执行<code>bx lr</code>，而此时<code>lr</code>中的值为<code>here + gd-&gt;reloc_off</code>，怎么解释？此时重定位已经完成，重定位后的地址差值为<code>gd-&gt;reloc_off</code>，<code>here</code> 为<code>here</code>处的相对地址，所以<strong>二者相加后为重定位后的<code>here</code>处的地址</strong>，然后跳回去。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/relocate.S<br>/* ARMv4- don't know bx lr but the assembler fails to see that */<br><br>#ifdef __ARM_ARCH_4__<br>mov        pc, lr<br>#else<br>bx        lr<br>#endif<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204151531408.png"></p><h4 id="main-继续，接上文：here"><a href="#main-继续，接上文：here" class="headerlink" title="_main 继续，接上文：here"></a>_main 继续，接上文：here</h4><p>回到<code>here</code>处开始跳转到 <code>c_runtime_cpu_setup</code>，<code>c_runtime_cpu_setup</code>执行结束后返回。</p><h5 id="negative-squared-cross-mark-c-runtime-cpu-setup"><a href="#negative-squared-cross-mark-c-runtime-cpu-setup" class="headerlink" title=":negative_squared_cross_mark: c_runtime_cpu_setup"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> c_runtime_cpu_setup</h5><p><code>c_runtime_cpu_setup</code>位于 <code>arch/arm/cpu/armv7/start.S</code>，</p><p>配置协处理器CP15</p><p>加载程序起始地址到r0，设置<code>CP15 VBAR register</code> </p><p><strong>TODO：待补充</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/cpu/armv7/start.S<br>ENTRY(c_runtime_cpu_setup)<br>/*<br> * If I-cache is enabled invalidate it<br> */<br>#ifndef CONFIG_SYS_ICACHE_OFF<br>mcr   p15, 0, r0, c7, c5, 0@ invalidate icache<br>mcr     p15, 0, r0, c7, c10, 4@ DSB<br>mcr     p15, 0, r0, c7, c5, 4@ ISB<br>#endif<br>/*<br> * Move vector table<br> */<br>/* Set vector address in CP15 VBAR register */<br>ldr     r0, =_start<br>mcr     p15, 0, r0, c12, c0, 0  @Set VBAR<br><br>bxlr<br><br>ENDPROC(c_runtime_cpu_setup)<br></code></pre></td></tr></tbody></table></figure><p>继续执行<code>r0 = __bss_start</code>，<code>r1 = __bss_end</code>，<code>r2 = 0</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br>here:<br><br>/* Set up final (full) environment */<br><br>blc_runtime_cpu_setup/* we still call old routine here */<br><br>ldrr0, =__bss_start/* this is auto-relocated! */<br>ldrr1, =__bss_end/* this is auto-relocated! */<br><br>movr2, #0x00000000/* prepare zero to clear BSS */<br></code></pre></td></tr></tbody></table></figure><p>将<code>[__bss_start,__bss_end]</code>范围内的内存清零。</p><p>比较<code>r0</code>和<code>r1</code>的值，首先<code>r0=r0-r1</code>,当满足条件<code>r0&lt;r1</code>时，将<code>r2</code>中的值0复制给以将<code>r0</code>的值作为地址的内存中，当满足条件<code>r0&lt;r1</code>时，<code>r0=r0+4</code>，当满足条件<code>r0&lt;r1</code>时，跳转到<code>clbss_l</code>处。接着循环，直到二者相等时，不满足条件，继续执行<code>bl coloured_LED_init</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br><br>clbss_l:cmpr0, r1/* while not at end of BSS */<br>strlor2, [r0]/* clear 32-bit BSS word */<br>addlor0, r0, #4/* move to next */<br>bloclbss_l<br></code></pre></td></tr></tbody></table></figure><p>跳转到coloured_LED_init，跳转到red_led_on，没啥内容。主要关注一下语法即可。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br>    <br>bl coloured_LED_init<br>bl red_led_on<br>------------------------------<br>// common/board_f.c<br>inline void __coloured_LED_init(void) {}<br>void coloured_LED_init(void)<br>        __attribute__((weak, alias("__coloured_LED_init")));<br>inline void __red_led_on(void) {}<br>void red_led_on(void) __attribute__((weak, alias("__red_led_on")));<br></code></pre></td></tr></tbody></table></figure><p><code>r0 = r9 = gd</code>，<code>r1 = [r9(gd) + GD_RELOCADDR]</code>，也就是说<code>r0</code>此时为<code>gd</code>,<code>r1</code>为相对于<code>gd</code>偏移<code>GD_RELOCADDR</code>的地址中的值。</p><p>将<code>pc</code>值更改为<code>board_init_r</code>，也就是跳转到<code>board_init_r</code>执行，此处不需要返回。因为要跳转到c代码，而c代码入口有两个参数，有APCS可知前四个整形实参被存入到a1-a4中，也即r0-r3中。此时r0为gd，r1为<code>gd-&gt;relocaddr</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; arch/arm/lib/crt0.S<br>/* call board_init_r(gd_t *id, ulong dest_addr) */<br>mov     r0, r9                  /* gd_t */<br>ldrr1, [r9, #GD_RELOCADDR]/* dest_addr */<br>/* call board_init_r */<br>ldrpc, =board_init_r/* this is auto-relocated! */<br><br>/* we should not return here. */<br></code></pre></td></tr></tbody></table></figure><p>到此 <code>_main</code>就结束了。</p><h4 id="board-init-r"><a href="#board-init-r" class="headerlink" title="board_init_r"></a>board_init_r</h4><p><del><strong>board_init_r</strong>函数位于<code>common/board_r.c</code>中，位置分析错误</del>，可以看下<code>common/Makefile</code>，通过命令查找 <code>grep -nr CONFIG_SYS_GENERIC_BOARD</code>有关其定义，在我们的<code>smart210.h</code>中并没有定义这个宏，所以调用的<code>board_init_r</code>不在此处的<code>board_r.c</code>中。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">boards</span><br><span class="hljs-meta prompt_">obj-$</span><span class="language-bash">(CONFIG_SYS_GENERIC_BOARD) += board_f.o</span><br><span class="hljs-meta prompt_">obj-$</span><span class="language-bash">(CONFIG_SYS_GENERIC_BOARD) += board_r.o</span><br></code></pre></td></tr></tbody></table></figure><p>所以 <code>board_init_r</code>函数其实位于 <code>arch/arm/lib/board.c</code>，跟<code>board_init_f</code>函数位于同一个文件中。</p><p>代码如下，我滴个老天爷这也太多了吧。一点点来，先把没用到的宏开关去掉。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>ulong malloc_start;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(CONFIG_SYS_NO_FLASH)</span><br>ulong flash_size;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>gd-&gt;flags |= GD_FLG_RELOC;<span class="hljs-comment">/* tell others: relocation done */</span><br>bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, <span class="hljs-string">"board_init_r"</span>);<br><br>monitor_flash_len = (ulong)&amp;__rel_dyn_end - (ulong)_start;<br><br><span class="hljs-comment">/* Enable caches */</span><br>enable_caches();<br><br>debug(<span class="hljs-string">"monitor flash len: %08lX\n"</span>, monitor_flash_len);<br>board_init();<span class="hljs-comment">/* Setup chipselects */</span><br>    <br>serial_initialize();<br><br>debug(<span class="hljs-string">"Now running in RAM - U-Boot at: %08lx\n"</span>, dest_addr);<br><br><span class="hljs-comment">/* The Malloc area is immediately below the monitor copy in DRAM */</span><br>malloc_start = dest_addr - TOTAL_MALLOC_LEN;<br>mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_EARLY_INIT_R</span><br>arch_early_init_r();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>power_init_board();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(CONFIG_SYS_NO_FLASH)</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Flash: "</span>);<br><br>flash_size = flash_init();<br><span class="hljs-keyword">if</span> (flash_size &gt; <span class="hljs-number">0</span>) {<br><span class="hljs-meta"># <span class="hljs-keyword">ifdef</span> CONFIG_SYS_FLASH_CHECKSUM</span><br>print_size(flash_size, <span class="hljs-string">""</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Compute and print flash CRC if flashchecksum is set to 'y'</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> Maybe we should add some WATCHDOG_RESET()? XXX</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (getenv_yesno(<span class="hljs-string">"flashchecksum"</span>) == <span class="hljs-number">1</span>) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"  CRC: %08X"</span>, crc32(<span class="hljs-number">0</span>,<br>(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) CONFIG_SYS_FLASH_BASE,<br>flash_size));<br>}<br>putc(<span class="hljs-string">'\n'</span>);<br><span class="hljs-meta"># <span class="hljs-keyword">else</span><span class="hljs-comment">/* !CONFIG_SYS_FLASH_CHECKSUM */</span></span><br>print_size(flash_size, <span class="hljs-string">"\n"</span>);<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_SYS_FLASH_CHECKSUM */</span></span><br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-built_in">puts</span>(failed);<br>hang();<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_CMD_NAND)</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"NAND:  "</span>);<br>nand_init();<span class="hljs-comment">/* go init the NAND */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HAS_DATAFLASH</span><br>AT91F_DataflashInit();<br>dataflash_print_info();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* initialize environment */</span><br><span class="hljs-keyword">if</span> (should_load_env())<br>env_relocate();<br><span class="hljs-keyword">else</span><br>set_default_env(<span class="hljs-literal">NULL</span>);<br><br>stdio_init();<span class="hljs-comment">/* get the devices list going. */</span><br><br>jumptable_init();<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_API)</span><br><span class="hljs-comment">/* Initialize API */</span><br>api_init();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>console_init_r();<span class="hljs-comment">/* fully init console as a device */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DISPLAY_BOARDINFO_LATE</span><br>checkboard();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_ARCH_MISC_INIT)</span><br><span class="hljs-comment">/* miscellaneous arch dependent initialisations */</span><br>arch_misc_init();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_MISC_INIT_R)</span><br><span class="hljs-comment">/* miscellaneous platform dependent initialisations */</span><br>misc_init_r();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br> <span class="hljs-comment">/* set up exceptions */</span><br>interrupt_init();<br><span class="hljs-comment">/* enable exceptions */</span><br>enable_interrupts();<br><br><span class="hljs-comment">/* Initialize from environment */</span><br>load_addr = getenv_ulong(<span class="hljs-string">"loadaddr"</span>, <span class="hljs-number">16</span>, load_addr);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BOARD_LATE_INIT</span><br>board_late_init();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BITBANGMII</span><br>bb_miiphy_init();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_CMD_NET)</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Net:   "</span>);<br>eth_initialize(gd-&gt;bd);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_RESET_PHY_R)</span><br>debug(<span class="hljs-string">"Reset Ethernet PHY\n"</span>);<br>reset_phy();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_POST</span><br>post_run(<span class="hljs-literal">NULL</span>, POST_RAM | post_bootmode_get(<span class="hljs-number">0</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Export available size of memory for Linux,</span><br><span class="hljs-comment"> * taking into account the protected RAM at top of memory</span><br><span class="hljs-comment"> */</span><br>{<br>ulong pram = <span class="hljs-number">0</span>;<br>uchar memsz[<span class="hljs-number">32</span>];<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PRAM</span><br>pram = getenv_ulong(<span class="hljs-string">"pram"</span>, <span class="hljs-number">10</span>, CONFIG_PRAM);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_LOGBUFFER</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ALT_LB_ADDR</span><br><span class="hljs-comment">/* Also take the logbuffer into account (pram is in kB) */</span><br>pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / <span class="hljs-number">1024</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)memsz, <span class="hljs-string">"%ldk"</span>, (gd-&gt;ram_size / <span class="hljs-number">1024</span>) - pram);<br>setenv(<span class="hljs-string">"mem"</span>, (<span class="hljs-type">char</span> *)memsz);<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* main_loop() can return to retry autoboot, if so just run it again. */</span><br><span class="hljs-keyword">for</span> (;;) {<br>main_loop();<br>}<br><br><span class="hljs-comment">/* NOTREACHED - no way out of command loop except booting */</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>分析这个函数，这也太麻烦了。。。。。</p><p>先看一部分，首先设置gd中的 flags 告诉其它，我已经重定位完了。然后标记当前段为<code>board_init_r</code>，然后计算flash监控区的长度 从<code>_start</code>到<code>__rel_syn_end</code>包括了代码段、只读数据段、读写数据段、<code>.u_boot_list</code>(uboot的命令)和重定位地址表段。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>ulong malloc_start;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(CONFIG_SYS_NO_FLASH)</span><br>ulong flash_size;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>gd-&gt;flags |= GD_FLG_RELOC;<span class="hljs-comment">/* tell others: relocation done */</span><br>bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, <span class="hljs-string">"board_init_r"</span>);<br><br>monitor_flash_len = (ulong)&amp;__rel_dyn_end - (ulong)_start;<br>        ...<br><span class="hljs-comment">/* NOTREACHED - no way out of command loop except booting */</span><br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="enable-caches"><a href="#enable-caches" class="headerlink" title="enable_caches"></a>enable_caches</h5><p>看下 enable_caches 函数的实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br>        enable_caches();<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>在 <code>arch/arm/lib/cache.c</code>为默认实现，其也就是打印一下cache未开启。在此处，需注意下，<code>__attribute__</code>的高级用法，声明一个弱符号函数，如果外部没有实现enable_caches，就去调用默认的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/cache.c</span><br><span class="hljs-type">void</span> __enable_caches(<span class="hljs-type">void</span>)<br>{<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"WARNING: Caches not enabled\n"</span>);<br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">enable_caches</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>__<span class="hljs-title function_">attribute__</span><span class="hljs-params">((weak, alias(<span class="hljs-string">"__enable_caches"</span>)))</span>;<br><br></code></pre></td></tr></tbody></table></figure><h5 id="negative-squared-cross-mark-board-init"><a href="#negative-squared-cross-mark-board-init" class="headerlink" title=":negative_squared_cross_mark: board_init"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> board_init</h5><p>接着我们看下board_init，网卡的初始化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br>        board_init();<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>board_init是在对应的板卡文件中实现的，实现dm9000网卡的初始化，配置板卡的类型代号以及板卡中boot的参数区，起始地址为<code>PHYS_SDRAM_1 + 0x100</code>，也即<code>0x20000100</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// board/samsung/smart210/smart210.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">board_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-comment">//smc9115_pre_init();</span><br>dm9000_pre_init();<br><br>gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDKV210;<br>gd-&gt;bd-&gt;bi_boot_params = PHYS_SDRAM_1 + <span class="hljs-number">0x100</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着看一下网卡的预初始化。呃，定义两个参数，对两个参数赋值，然后在将两个参数写入到SROM中。<strong>这个值怎么来的呢？</strong></p><p>smc_bw_conf 和 smc_bc_conf的配置可查看<code>S5PV210_UM_REV1.1.pdf</code>中<code>2.4.1.1 SROM Bus Width</code>与<code>2.4.1.2 SROM Bank Control Register</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// board/samsung/smart210/smart210.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dm9000_pre_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>u32 smc_bw_conf, smc_bc_conf;<br><br><span class="hljs-comment">/* Ethernet needs bus width of 16 bits */</span><br>smc_bw_conf = SMC_DATA16_WIDTH(CONFIG_ENV_SROM_BANK)<br>| SMC_BYTE_ADDR_MODE(CONFIG_ENV_SROM_BANK);<br>smc_bc_conf = SMC_BC_TACS(<span class="hljs-number">0</span>) | SMC_BC_TCOS(<span class="hljs-number">1</span>) | SMC_BC_TACC(<span class="hljs-number">2</span>)<br>| SMC_BC_TCOH(<span class="hljs-number">1</span>) | SMC_BC_TAH(<span class="hljs-number">0</span>) | SMC_BC_TACP(<span class="hljs-number">0</span>) | SMC_BC_PMC(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/* Select and configure the SROMC bank */</span><br>s5p_config_sromc(CONFIG_ENV_SROM_BANK, smc_bw_conf, smc_bc_conf);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这段展开也太多了，先留着，后续仔细分析<strong>TODO</strong></p><p>首先我们了解一下板卡硬件是怎么连的，由于是百兆口，只有四根线</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">网线    &lt;---&gt; RJ45(HR911105A)  &lt;---&gt; phy(DM9000A)  &lt;---&gt; 芯片(s5pv210)<br>4根线         自带变压器转换信号也还是4根线 <br>两组差分信号 两组差分信号<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204151450950.png"></p><h5 id="serial-initialize"><a href="#serial-initialize" class="headerlink" title="serial_initialize"></a>serial_initialize</h5><p>上面讲了，看 <a href="#serial_init">serial_init</a></p><h5 id="mem-malloc-init"><a href="#mem-malloc-init" class="headerlink" title="mem_malloc_init"></a>mem_malloc_init</h5><p>接着是计算malloc内存的起始地址和初始化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br>        malloc_start = dest_addr - TOTAL_MALLOC_LEN;<br>mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>计算<code>malloc_start</code>的地址，由<a href="#c_runtime_cpu_setup">c_runtime_cpu_setup</a>可知<code>gd-&gt;relocaddr</code>为<code>board_init_r</code>函数的第二个参数，也即<code>dest_addr=gd-&gt;relocaddr</code>，</p><p>而 <code>TOTAL_MALLOC_LEN</code>被定义为<code>(CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)=（CONFIG_ENV_SIZE + (1&lt;&lt;20) + CONFIG_ENV_SIZE）= 128&lt;&lt;10 * 2 + 1&lt;&lt;20=256k+1024k=1280k</code>，所以通过<code>dest_addr-TOTAL_MALLOC_LEN</code>获得可分配的最低位置。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>TOTAL_MALLOC_LEN(CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204151531408.png"></p><p>接着便是对这段范围内的内存初始化，设置malloc的开始、结束及brk的位置，并将内存内的数据清零。由于未定义<code>CONFIG_NEEDS_MANUAL_RELOC</code>宏，所以此处<code>malloc_bin_reloc</code>为空。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/dlmalloc.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_malloc_init</span><span class="hljs-params">(ulong start, ulong size)</span><br>{<br>mem_malloc_start = start;<br>mem_malloc_end = start + size;<br>mem_malloc_brk = start;<br><br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)mem_malloc_start, <span class="hljs-number">0</span>, size);<br><br>malloc_bin_reloc();<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="power-init-board"><a href="#power-init-board" class="headerlink" title="power_init_board"></a>power_init_board</h5><p>电源初始化，由于未定义<code>CONFIG_POWER</code>宏，所以此处实现为空</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">__weak <span class="hljs-type">int</span> <span class="hljs-title function_">power_init_board</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="nand-init"><a href="#nand-init" class="headerlink" title="nand_init"></a>nand_init</h5><p>此处开始初始化nand，跳转到nand_init看一下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_CMD_NAND)</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"NAND:  "</span>);<br>nand_init();<span class="hljs-comment">/* go init the NAND */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于我们没有定义<code>CONFIG_SYS_NAND_SELF_INIT</code>，CONFIG_SYS_MAX_NAND_DEVICE大小为1，所以会进入下面的循环初始化中，<code>CONFIG_SYS_NAND_SELECT_DEVICE</code>没有定义，所以此函数中进有<code>nand_init_chip(0);</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers/mtd/nand/nand.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">nand_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYS_NAND_SELF_INIT</span><br>board_nand_init();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; CONFIG_SYS_MAX_NAND_DEVICE; i++)<br>nand_init_chip(i);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lu MiB\n"</span>, total_nand_size / <span class="hljs-number">1024</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYS_NAND_SELECT_DEVICE</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Select the chip in the board/cpu specific driver</span><br><span class="hljs-comment"> */</span><br>board_nand_select_device(nand_info[nand_curr_device].priv, nand_curr_device);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br></code></pre></td></tr></tbody></table></figure><p>接着进入<code>nand_init_chip</code>，了解<code>mtd_info</code>、<code>nand_info</code>结构体，mtd指向全局变量nand_info，这个变量就是nand设备的信息；再看初始化：mtd-&gt;private=nand; mtd的私有数据就是一个指向<code>struct nand_chip</code>类型的结构体</p><blockquote><p>从编程的角度来说，一个硬件驱动应该有两个面，一个面向上层，提供接口；一个面向底层，提供硬件操作。</p><p>从广义上来看：</p><p><code>struct mtd_info</code> 就是面向上层，提供数据接口</p><p><code>struct nand_chip</code> 面向nand设备，提供硬件接口</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// drivers/mtd/nand/nand.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SYS_NAND_SELF_INIT</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">nand_init_chip</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mtd_info</span> *<span class="hljs-title">mtd</span> =</span> &amp;nand_info[i];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nand_chip</span> *<span class="hljs-title">nand</span> =</span> &amp;nand_chip[i];<br>ulong base_addr = base_address[i];<br><span class="hljs-type">int</span> maxchips = CONFIG_SYS_NAND_MAX_CHIPS;<br><br><span class="hljs-keyword">if</span> (maxchips &lt; <span class="hljs-number">1</span>)<br>maxchips = <span class="hljs-number">1</span>;<br><br>mtd-&gt;priv = nand;<br>nand-&gt;IO_ADDR_R = nand-&gt;IO_ADDR_W = (<span class="hljs-type">void</span>  __iomem *)base_addr;<br><br><span class="hljs-keyword">if</span> (board_nand_init(nand))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (nand_scan(mtd, maxchips))<br><span class="hljs-keyword">return</span>;<br><br>nand_register(i);<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></tbody></table></figure><p>基于这个思路，看一下<code>struct mtd_info</code>，记住几个</p><blockquote><p><strong>mtd_info</strong>描述原始设备层的一个分区的结构, 描述一个设备或一个多分区设备中的一个分区</p><ul><li>type MTD设备类型，有MTD_RAM、MTD_ROM、MTD_NORFLASH、MTD_NAND_FLASH等</li><li>flags 读写及权限标志位，有MTD_WRITEABLE、MTD_BIT_WRITEABLE、MTD_NO_ERASE、MTD_UP_LOCK</li><li>size MTD设备的大小</li><li>erase 主要擦除块的大小，NandFlash 就是块的大小</li><li>writesize 最小可写字节数，NandFlash 对应着”页”</li><li>oobsize 一个blokc中可用的oob的字节数</li><li>oobavail 一个block中可用oob字节数</li><li>接着下面就是一些函数指针，用于上层调用</li><li>priv 私有数据指针</li></ul></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mtd_info</span> {</span><br>u_char type;<span class="hljs-comment">/* 设备类型 */</span><br><span class="hljs-type">u_int32_t</span> flags;<br><span class="hljs-type">uint64_t</span> size; <span class="hljs-comment">/* Total size of the MTD */</span><br><br><span class="hljs-comment">/* "Major" erase size for the device. Naïve users may take this</span><br><span class="hljs-comment"> * to be the only erase size available, or may use the more detailed</span><br><span class="hljs-comment"> * information below if they desire</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u_int32_t</span> erasesize;<br><span class="hljs-comment">/* Minimal writable flash unit size. In case of NOR flash it is 1 (even</span><br><span class="hljs-comment"> * though individual bits can be cleared), in case of NAND flash it is</span><br><span class="hljs-comment"> * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR</span><br><span class="hljs-comment"> * it is of ECC block size, etc. It is illegal to have writesize = 0.</span><br><span class="hljs-comment"> * Any driver registering a struct mtd_info must ensure a writesize of</span><br><span class="hljs-comment"> * 1 or larger.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">u_int32_t</span> writesize;<br><br><span class="hljs-type">u_int32_t</span> oobsize;   <span class="hljs-comment">/* Amount of OOB data per block (e.g. 16) */</span><br><span class="hljs-type">u_int32_t</span> oobavail;  <span class="hljs-comment">/* Available OOB bytes per block */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * read ops return -EUCLEAN if max number of bitflips corrected on any</span><br><span class="hljs-comment"> * one region comprising an ecc step equals or exceeds this value.</span><br><span class="hljs-comment"> * Settable by driver, else defaults to ecc_strength.  User can override</span><br><span class="hljs-comment"> * in sysfs.  N.B. The meaning of the -EUCLEAN return code has changed;</span><br><span class="hljs-comment"> * see Documentation/ABI/testing/sysfs-class-mtd for more detail.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bitflip_threshold;<br><br><span class="hljs-comment">/* Kernel-only stuff starts here. */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">int</span> index;<br><br><span class="hljs-comment">/* ECC layout structure pointer - read only! */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nand_ecclayout</span> *<span class="hljs-title">ecclayout</span>;</span><br><br><span class="hljs-comment">/* max number of correctible bit errors per ecc step */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ecc_strength;<br><br><span class="hljs-comment">/* Data for variable erase regions. If numeraseregions is zero,</span><br><span class="hljs-comment"> * it means that the whole device has erasesize as given above.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> numeraseregions;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mtd_erase_region_info</span> *<span class="hljs-title">eraseregions</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Do not call via these pointers, use corresponding mtd_*()</span><br><span class="hljs-comment"> * wrappers instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*_erase) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-keyword">struct</span> erase_info *instr);<br><span class="hljs-type">int</span> (*_point) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> from, <span class="hljs-type">size_t</span> len,<br><span class="hljs-type">size_t</span> *retlen, <span class="hljs-type">void</span> **virt, <span class="hljs-type">phys_addr_t</span> *phys);<br><span class="hljs-type">void</span> (*_unpoint) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> from, <span class="hljs-type">size_t</span> len);<br><span class="hljs-type">int</span> (*_read) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> from, <span class="hljs-type">size_t</span> len,<br>     <span class="hljs-type">size_t</span> *retlen, u_char *buf);<br><span class="hljs-type">int</span> (*_write) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> to, <span class="hljs-type">size_t</span> len,<br>      <span class="hljs-type">size_t</span> *retlen, <span class="hljs-type">const</span> u_char *buf);<br><br><span class="hljs-comment">/* In blackbox flight recorder like scenarios we want to make successful</span><br><span class="hljs-comment">   writes in interrupt context. panic_write() is only intended to be</span><br><span class="hljs-comment">   called when its known the kernel is about to panic and we need the</span><br><span class="hljs-comment">   write to succeed. Since the kernel is not going to be running for much</span><br><span class="hljs-comment">   longer, this function can break locks and delay to ensure the write</span><br><span class="hljs-comment">   succeeds (but not sleep). */</span><br><br><span class="hljs-type">int</span> (*_panic_write) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> to, <span class="hljs-type">size_t</span> len, <span class="hljs-type">size_t</span> *retlen, <span class="hljs-type">const</span> u_char *buf);<br><br><span class="hljs-type">int</span> (*_read_oob) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> from,<br> <span class="hljs-keyword">struct</span> mtd_oob_ops *ops);<br><span class="hljs-type">int</span> (*_write_oob) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> to,<br> <span class="hljs-keyword">struct</span> mtd_oob_ops *ops);<br><span class="hljs-type">int</span> (*_get_fact_prot_info) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-keyword">struct</span> otp_info *buf,<br>   <span class="hljs-type">size_t</span> len);<br><span class="hljs-type">int</span> (*_read_fact_prot_reg) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> from,<br>   <span class="hljs-type">size_t</span> len, <span class="hljs-type">size_t</span> *retlen, u_char *buf);<br><span class="hljs-type">int</span> (*_get_user_prot_info) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-keyword">struct</span> otp_info *buf,<br>   <span class="hljs-type">size_t</span> len);<br><span class="hljs-type">int</span> (*_read_user_prot_reg) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> from,<br>   <span class="hljs-type">size_t</span> len, <span class="hljs-type">size_t</span> *retlen, u_char *buf);<br><span class="hljs-type">int</span> (*_write_user_prot_reg) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> to, <span class="hljs-type">size_t</span> len,<br>    <span class="hljs-type">size_t</span> *retlen, u_char *buf);<br><span class="hljs-type">int</span> (*_lock_user_prot_reg) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> from,<br>   <span class="hljs-type">size_t</span> len);<br><span class="hljs-type">void</span> (*_sync) (<span class="hljs-keyword">struct</span> mtd_info *mtd);<br><span class="hljs-type">int</span> (*_lock) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> ofs, <span class="hljs-type">uint64_t</span> len);<br><span class="hljs-type">int</span> (*_unlock) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> ofs, <span class="hljs-type">uint64_t</span> len);<br><span class="hljs-type">int</span> (*_block_isbad) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> ofs);<br><span class="hljs-type">int</span> (*_block_markbad) (<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">loff_t</span> ofs);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the driver is something smart, like UBI, it may need to maintain</span><br><span class="hljs-comment"> * its own reference counting. The below functions are only for driver.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*_get_device) (<span class="hljs-keyword">struct</span> mtd_info *mtd);<br><span class="hljs-type">void</span> (*_put_device) (<span class="hljs-keyword">struct</span> mtd_info *mtd);<br>    <br><span class="hljs-comment">/* ECC status information */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mtd_ecc_stats</span> <span class="hljs-title">ecc_stats</span>;</span><br><span class="hljs-comment">/* Subpage shift (NAND) */</span><br><span class="hljs-type">int</span> subpage_sft;<br><br><span class="hljs-type">void</span> *priv;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-type">int</span> usecount;<br>};<br></code></pre></td></tr></tbody></table></figure><p>结构知道了，其值在哪定义的呢，在同文件下，定义了一个结构体数组，其大小为<code>CONFIG_SYS_MAX_NAND_DEVICE</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">nand_info_t</span> nand_info[CONFIG_SYS_MAX_NAND_DEVICE];<br>----------------------------------------------------------------------------------------<br> <span class="hljs-comment">// include/configs/smart210.h</span><br> <span class="hljs-meta">#<span class="hljs-keyword">define</span> CONFIG_SYS_MAX_NAND_DEVICE  1</span><br></code></pre></td></tr></tbody></table></figure><p>接着看<code>mtd-&gt;priv = nand</code>也就是将nand的结构体指针给了mtd的私有变量，说明mtd的下层操作的设备为nand。接着往下走，<code>board_nand_init(nand)</code>初始化nand，配置nand一些参数及操作（代码可见<code>drivers/mtd/nand/s5pv210_nand.c</code>中的<code>board_nand_init</code>）。</p><p><code>nand_scan_ident</code>扫描设备，获取当前mtd中的私有变量<code>priv</code>中的数据结构（刚刚我们在<code>nand_init_chip</code>函数中赋值priv为nand，实际是全局变量，并经<code>board_nand_init</code>初始化），获取buswidth并设置、获取chip数量和大小。</p><p><code>nand_scan_tail</code>用默认值填充所有未初始化的函数指针</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">nand_scan(mtd, maxchips)<br>------------------------------------------<br><span class="hljs-comment">// drivers/mtd/nand/nand_base.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">nand_scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mtd_info *mtd, <span class="hljs-type">int</span> maxchips)</span><br>{<br><span class="hljs-type">int</span> ret;<br>ret = nand_scan_ident(mtd, maxchips, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 获取当前mtd下</span><br><span class="hljs-keyword">if</span> (!ret)<br>ret = nand_scan_tail(mtd);<br><span class="hljs-keyword">return</span> ret;<br>}<br></code></pre></td></tr></tbody></table></figure><p>还有一个注册函数，其实就是配置设备名称，形如<code>nand0</code>，然后计算总的<code>total_nand_size</code>大小，并将上面的<code>&amp;nand_info[devnum]</code>添加到<code>mtd_table</code>中，over。这个地方就结束了，其实想要更深层次的了解最好去看下<a href="#%E5%8F%82%E8%80%83">参考22</a>。</p><p>总结一下，其实就是定义了2个结构体数组，分别为<code>nand_info</code>、<code>nand_chip</code>，分别初始化，然后赋值，<code>&amp;nand_info[0]-&gt;prvi=&amp;nand_chip[0]</code>，并在<code>nand_chip</code>中实现对应的操作函数。之后呢，在将<code>&amp;nand_info[0]</code>放到<code>mtd_table</code>中，后续在使用时应该就是上层直接使用<code>mtd_table</code>来完成相应的操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">nand_register</span><span class="hljs-params">(<span class="hljs-type">int</span> devnum)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mtd_info</span> *<span class="hljs-title">mtd</span>;</span><br><br><span class="hljs-keyword">if</span> (devnum &gt;= CONFIG_SYS_MAX_NAND_DEVICE)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>mtd = &amp;nand_info[devnum];<br><br><span class="hljs-built_in">sprintf</span>(dev_name[devnum], <span class="hljs-string">"nand%d"</span>, devnum);<br>mtd-&gt;name = dev_name[devnum];<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MTD_DEVICE</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Add MTD device so that we can reference it later</span><br><span class="hljs-comment"> * via the mtdcore infrastructure (e.g. ubi).</span><br><span class="hljs-comment"> */</span><br>add_mtd_device(mtd);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>total_nand_size += mtd-&gt;size / <span class="hljs-number">1024</span>;<br><br><span class="hljs-keyword">if</span> (nand_curr_device == <span class="hljs-number">-1</span>)<br>nand_curr_device = devnum;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="should-load-env"><a href="#should-load-env" class="headerlink" title="should_load_env"></a>should_load_env</h5><p>发现 <code>CONFIG_OF_CONTROL</code>、<code>CONFIG_DELAY_ENVIRONMENT</code>均没有定义，返回1。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br><span class="hljs-comment">/* initialize environment */</span><br><span class="hljs-keyword">if</span> (should_load_env())<br>env_relocate();<br><span class="hljs-keyword">else</span><br>set_default_env(<span class="hljs-literal">NULL</span>);<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>也就是<code>env_relocate()</code>，由于<code>CONFIG_NEEDS_MANUAL_RELOC</code>、<code>CONFIG_ENV_IS_NOWHERE</code>没有定义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">env_relocate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-keyword">if</span> (gd-&gt;env_valid == <span class="hljs-number">0</span>) {<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)</span><br><span class="hljs-comment">/* Environment not changable */</span><br>set_default_env(<span class="hljs-literal">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);<br>set_default_env(<span class="hljs-string">"!bad CRC"</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>} <span class="hljs-keyword">else</span> {<br>env_relocate_spec();<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>所以代码可精简为如下, 由于在<a href="#env_init">env_init</a>中配置为1，所以此处走<code>else</code>分支。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">env_relocate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-keyword">if</span> (gd-&gt;env_valid == <span class="hljs-number">0</span>) {<br>bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);<br>set_default_env(<span class="hljs-string">"!bad CRC"</span>);<br>} <span class="hljs-keyword">else</span> {<br>env_relocate_spec();<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p> 由于上述我们使用的为nand，所以此处env_relocate_spec位置在<code>common/env_nand.c</code>中，先看下这个又臭又长的宏定义。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/env_nand.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">env_relocate_spec</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-type">int</span> ret;<br>ALLOC_CACHE_ALIGN_BUFFER(<span class="hljs-type">char</span>, buf, CONFIG_ENV_SIZE);<br>ret = readenv(CONFIG_ENV_OFFSET, (u_char *)buf);<br><span class="hljs-keyword">if</span> (ret) {<br>set_default_env(<span class="hljs-string">"!readenv() failed"</span>);<br><span class="hljs-keyword">return</span>;<br>}<br>env_import(buf, <span class="hljs-number">1</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>看下下面的分析，其实也就是定义了一个数组，然后返回一个数组指针，只不过其中保证了内存对齐，</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/env_nand.c</span><br>ALLOC_CACHE_ALIGN_BUFFER(<span class="hljs-type">char</span>, buf, CONFIG_ENV_SIZE);<br><span class="hljs-comment">//-------------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// include/common.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOC_CACHE_ALIGN_BUFFER(type, name, size)ALLOC_ALIGN_BUFFER(type, name, size, ARCH_DMA_MINALIGN)</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOC_ALIGN_BUFFER(type, name, size, align)       ALLOC_ALIGN_BUFFER_PAD(type, name, size, align, 1)</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOC_ALIGN_BUFFER_PAD(type, name, size, align, pad)\</span><br><span class="hljs-meta">char __##name[ROUND(PAD_SIZE((size) * sizeof(type), pad), align)  \</span><br><span class="hljs-meta">      + (align - 1)];\</span><br><span class="hljs-meta">\</span><br><span class="hljs-meta">type *name = (type *) ALIGN((uintptr_t)__##name, align)</span><br><span class="hljs-comment">//---------------------------------------------------------------------------------------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOC_CACHE_ALIGN_BUFFER(type, name, size)  \</span><br><span class="hljs-meta">char __##name[ROUND(PAD_SIZE((size) * sizeof(type), 1), ARCH_DMA_MINALIGN)  \</span><br><span class="hljs-meta">      + (ARCH_DMA_MINALIGN - 1)];\</span><br><span class="hljs-meta">type *name = (type *) ALIGN((uintptr_t)__##name, ARCH_DMA_MINALIGN)</span><br><span class="hljs-comment">//------------------------------------------------------------------------------------------------</span><br>ALLOC_CACHE_ALIGN_BUFFER(<span class="hljs-type">char</span>, buf, CONFIG_ENV_SIZE);<br><span class="hljs-type">char</span> __buf[CONFIG_ENV_SIZE];<br><span class="hljs-type">char</span> *buf = (<span class="hljs-type">char</span> *)ALIGN((<span class="hljs-type">uintptr_t</span>)__buf,ARCH_DMA_MINALIGN);<br></code></pre></td></tr></tbody></table></figure><p>接着看readenv函数，在实际中打印</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">readenv<br>end of readenv,amount_loaded=131072 CONFIG_ENV_SIZE:131072<br></code></pre></td></tr></tbody></table></figure><p><code>nand_info[0].erasesize</code>又是在哪赋值的呢？</p><p>在<code>nand_init_chip</code>中，没有与<code>mtd-&gt;erasesize</code>相关的，而<code>board_nand_init</code>仅与<code>nand_chip</code>有关，<code>nand_register</code>中也没有与之有关的。</p><p>所以一路找下去，最终是在<code>nand_get_flash_type</code>中的<code>nand_decode_id</code>（或者<code>nand_decode_ext_id</code>）获取类型中给<code>mtd-&gt;erasesize</code>赋值的，具体值的大小与nand的厂商有关。 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">--&gt; nand_init<br>          |<br> --&gt; nand_init_chip<br> |<br> --&gt; nand_scan<br> |<br> --&gt; nand_scan_ident<br> |<br> --&gt; nand_get_flash_type<br> |<br> --&gt; nand_decode_ext_id<br>        --&gt; nand_decode_id<br></code></pre></td></tr></tbody></table></figure><p>从<code>blocksize</code>或者<code>CONFIG_ENV_SIZE</code>中获取最小值，接着一个循环 条件呢？就是总共加载的大小与配置的环境大小相比且当前的偏移小于配置的环境的大小。</p><p>先判断当前块是否是坏的，如果是，则跳过，<code>offset += blocksize</code></p><p>否则，在里面接着以跳过坏块的方式读，并将读取的环境变量写入<code>buf</code>中，二者相等返回0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">readenv</span><span class="hljs-params">(<span class="hljs-type">size_t</span> offset, u_char *buf)</span><br>{<br><span class="hljs-type">size_t</span> end = offset + CONFIG_ENV_RANGE;<br><span class="hljs-type">size_t</span> amount_loaded = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> blocksize, len;<br>u_char *char_ptr;<br><br>debug(<span class="hljs-string">"readenv\r\n"</span>);<br>blocksize = nand_info[<span class="hljs-number">0</span>].erasesize;<br><span class="hljs-keyword">if</span> (!blocksize)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>len = min(blocksize, CONFIG_ENV_SIZE);<br><br><span class="hljs-keyword">while</span> (amount_loaded &lt; CONFIG_ENV_SIZE &amp;&amp; offset &lt; end) {<br><span class="hljs-keyword">if</span> (nand_block_isbad(&amp;nand_info[<span class="hljs-number">0</span>], offset)) {<br>offset += blocksize;<br>} <span class="hljs-keyword">else</span> {<br>char_ptr = &amp;buf[amount_loaded];<br><span class="hljs-keyword">if</span> (nand_read_skip_bad(&amp;nand_info[<span class="hljs-number">0</span>], offset,<br>       &amp;len, <span class="hljs-literal">NULL</span>,<br>       nand_info[<span class="hljs-number">0</span>].size, char_ptr))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>offset += blocksize;<br>amount_loaded += len;<br>}<br>}<br>debug(<span class="hljs-string">"end of readenv,amount_loaded=%d CONFIG_ENV_SIZE:%d\r\n"</span>,amount_loaded,CONFIG_ENV_SIZE);<br><span class="hljs-keyword">if</span> (amount_loaded != CONFIG_ENV_SIZE)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>返回到<code>env_relocate_spec</code>中，执行<code>env_import(buf,1)</code>这个函数是个难点，也是个重点，涉及到对哈希表的操作。</p><p>这个函数有两个操作，一个是crc校验；另一个是创建哈希表，并将环境变量中的数据提取出来插入表中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">env_import</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> check)</span><br>{<br><span class="hljs-type">env_t</span> *ep = (<span class="hljs-type">env_t</span> *)buf;<br>debug(<span class="hljs-string">"env_import\r\n"</span>);<br><span class="hljs-keyword">if</span> (check) {<br><span class="hljs-type">uint32_t</span> crc;<br><span class="hljs-built_in">memcpy</span>(&amp;crc, &amp;ep-&gt;crc, <span class="hljs-keyword">sizeof</span>(crc));<br><span class="hljs-keyword">if</span> (crc32(<span class="hljs-number">0</span>, ep-&gt;data, ENV_SIZE) != crc) {<br>debug(<span class="hljs-string">"env_import --&gt; crc32\r\n"</span>);<br>set_default_env(<span class="hljs-string">"!bad CRC"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br>}<br><span class="hljs-keyword">if</span> (himport_r(&amp;env_htab, (<span class="hljs-type">char</span> *)ep-&gt;data, ENV_SIZE, <span class="hljs-string">'\0'</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)) {<br>debug(<span class="hljs-string">"env_import --&gt; himport_r\r\n"</span>);<br>gd-&gt;flags |= GD_FLG_ENV_READY;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br>error(<span class="hljs-string">"Cannot import environment: errno = %d\n"</span>, errno);<br>set_default_env(<span class="hljs-string">"!import failed"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>主要是分析下创建哈希表和哈希表的插入操作。<strong>TODO：明天挑一段长的时间分析吧！</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/env_common.c</span><br>himport_r(&amp;env_htab, (<span class="hljs-type">char</span> *)ep-&gt;data, ENV_SIZE, <span class="hljs-string">'\0'</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>) <br><span class="hljs-comment">// lib/hashtable.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">himport_r</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> hsearch_data *htab,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *env, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-type">char</span> sep, <span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> nvars, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> vars[])</span><br>{<br><span class="hljs-type">char</span> *data, *sp, *dp, *name, *value;<br><span class="hljs-type">char</span> *localvars[nvars];<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-comment">/* Test for correct arguments.  */</span><br><span class="hljs-keyword">if</span> (htab == <span class="hljs-literal">NULL</span>) {<br>__set_errno(EINVAL);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">/* we allocate new space to make sure we can write to the array */</span><br><span class="hljs-keyword">if</span> ((data = <span class="hljs-built_in">malloc</span>(size)) == <span class="hljs-literal">NULL</span>) {<br>debug(<span class="hljs-string">"himport_r: can't malloc %zu bytes\n"</span>, size);<br>__set_errno(ENOMEM);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-built_in">memcpy</span>(data, env, size);<br>dp = data;<br><br><span class="hljs-comment">/* make a local copy of the list of variables */</span><br><span class="hljs-keyword">if</span> (nvars)<br><span class="hljs-built_in">memcpy</span>(localvars, vars, <span class="hljs-keyword">sizeof</span>(vars[<span class="hljs-number">0</span>]) * nvars);<br><br><span class="hljs-keyword">if</span> ((flag &amp; H_NOCLEAR) == <span class="hljs-number">0</span>) {<br><span class="hljs-comment">/* Destroy old hash table if one exists */</span><br>debug(<span class="hljs-string">"Destroy Hash Table: %p table = %p\n"</span>, htab, htab-&gt;table);<br><span class="hljs-keyword">if</span> (htab-&gt;table) hdestroy_r(htab);<br>}<br><br><span class="hljs-keyword">if</span> (!htab-&gt;table) {<br><span class="hljs-type">int</span> nent = CONFIG_ENV_MIN_ENTRIES + size / <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (nent &gt; CONFIG_ENV_MAX_ENTRIES) nent = CONFIG_ENV_MAX_ENTRIES;<br>debug(<span class="hljs-string">"Create Hash Table: N=%d\n"</span>, nent);<br><span class="hljs-keyword">if</span> (hcreate_r(nent, htab) == <span class="hljs-number">0</span>) {<br><span class="hljs-built_in">free</span>(data);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br>}<br><br><span class="hljs-comment">/* Parse environment; allow for '\0' and 'sep' as separators */</span><br><span class="hljs-keyword">do</span> {<br>ENTRY e, *rv;<br><span class="hljs-comment">/* skip leading white space */</span><br><span class="hljs-keyword">while</span> (isblank(*dp))<br>++dp;<br><span class="hljs-comment">/* skip comment lines */</span><br><span class="hljs-keyword">if</span> (*dp == <span class="hljs-string">'#'</span>) {<br><span class="hljs-keyword">while</span> (*dp &amp;&amp; (*dp != sep))<br>++dp;<br>++dp;<br><span class="hljs-keyword">continue</span>;<br>}<br><br><span class="hljs-comment">/* parse name */</span><br><span class="hljs-keyword">for</span> (name = dp; *dp != <span class="hljs-string">'='</span> &amp;&amp; *dp &amp;&amp; *dp != sep; ++dp)<br>;<br><br><span class="hljs-comment">/* deal with "name" and "name=" entries (delete var) */</span><br><span class="hljs-keyword">if</span> (*dp == <span class="hljs-string">'\0'</span> || *(dp + <span class="hljs-number">1</span>) == <span class="hljs-string">'\0'</span> ||<br>    *dp == sep || *(dp + <span class="hljs-number">1</span>) == sep) {<br><span class="hljs-keyword">if</span> (*dp == <span class="hljs-string">'='</span>)<br>*dp++ = <span class="hljs-string">'\0'</span>;<br>*dp++ = <span class="hljs-string">'\0'</span>;<span class="hljs-comment">/* terminate name */</span><br><br>debug(<span class="hljs-string">"DELETE CANDIDATE: \"%s\"\n"</span>, name);<br><span class="hljs-keyword">if</span> (!drop_var_from_set(name, nvars, localvars))<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (hdelete_r(name, htab, flag) == <span class="hljs-number">0</span>)<br>debug(<span class="hljs-string">"DELETE ERROR ##############################\n"</span>);<br><br><span class="hljs-keyword">continue</span>;<br>}<br>*dp++ = <span class="hljs-string">'\0'</span>;<span class="hljs-comment">/* terminate name */</span><br><br><span class="hljs-comment">/* parse value; deal with escapes */</span><br><span class="hljs-keyword">for</span> (value = sp = dp; *dp &amp;&amp; (*dp != sep); ++dp) {<br><span class="hljs-keyword">if</span> ((*dp == <span class="hljs-string">'\\'</span>) &amp;&amp; *(dp + <span class="hljs-number">1</span>))<br>++dp;<br>*sp++ = *dp;<br>}<br>*sp++ = <span class="hljs-string">'\0'</span>;<span class="hljs-comment">/* terminate value */</span><br>++dp;<br><br><span class="hljs-keyword">if</span> (*name == <span class="hljs-number">0</span>) {<br>debug(<span class="hljs-string">"INSERT: unable to use an empty key\n"</span>);<br>__set_errno(EINVAL);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">/* Skip variables which are not supposed to be processed */</span><br><span class="hljs-keyword">if</span> (!drop_var_from_set(name, nvars, localvars))<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/* enter into hash table */</span><br>e.key = name;<br>e.data = value;<br><br>hsearch_r(e, ENTER, &amp;rv, htab, flag);<br><span class="hljs-keyword">if</span> (rv == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"himport_r: can't insert \"%s=%s\" into hash table\n"</span>,name, value);<br>debug(<span class="hljs-string">"INSERT: table %p, filled %d/%d rv %p ==&gt; name=\"%s\" value=\"%s\"\n"</span>,htab, htab-&gt;filled, htab-&gt;size,rv, name, value);<br>} <span class="hljs-keyword">while</span> ((dp &lt; data + size) &amp;&amp; *dp);<span class="hljs-comment">/* size check needed for text */</span><br><span class="hljs-comment">/* without '\0' termination */</span><br>debug(<span class="hljs-string">"INSERT: free(data = %p)\n"</span>, data);<br><span class="hljs-built_in">free</span>(data);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nvars; i++) {<br><span class="hljs-keyword">if</span> (localvars[i] == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (hdelete_r(localvars[i], htab, flag) == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"WARNING: '%s' neither in running nor in imported env!\n"</span>, localvars[i]);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"WARNING: '%s' not in imported env, deleting it!\n"</span>, localvars[i]);<br>}<br><br>debug(<span class="hljs-string">"INSERT: done\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">/* everything OK */</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>先把打印的日志摆这，对着分析还容易点。。。。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">Destroy Hash Table: 3ffb4f0c table = 00000000<br>Create Hash Table: N=512<br>INSERT: table 3ffb4f0c, filled 1/521 rv 3fe62868 ==&gt; name="baudrate" value="115200"<br>INSERT: table 3ffb4f0c, filled 2/521 rv 3fe643fc ==&gt; name="bootargs" value="root=/dev/nfs rw nfsroot=10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs ip=10.0.0.98:10.0.0.97:10.0.0.1:255.0.0.0::eth0:off init=/linuxrc console=ttySAC0，115200"<br>INSERT: table 3ffb4f0c, filled 3/521 rv 3fe62c8c ==&gt; name="bootcmd" value="nfs 20000000 10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs/uImage;nfs 21000000 10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs/s5pv210-smart210.dtb;bootm 20000000 - 21000000"<br>INSERT: table 3ffb4f0c, filled 4/521 rv 3fe634e8 ==&gt; name="bootdelay" value="1"<br>INSERT: table 3ffb4f0c, filled 5/521 rv 3fe62bb0 ==&gt; name="ethact" value="dm9000"<br>INSERT: table 3ffb4f0c, filled 6/521 rv 3fe625fc ==&gt; name="ethaddr" value="1a:2a:3a:4a:5a:6a"<br>INSERT: table 3ffb4f0c, filled 7/521 rv 3fe64320 ==&gt; name="ipaddr" value="10.0.0.98"<br>INSERT: table 3ffb4f0c, filled 8/521 rv 3fe6232c ==&gt; name="machid" value="0xffffffff"<br>INSERT: table 3ffb4f0c, filled 9/521 rv 3fe63e48 ==&gt; name="qqqqq" value="1111"<br>INSERT: table 3ffb4f0c, filled 10/521 rv 3fe62a84 ==&gt; name="serverip" value="10.0.0.20"<br>INSERT: table 3ffb4f0c, filled 11/521 rv 3fe62fac ==&gt; name="stderr" value="serial"<br>INSERT: table 3ffb4f0c, filled 12/521 rv 3fe627c8 ==&gt; name="stdin" value="serial"<br>INSERT: table 3ffb4f0c, filled 13/521 rv 3fe638f8 ==&gt; name="stdout" value="serial"<br>INSERT: free(data = 3fe41bd0)<br>INSERT: done<br></code></pre></td></tr></tbody></table></figure><h5 id="negative-squared-cross-mark-stdio-init"><a href="#negative-squared-cross-mark-stdio-init" class="headerlink" title=":negative_squared_cross_mark: stdio_init"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> stdio_init</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br>stdio_init();<span class="hljs-comment">/* get the devices list going. */</span><br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为一些宏在smart210.h中未定义，所以 此处留下会执行的代码。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/stdio.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stdio_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-comment">/* Initialize the list */</span><br>INIT_LIST_HEAD(&amp;(devs.<span class="hljs-built_in">list</span>));<br>drv_system_init ();<br>serial_stdio_init ();<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>首先初始化列表，双向列表的头初始化时 其下一个和前一个节点均指向自身。此处尽管<code>INIT_LIST_HEAD</code>为static函数，但是其在common.h实现，在c中展开相当于仅在当前c中使用。再看下<code>devs.list</code>是什么东西？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">INIT_LIST_HEAD</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>)</span><br>{<br><span class="hljs-built_in">list</span>-&gt;next = <span class="hljs-built_in">list</span>;<br><span class="hljs-built_in">list</span>-&gt;prev = <span class="hljs-built_in">list</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>此处又引出一个结构体<code>stdio_dev</code>，其中包括标志位、支持的扩展、设备名称、设备操作函数、私有扩展和一个双向列表。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/stdio.c</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stdio_dev</span> <span class="hljs-title">devs</span>;</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/stdio_dev.h</span><br><span class="hljs-comment">/* Device information */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stdio_dev</span> {</span><br><span class="hljs-type">int</span>flags; <span class="hljs-comment">/* Device flags: input/output/system*/</span><br><span class="hljs-type">int</span>ext;<span class="hljs-comment">/* Supported extensions*/</span><br>        <span class="hljs-type">char</span>name[<span class="hljs-number">16</span>];<span class="hljs-comment">/* Device name*/</span><br><br><span class="hljs-comment">/* GENERAL functions */</span><br><span class="hljs-type">int</span> (*start) (<span class="hljs-type">void</span>); <span class="hljs-comment">/* To start the device*/</span><br><span class="hljs-type">int</span> (*stop) (<span class="hljs-type">void</span>);       <span class="hljs-comment">/* To stop the device*/</span><br><br><span class="hljs-comment">/* OUTPUT functions */</span><br><span class="hljs-type">void</span> (*putc) (<span class="hljs-type">const</span> <span class="hljs-type">char</span> c);<span class="hljs-comment">/* To put a char*/</span><br><span class="hljs-type">void</span> (*<span class="hljs-built_in">puts</span>) (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s);<span class="hljs-comment">/* To put a string (accelerator)*/</span><br><br><span class="hljs-comment">/* INPUT functions */</span><br><span class="hljs-type">int</span> (*tstc) (<span class="hljs-type">void</span>);<span class="hljs-comment">/* To test if a char is ready...*/</span><br><span class="hljs-type">int</span> (*getc) (<span class="hljs-type">void</span>);<span class="hljs-comment">/* To get that char*/</span><br><br><span class="hljs-comment">/* Other functions */</span><br><span class="hljs-type">void</span> *priv;<span class="hljs-comment">/* Private extensions*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>接着看下<strong>drv_system_init</strong>，其中定义了<code>struct stdio_dev dev</code>，然后初始化。最后注册这个结构。直接看下是如何注册的？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/stdio.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">drv_system_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stdio_dev</span> <span class="hljs-title">dev</span>;</span><br><span class="hljs-built_in">memset</span> (&amp;dev, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (dev));<br><span class="hljs-built_in">strcpy</span> (dev.name, <span class="hljs-string">"serial"</span>);<br>dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;<br>dev.putc = serial_putc;<br>dev.<span class="hljs-built_in">puts</span> = serial_puts;<br>dev.getc = serial_getc;<br>dev.tstc = serial_tstc;<br>stdio_register (&amp;dev);<br>}<br></code></pre></td></tr></tbody></table></figure><p>在注册函数中，首先克隆一个当前的结构（先分配空间，在拷贝数据），然后把克隆出的结构体在挂到<code>devs.list</code>上（<code>TODO：此处待理解双向列表添加后在分析</code>）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/stdio.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stdio_register</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> stdio_dev * dev)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stdio_dev</span> *_<span class="hljs-title">dev</span>;</span><br><br>_dev = stdio_clone(dev);<br><span class="hljs-keyword">if</span>(!_dev)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>list_add_tail(&amp;(_dev-&gt;<span class="hljs-built_in">list</span>), &amp;(devs.<span class="hljs-built_in">list</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>再看下 <code>serial_stdio_init</code>，<code>serial_devices</code>不知各位看官姥爷还有没有印象，反正笔者是没有印象了。。。。好了，话说回来，在<a href="#serial_init">serial_init</a>中我们分析了串口的初始化，其节点都挂到 <code>serial_devices</code>列表中，<code>serial_current</code>中保存着当前串口的指针。</p><p>这段代码的意思是 遍历<code>serial_devices</code>中的所有节点，将其添加到<code>devs</code>中去。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">serial_stdio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stdio_dev</span> <span class="hljs-title">dev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">serial_device</span> *<span class="hljs-title">s</span> =</span> serial_devices;<br><span class="hljs-keyword">while</span> (s) {<br><span class="hljs-built_in">memset</span>(&amp;dev, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dev));<br><span class="hljs-built_in">strcpy</span>(dev.name, s-&gt;name);<br>dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;<br>dev.start = s-&gt;start;<br>dev.stop = s-&gt;stop;<br>dev.putc = s-&gt;putc;<br>dev.<span class="hljs-built_in">puts</span> = s-&gt;<span class="hljs-built_in">puts</span>;<br>dev.getc = s-&gt;getc;<br>dev.tstc = s-&gt;tstc;<br>stdio_register(&amp;dev);<br>s = s-&gt;next;<span class="hljs-comment">// 移到下一个节点</span><br>}<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="jumptable-init"><a href="#jumptable-init" class="headerlink" title="jumptable_init"></a>jumptable_init</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br>jumptable_init();<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>在<code>common/exports.c</code>中实现</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/exports.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">jumptable_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>gd-&gt;jt = <span class="hljs-built_in">malloc</span>(XF_MAX * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *));<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;_exports.h&gt;</span></span><br>}<br></code></pre></td></tr></tbody></table></figure><p>手动模拟编译器展开（滑稽）看一下，此处只需要记住，宏直接展开。注意下在<code>exports.c</code>中包含<code>exports.h</code>，而<code>exports.h</code>定义了一个enum，那个enum展开后对应的恰是<code>_exports.h</code>中的所有函数的索引（<code>0</code>开始，<code>XF_MAX</code>结束，所以前面分配内存时可直接<code>XF_MAX</code>）。所以在<code>exports.c</code>就可以直接使用索引访问数组并给每个数组变量赋值。至于这些个函数就不一一分析了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/exports.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXPORT_FUNC(sym) gd-&gt;jt[XF_##sym] = (void *)sym;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">jumptable_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>gd-&gt;jt = <span class="hljs-built_in">malloc</span>(XF_MAX * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *));<br>        EXPORT_FUNC(get_version)<br>        EXPORT_FUNC(getc)<br>        EXPORT_FUNC(tstc)<br>        EXPORT_FUNC(putc)<br>        EXPORT_FUNC(<span class="hljs-built_in">puts</span>)<br>        EXPORT_FUNC(<span class="hljs-built_in">printf</span>)<br>        EXPORT_FUNC(install_hdlr)<br>        EXPORT_FUNC(free_hdlr)<br>        ...<br>        EXPORT_FUNC(spi_xfer)<br>}<br><span class="hljs-comment">//--------------------------------------------------------------------------------------</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">jumptable_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>gd-&gt;jt = <span class="hljs-built_in">malloc</span>(XF_MAX * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *));<br>         gd-&gt;jt[XF_getc] = (<span class="hljs-type">void</span> *)get_c;<br>gd-&gt;jt[XF_get_version] = (<span class="hljs-type">void</span> *)get_version;<br>gd-&gt;jt[XF_tstc] = (<span class="hljs-type">void</span> *)tstc;<br>gd-&gt;jt[XF_putc] = (<span class="hljs-type">void</span> *)putc;<br>gd-&gt;jt[XF_puts] = (<span class="hljs-type">void</span> *)<span class="hljs-built_in">puts</span>;<br>gd-&gt;jt[XF_printf] = (<span class="hljs-type">void</span> *)<span class="hljs-built_in">printf</span>;<br>gd-&gt;jt[XF_install_hdlr] = (<span class="hljs-type">void</span> *)install_hdlr;<br>gd-&gt;jt[XF_free_hdlr] = (<span class="hljs-type">void</span> *)free_hdlr;<br>...<br>         gd-&gt;jt[XF_spi_xfer] = (<span class="hljs-type">void</span> *)spi_xfer;<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于头文件一般都在函数之前，所以此处定义<code>EXPORT_FUNC(x)</code>不会出错，待使用结束后<code>undef</code>，所以后面使用时也没有问题。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> {</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXPORT_FUNC(x) XF_ ## x ,</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;_exports.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> EXPORT_FUNC</span><br><br>XF_MAX<br>};<br></code></pre></td></tr></tbody></table></figure><h5 id="console-init-r"><a href="#console-init-r" class="headerlink" title="console_init_r"></a>console_init_r</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br>console_init_r();<span class="hljs-comment">/* fully init console as a device */</span><br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>看下<code>CONFIG_SYS_CONSOLE_IS_IN_ENV</code>宏是否定义，没有定义，那么代码就是下面这一段。</p><p><code>list_for_each(pos, list)</code>是一个迭代器，好吧，也就是一个<code>for</code>循环，但是注意里面有一个<code>prefetch</code>，此处需分析一下。<code>TODO：待分析</code></p><p>然后<code>list_entry</code>也需要分析一下。<code>TODO：待分析</code></p><p>这个循环的目的，根据标志位判断输入输出节点，并将其赋值给<code>inputdev</code>、<code>outputdev</code>，如果这两者都有的话，结束这个循环。</p><p>一个<code>console_setfile</code>将dev设置到<code>stdio_devices[i]</code>，同时也设给<code>console_devices[i][0]</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/console.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">console_init_r</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stdio_dev</span> *<span class="hljs-title">inputdev</span> =</span> <span class="hljs-literal">NULL</span>, *outputdev = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> i;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">list</span> =</span> stdio_get_list();<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">pos</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stdio_dev</span> *<span class="hljs-title">dev</span>;</span><br><br><span class="hljs-comment">/* Scan devices looking for input and output devices */</span><br>list_for_each(pos, <span class="hljs-built_in">list</span>) {<br>dev = list_entry(pos, <span class="hljs-keyword">struct</span> stdio_dev, <span class="hljs-built_in">list</span>);<br><br><span class="hljs-keyword">if</span> ((dev-&gt;flags &amp; DEV_FLAGS_INPUT) &amp;&amp; (inputdev == <span class="hljs-literal">NULL</span>)) {<br>inputdev = dev;<br>}<br><span class="hljs-keyword">if</span> ((dev-&gt;flags &amp; DEV_FLAGS_OUTPUT) &amp;&amp; (outputdev == <span class="hljs-literal">NULL</span>)) {<br>outputdev = dev;<br>}<br><span class="hljs-keyword">if</span>(inputdev &amp;&amp; outputdev)<br><span class="hljs-keyword">break</span>;<br>}<br><br><span class="hljs-comment">/* Initializes output console first */</span><br><span class="hljs-keyword">if</span> (outputdev != <span class="hljs-literal">NULL</span>) {<br>console_setfile(<span class="hljs-built_in">stdout</span>, outputdev);<br>console_setfile(<span class="hljs-built_in">stderr</span>, outputdev);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CONSOLE_MUX</span><br>console_devices[<span class="hljs-built_in">stdout</span>][<span class="hljs-number">0</span>] = outputdev;<br>console_devices[<span class="hljs-built_in">stderr</span>][<span class="hljs-number">0</span>] = outputdev;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br><br><span class="hljs-comment">/* Initializes input console */</span><br><span class="hljs-keyword">if</span> (inputdev != <span class="hljs-literal">NULL</span>) {<br>console_setfile(<span class="hljs-built_in">stdin</span>, inputdev);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CONSOLE_MUX</span><br>console_devices[<span class="hljs-built_in">stdin</span>][<span class="hljs-number">0</span>] = inputdev;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SYS_CONSOLE_INFO_QUIET</span><br>stdio_print_current_devices();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_SYS_CONSOLE_INFO_QUIET */</span></span><br><br><span class="hljs-comment">/* Setting environment variables */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br>setenv(stdio_names[i], stdio_devices[i]-&gt;name);<br>}<br><br>gd-&gt;flags |= GD_FLG_DEVINIT;<span class="hljs-comment">/* device initialization completed */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后调用<code>stdio_print_current_devices</code>打印，debug输出如下。并设置环境变量<code>stderr</code>、<code>stdin</code>、<code>stdout</code>为<code>serial</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">In:    serial<br>Out:   serial<br>Err:   serial<br></code></pre></td></tr></tbody></table></figure><p>最后一个设置标志位<code>GD_FLG_DEVINIT</code>表示dev初始化完成。</p><h5 id="checkboard-1"><a href="#checkboard-1" class="headerlink" title="checkboard"></a>checkboard</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br> checkboard();<span class="hljs-comment">/* fully init console as a device */</span><br>        ...<br>}<br><span class="hljs-comment">// board/samsung/smart210/smart210.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">checkboard</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Board:\tSMART210\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="negative-squared-cross-mark-interrupt-init"><a href="#negative-squared-cross-mark-interrupt-init" class="headerlink" title=":negative_squared_cross_mark: interrupt_init"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> interrupt_init</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br><span class="hljs-comment">/* set up exceptions */</span><br>interrupt_init();<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>没有定义宏<code>CONFIG_USE_IRQ</code>，走这个分支，这个代码也只是设置<code>IRQ_STACK_START_IN</code>中断栈起始地址为<code>gd-&gt;irq_sp + 8</code>？不应该是<code>-8</code>吗？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/interrupts.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">interrupt_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>IRQ_STACK_START_IN = gd-&gt;irq_sp + <span class="hljs-number">8</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204151531408.png"></p><h5 id="enable-interrupts"><a href="#enable-interrupts" class="headerlink" title="enable_interrupts"></a>enable_interrupts</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br><span class="hljs-comment">/* enable exceptions */</span><br>enable_interrupts();<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>空实现</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/interrupts.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">enable_interrupts</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="eth-initialize"><a href="#eth-initialize" class="headerlink" title="eth_initialize"></a>eth_initialize</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>...<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Net:   "</span>);<br>eth_initialize(gd-&gt;bd);<br>        ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>类似串口，这个地方又有个数据结构<code>struct eth_device</code>，定义了网络设备的基本操作。其中从面向对象的角度来说，在驱动层面只需要把对应的init、send、recv、halt、weite_hwaddr这几种方法实现，就可以正常收发数据了，至于数据收回来要怎么办，那是上层决定的，我们并不需要关心。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/net.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eth_device</span> {</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> enetaddr[<span class="hljs-number">6</span>];<br><span class="hljs-type">int</span> iobase;<br><span class="hljs-type">int</span> state;<br><br><span class="hljs-type">int</span>  (*init) (<span class="hljs-keyword">struct</span> eth_device *, <span class="hljs-type">bd_t</span> *);<br><span class="hljs-type">int</span>  (*send) (<span class="hljs-keyword">struct</span> eth_device *, <span class="hljs-type">void</span> *packet, <span class="hljs-type">int</span> length);<br><span class="hljs-type">int</span>  (*recv) (<span class="hljs-keyword">struct</span> eth_device *);<br><span class="hljs-type">void</span> (*halt) (<span class="hljs-keyword">struct</span> eth_device *);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MCAST_TFTP</span><br><span class="hljs-type">int</span> (*mcast) (<span class="hljs-keyword">struct</span> eth_device *, <span class="hljs-type">const</span> u8 *enetaddr, u8 <span class="hljs-built_in">set</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">int</span>  (*write_hwaddr) (<span class="hljs-keyword">struct</span> eth_device *);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eth_device</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">int</span> index;<br><span class="hljs-type">void</span> *priv;<br>};<br></code></pre></td></tr></tbody></table></figure><p>接着看<code>eth_initialize</code>函数，上来首先将<code>eth_devices</code>（网卡设备链表）、<code>eth_current</code>（当前网卡设备）置空，然后标记当前阶段为<code>BOOTSTAGE_ID_NET_ETH_START</code>，从环境变量查找<code>"bootfile"</code>，如果有，则拷贝至<code>BootFile</code>中。</p><p>接着往下走，实际上是一个初始化函数，只不过分了几种情况，如果<code>board-specific</code>存在的话，就调用它；如果没有，调用<code>CPU-specific</code>那个。</p><p>本文中走的是第一个分支，调用的<code>board_eth_init(bis)</code> 为<code>board/samsung/smart210/smart210.c</code>中的，我们分析一下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// net/eth.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eth_initialize</span><span class="hljs-params">(<span class="hljs-type">bd_t</span> *bis)</span><br>{<br><span class="hljs-type">int</span> num_devices = <span class="hljs-number">0</span>;<br>eth_devices = <span class="hljs-literal">NULL</span>;<br>eth_current = <span class="hljs-literal">NULL</span>;<br><br>bootstage_mark(BOOTSTAGE_ID_NET_ETH_START);<br><br>eth_env_init(bis);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If board-specific initialization exists, call it.</span><br><span class="hljs-comment"> * If not, call a CPU-specific one</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (board_eth_init != __def_eth_init) {<br><span class="hljs-keyword">if</span> (board_eth_init(bis) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Board Net Initialization Failed\n"</span>);<br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cpu_eth_init != __def_eth_init) {<br><span class="hljs-keyword">if</span> (cpu_eth_init(bis) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"CPU Net Initialization Failed\n"</span>);<br>} <span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Net Initialization Skipped\n"</span>);<br>...<br>}<br></code></pre></td></tr></tbody></table></figure><p>先是调用的<code>board_eth_init</code>，接着调用<code>dm9000_initialize</code>，在这个函数里，就是将<code>dm9000_info.netdev</code>结构给初始化，并且从EEPROM中获取MAC地址，初始化函数，然后注册（在注册中，如果<code>eth_devices</code>网卡设备链表为空，则使<code>eth_devices</code>、<code>eth_devices</code>指向当前设备dev，并且如果当前网卡存在则设置环境变量中<code>ethact</code>的名称为当前网卡名，也就是说如果手动更改环境变量中<code>ethact</code>的value，即使保存后，下次重启后<code>ethact</code>为前面设置的<code>dm9000</code>。接着就是将网卡状态置位，将<code>next</code>指针指向自己，索引自加）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// board/samsung/smart210/smart210.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">board_eth_init</span><span class="hljs-params">(<span class="hljs-type">bd_t</span> *bis)</span><br>{<br><span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;<br>rc = dm9000_initialize(bis);<br><span class="hljs-keyword">return</span> rc;<br>}<br><span class="hljs-comment">//----------------------------------------------------------------------------------</span><br><span class="hljs-comment">// drivers/net/dm9000x.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dm9000_initialize</span><span class="hljs-params">(<span class="hljs-type">bd_t</span> *bis)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eth_device</span> *<span class="hljs-title">dev</span> =</span> &amp;(dm9000_info.netdev);<br><br><span class="hljs-comment">/* Load MAC address from EEPROM */</span><br>dm9000_get_enetaddr(dev);<br><br>dev-&gt;init = dm9000_init;<br>dev-&gt;halt = dm9000_halt;<br>dev-&gt;send = dm9000_send;<br>dev-&gt;recv = dm9000_rx;<br><span class="hljs-built_in">sprintf</span>(dev-&gt;name, <span class="hljs-string">"dm9000"</span>);<br><br>eth_register(dev);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着我们返回到<code>eth_initialize</code>，看一下剩下的部分。从<code>eth_devices</code>中取出，从环境变量中取出<code>ethprime</code>的value（应该为空，因为环境变量中没有此项），标记一下当前阶段。接着就是如果有多个网卡，则在显示的时候中间用<code>,</code>分开，比如：<code>Net:   dm9000,dm9001</code>。然后<code>eth_write_hwaddr</code>写网卡的MAC地址到dev中，接着更新下一个，但是我们刚刚设置dev-&gt;next指向自己，所以条件不满足，退出循环，返回网卡的个数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// net/eth.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eth_initialize</span><span class="hljs-params">(<span class="hljs-type">bd_t</span> *bis)</span><br>{<br>         ...<br>         <span class="hljs-keyword">if</span> (!eth_devices) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"No ethernet found.\n"</span>);<br>bootstage_error(BOOTSTAGE_ID_NET_ETH_START);<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-keyword">struct</span> eth_device *dev = eth_devices;<br><span class="hljs-type">char</span> *ethprime = getenv(<span class="hljs-string">"ethprime"</span>);<br><br>bootstage_mark(BOOTSTAGE_ID_NET_ETH_INIT);<br><span class="hljs-keyword">do</span> {<br><span class="hljs-keyword">if</span> (dev-&gt;index)<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">", "</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, dev-&gt;name);<br><br><span class="hljs-keyword">if</span> (ethprime &amp;&amp; <span class="hljs-built_in">strcmp</span>(dev-&gt;name, ethprime) == <span class="hljs-number">0</span>) {<br>eth_current = dev;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">" [PRIME]"</span>);<br>}<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(dev-&gt;name, <span class="hljs-string">' '</span>))<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"\nWarning: eth device name has a space!"</span> <span class="hljs-string">"\n"</span>);<br><br><span class="hljs-keyword">if</span> (eth_write_hwaddr(dev, <span class="hljs-string">"eth"</span>, dev-&gt;index))<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"\nWarning: failed to set MAC address\n"</span>);<br><br>dev = dev-&gt;next;<br>num_devices++;<br>} <span class="hljs-keyword">while</span> (dev != eth_devices);<br><br>eth_current_changed();<br>putc(<span class="hljs-string">'\n'</span>);<br>}<br><span class="hljs-keyword">return</span> num_devices;<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="main-loop"><a href="#main-loop" class="headerlink" title="main_loop"></a>main_loop</h5><p>终于到最后一个函数了，</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/arm/lib/board.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_init_r</span><span class="hljs-params">(<span class="hljs-type">gd_t</span> *id, ulong dest_addr)</span><br>{<br>        ...<br><span class="hljs-comment">/* main_loop() can return to retry autoboot, if so just run it again. */</span><br><span class="hljs-keyword">for</span> (;;) {<br>main_loop();<br>}<br><span class="hljs-comment">/* NOTREACHED - no way out of command loop except booting */</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>已定义宏 <code>CONFIG_SYS_HUSH_PARSER</code>、<code>CONFIG_BOOTDELAY</code>精简后代码如下，首先标记当前阶段<code>BOOTSTAGE_ID_MAIN_LOOP</code>，接着看一下这几个函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/main.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main_loop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, <span class="hljs-string">"main_loop"</span>);<br>u_boot_hush_start();<br>process_boot_delay();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Main Loop for Monitor Command Processing</span><br><span class="hljs-comment"> */</span><br>parse_file_outer();<br><span class="hljs-comment">/* This point is never reached */</span><br><span class="hljs-keyword">for</span> (;;);<br>}<br></code></pre></td></tr></tbody></table></figure><h6 id="u-boot-hush-start"><a href="#u-boot-hush-start" class="headerlink" title="u_boot_hush_start"></a>u_boot_hush_start</h6><p> <code>u_boot_hush_start</code>在<code>common/hush.c</code>中，给<code>top_vars</code>分配空间，然后初始化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/hush.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">u_boot_hush_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-keyword">if</span> (top_vars == <span class="hljs-literal">NULL</span>) {<br>top_vars = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> variables));<br>top_vars-&gt;name = <span class="hljs-string">"HUSH_VERSION"</span>;<br>top_vars-&gt;value = <span class="hljs-string">"0.01"</span>;<br>top_vars-&gt;next = <span class="hljs-literal">NULL</span>;<br>top_vars-&gt;flg_export = <span class="hljs-number">0</span>;<br>top_vars-&gt;flg_read_only = <span class="hljs-number">1</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h6 id="process-boot-delay"><a href="#process-boot-delay" class="headerlink" title="process_boot_delay"></a>process_boot_delay</h6><p><code>process_boot_delay</code> 在<code>common/main.c</code>中，从环境变量中获取<code>bootdelay</code>对应的value，获取<code>bootcmd</code>对应的value，然后进入<code>abortboot(bootdelay)</code>函数，</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/main.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_boot_delay</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-type">char</span> *s;<br><span class="hljs-type">int</span> bootdelay;<br>s = getenv (<span class="hljs-string">"bootdelay"</span>);<br>bootdelay = s ? (<span class="hljs-type">int</span>)simple_strtol(s, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>) : CONFIG_BOOTDELAY;<br>debug (<span class="hljs-string">"### main_loop entered: bootdelay=%d\n"</span>, bootdelay);<br>s = getenv (<span class="hljs-string">"bootcmd"</span>);<br>debug (<span class="hljs-string">"### main_loop: bootcmd=\"%s\"\n"</span>, s ? s : <span class="hljs-string">"&lt;UNDEFINED&gt;"</span>);<br><span class="hljs-keyword">if</span> (bootdelay != <span class="hljs-number">-1</span> &amp;&amp; s &amp;&amp; !abortboot(bootdelay)) {<br>run_command_list(s, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>abortboot</code>处理延迟逻辑</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/main.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">abortboot</span><span class="hljs-params">(<span class="hljs-type">int</span> bootdelay)</span><br>{<br><span class="hljs-keyword">return</span> abortboot_normal(bootdelay);<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果获取到字符，就停止计时，否则一直在此空转，<code>bootdelay</code>秒后，函数返回。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/main.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">abortboot_normal</span><span class="hljs-params">(<span class="hljs-type">int</span> bootdelay)</span><br>{<br><span class="hljs-type">int</span> <span class="hljs-built_in">abort</span> = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ts;<br><br><span class="hljs-keyword">if</span> (bootdelay &gt;= <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hit any key to stop autoboot: %2d "</span>, bootdelay);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check if key already pressed</span><br><span class="hljs-comment"> * Don't check if bootdelay &lt; 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (bootdelay &gt;= <span class="hljs-number">0</span>) {<br><span class="hljs-keyword">if</span> (tstc()) {<span class="hljs-comment">/* we got a key press*/</span><br>(<span class="hljs-type">void</span>) getc();  <span class="hljs-comment">/* consume input*/</span><br><span class="hljs-built_in">puts</span> (<span class="hljs-string">"\b\b\b 0"</span>);<br><span class="hljs-built_in">abort</span> = <span class="hljs-number">1</span>;<span class="hljs-comment">/* don't auto boot*/</span><br>}<br>}<br><br><span class="hljs-keyword">while</span> ((bootdelay &gt; <span class="hljs-number">0</span>) &amp;&amp; (!<span class="hljs-built_in">abort</span>)) {<br>--bootdelay;<br><span class="hljs-comment">/* delay 1000 ms */</span><br>ts = get_timer(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">do</span> {<br><span class="hljs-keyword">if</span> (tstc()) {<span class="hljs-comment">/* we got a key press*/</span><br><span class="hljs-built_in">abort</span>  = <span class="hljs-number">1</span>;<span class="hljs-comment">/* don't auto boot*/</span><br>bootdelay = <span class="hljs-number">0</span>;<span class="hljs-comment">/* no more delay*/</span><br>(<span class="hljs-type">void</span>) getc();  <span class="hljs-comment">/* consume input*/</span><br><span class="hljs-keyword">break</span>;<br>}<br>udelay(<span class="hljs-number">10000</span>);<br>} <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">abort</span> &amp;&amp; get_timer(ts) &lt; <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\b\b\b%2d "</span>, bootdelay);<br>}<br>putc(<span class="hljs-string">'\n'</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abort</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后运行 <code>run_command_list(s, -1, 0);</code>，此时s中数据为<code>bootcmd="nfs 20000000 10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs/uImage;nfs 21000000 10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs/s5pv210-smart210.dtb;bootm 20000000 - 21000000"</code></p><h6 id="run-command-list"><a href="#run-command-list" class="headerlink" title="run_command_list"></a>run_command_list</h6><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">run_command_list</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmd, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> flag)</span><br>{<br><span class="hljs-type">int</span> need_buff = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> *buff = (<span class="hljs-type">char</span> *)cmd;<span class="hljs-comment">/* cast away const */</span><br><span class="hljs-type">int</span> rcode = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>) {<br>len = <span class="hljs-built_in">strlen</span>(cmd);<br><span class="hljs-comment">/* hush will never change our string */</span><br>need_buff = <span class="hljs-number">0</span>;<br>}<br>rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);<span class="hljs-comment">// 1&lt;&lt;1</span><br><span class="hljs-keyword">return</span> rcode;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>run_command_list</code>只是对<code>hush shell</code>中的函数<code>parse_string_outer</code>进行了一层封装。<code>parse_string_outer</code>函数调用了<code>hush shell</code>的命令解释器<code>parse_stream_outer</code>函数来解释bootcmd的命令。</p><h6 id="parse-string-outer"><a href="#parse-string-outer" class="headerlink" title="parse_string_outer"></a>parse_string_outer</h6><p>我们看下<code>parse_stream_outer</code>这个执行过程实在太复杂了。从这开始整个执行流程是这样的，最后就跳转到调用的地方了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">--&gt; parse_string_outer<br>    |<br>    --&gt; parse_stream_outer<br>    |<br>    --&gt; parse_stream<br>    --&gt; run_list<br>    |<br>    --&gt; run_list_real<br>    |<br>    --&gt; run_pipe_real<br>    |<br>    --&gt; cmd_process<br>    |<br>    --&gt; cmd_call<br></code></pre></td></tr></tbody></table></figure><p><del>这个过程需要理解一系列的代码以及各种神奇操作，让我们先省略这一段继续往后吧。</del></p><p>最后调用<code>parse_string_outer</code>，在源码中，我们定义了<code>__U_BOOT__</code>宏，所以<code>parse_string_outer</code>源码如下</p><p>首先进入代码后先判空，然后搜索<code>\n</code>，如果以<code>\n</code>结尾，<del>会走if分支，否则走else分支</del>，其区别就是是否需要分配空间，拷贝一下，添加<code>\n</code>到尾部。</p><p>然后转换一下格式，在<code>setup_string_in_str</code>中将其转为结构体<code>struct in_str</code>，然后进入<code>parse_stream_outer</code>，<del>此处hush解析器不在分析。</del>还是得分析。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/hush.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">parse_string_outer</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> flag)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_str</span> <span class="hljs-title">input</span>;</span><br><span class="hljs-type">char</span> *p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> rcode;<br><span class="hljs-keyword">if</span> ( !s || !*s)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (!(p = <span class="hljs-built_in">strchr</span>(s, <span class="hljs-string">'\n'</span>)) || *++p) {<br>p = xmalloc(<span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">2</span>);<br><span class="hljs-built_in">strcpy</span>(p, s);<br><span class="hljs-built_in">strcat</span>(p, <span class="hljs-string">"\n"</span>);<br>setup_string_in_str(&amp;input, p);<br>rcode = parse_stream_outer(&amp;input, flag);<br><span class="hljs-built_in">free</span>(p);<br><span class="hljs-keyword">return</span> rcode;<br>} <span class="hljs-keyword">else</span> {<br>setup_string_in_str(&amp;input, s);<br><span class="hljs-keyword">return</span> parse_stream_outer(&amp;input, flag);<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><h6 id="parse-stream-outer"><a href="#parse-stream-outer" class="headerlink" title="parse_stream_outer"></a>parse_stream_outer</h6><p>先进入<code>parse_stream</code>函数对数据进行处理，识别到执行命令后，最后进入<code>run_list</code>函数，<code>parse_stream</code>和<code>run_list</code>中间的数据是怎么衔接的呢？借助<code>ctx</code>，一会看一下<code>ctx</code>（<code>p_context</code>）的结构。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/hush.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parse_stream_outer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_str *inp, <span class="hljs-type">int</span> flag)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">p_context</span> <span class="hljs-title">ctx</span>;</span><br>o_string temp=NULL_O_STRING;<br><span class="hljs-type">int</span> rcode;<br><span class="hljs-type">int</span> code = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> {<br>ctx.type = flag;<br>initialize_context(&amp;ctx);<br>update_ifs_map();<br><span class="hljs-keyword">if</span> (!(flag &amp; FLAG_PARSE_SEMICOLON) || (flag &amp; FLAG_REPARSING)) mapset((uchar *)<span class="hljs-string">";$&amp;|"</span>, <span class="hljs-number">0</span>);<br>inp-&gt;promptmode=<span class="hljs-number">1</span>;<br>rcode = parse_stream(&amp;temp, &amp;ctx, inp, <span class="hljs-string">'\n'</span>);<br><span class="hljs-keyword">if</span> (rcode == <span class="hljs-number">1</span>) flag_repeat = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (rcode != <span class="hljs-number">1</span> &amp;&amp; ctx.old_flag != <span class="hljs-number">0</span>) {<br>syntax();<br>flag_repeat = <span class="hljs-number">0</span>;<br>}<br><span class="hljs-keyword">if</span> (rcode != <span class="hljs-number">1</span> &amp;&amp; ctx.old_flag == <span class="hljs-number">0</span>) {<br>done_word(&amp;temp, &amp;ctx);<br>done_pipe(&amp;ctx,PIPE_SEQ);<br>code = run_list(ctx.list_head);<br><span class="hljs-keyword">if</span> (code == <span class="hljs-number">-2</span>) {<span class="hljs-comment">/* exit */</span><br>b_free(&amp;temp);<br>code = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* XXX hackish way to not allow exit from main loop */</span><br><span class="hljs-keyword">if</span> (inp-&gt;peek == file_peek) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"exit not allowed from main input shell.\n"</span>);<br><span class="hljs-keyword">continue</span>;<br>}<br><span class="hljs-keyword">break</span>;<br>}<br><span class="hljs-keyword">if</span> (code == <span class="hljs-number">-1</span>)<br>    flag_repeat = <span class="hljs-number">0</span>;<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-keyword">if</span> (ctx.old_flag != <span class="hljs-number">0</span>) {<br><span class="hljs-built_in">free</span>(ctx.<span class="hljs-built_in">stack</span>);<br>b_reset(&amp;temp);<br>}<br><span class="hljs-keyword">if</span> (inp-&gt;__promptme == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&lt;INTERRUPT&gt;\n"</span>);<br>inp-&gt;__promptme = <span class="hljs-number">1</span>;<br>temp.nonnull = <span class="hljs-number">0</span>;<br>temp.quote = <span class="hljs-number">0</span>;<br>inp-&gt;p = <span class="hljs-literal">NULL</span>;<br>free_pipe_list(ctx.list_head,<span class="hljs-number">0</span>);<br>}<br>b_free(&amp;temp);<br>} <span class="hljs-keyword">while</span> (rcode != <span class="hljs-number">-1</span> &amp;&amp; !(flag &amp; FLAG_EXIT_FROM_LOOP));   <span class="hljs-comment">/* loop on syntax errors, return on EOF */</span><br><span class="hljs-keyword">return</span> (code != <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h6 id="negative-squared-cross-mark-p-context"><a href="#negative-squared-cross-mark-p-context" class="headerlink" title=":negative_squared_cross_mark: p_context"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> p_context</h6><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This holds pointers to the various results of parsing */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">p_context</span> {</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">child_prog</span> *<span class="hljs-title">child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">list_head</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __U_BOOT__</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redir_struct</span> *<span class="hljs-title">pending_redirect</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>reserved_style w;<br><span class="hljs-type">int</span> old_flag;<span class="hljs-comment">/* for figuring out valid reserved words */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">p_context</span> *<span class="hljs-title">stack</span>;</span><br><span class="hljs-type">int</span> type;<span class="hljs-comment">/* define type of parser : ";$" common or special symbol */</span><br><span class="hljs-comment">/* How about quoting status? */</span><br>};<br></code></pre></td></tr></tbody></table></figure><h6 id="run-list"><a href="#run-list" class="headerlink" title="run_list"></a>run_list</h6><p>由于定义了<code>__U_BOOT__</code>，所以此处会直接运行<code>rcode = run_list_real(pi);</code>，进入到<code>run_list_real</code>函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_list</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi)</span><br>{<br><span class="hljs-type">int</span> rcode=<span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __U_BOOT__</span><br><span class="hljs-keyword">if</span> (fake_mode==<span class="hljs-number">0</span>) {<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>rcode = run_list_real(pi);<br>debug(<span class="hljs-string">"rcode:%d\n"</span>,rcode);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __U_BOOT__</span><br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* free_pipe_list has the side effect of clearing memory</span><br><span class="hljs-comment"> * In the long run that function can be merged with run_list_real,</span><br><span class="hljs-comment"> * but doing that now would hobble the debugging effort. */</span><br>free_pipe_list(pi,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> rcode;<br>}<br></code></pre></td></tr></tbody></table></figure><h6 id="negative-squared-cross-mark-run-list-real"><a href="#negative-squared-cross-mark-run-list-real" class="headerlink" title=":negative_squared_cross_mark: run_list_real"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> run_list_real</h6><p><strong>TODO：待分析</strong></p><p>只会运行一次，且不会返回。</p><p>跳转到<code>rcode = run_pipe_real(pi);</code></p><h6 id="negative-squared-cross-mark-run-pipe-real"><a href="#negative-squared-cross-mark-run-pipe-real" class="headerlink" title=":negative_squared_cross_mark: run_pipe_real"></a><span class="github-emoji"><span>❎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> run_pipe_real</h6><p>先看一下<code>struct pipe</code>是什么东西，在u-boot中有<code>__U_BOOT__</code>宏，去掉了相关无用的代码。</p><p>此处看一下busybox中的<a href="https://git.busybox.net/busybox/tree/shell/hush_doc.txt">hush_doc.txt</a>中的示例就明白了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> {</span><br><span class="hljs-type">int</span> num_progs;<span class="hljs-comment">/* 在当前任务流中的命令总数 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">child_prog</span> *<span class="hljs-title">progs</span>;</span><span class="hljs-comment">/* 在管道中的命令数组 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">/* 下一个命令的指针 */</span><br>pipe_style followup;    <span class="hljs-comment">/* 表示这一截管道的类型 PIPE_BG, PIPE_SEQ, PIPE_OR, PIPE_AND；比如a &amp;&amp; b，则此处应为PIPE_AND */</span><br>reserved_style r_mode;  <span class="hljs-comment">/* 表示控制流 比如if,for, while, until这种 */</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>解析管道中的命令，处理条件语句，比如IF、THEN、ELSE等。</p><h6 id="cmd-process"><a href="#cmd-process" class="headerlink" title="cmd_process"></a>cmd_process</h6><p>此处函数在重启时会执行三次，因为在bootcmd 启动命令中有三段。</p><p><code>nfs 20000000 10.0.0.97:/home/glj0/worksapce/os/smart210/rootfs/uImage;</code></p><p><code>nfs 21000000 10.0.0.97:/home/glj0/worksapce/os/smart210/rootfs/s5pv210-smart210.dtb;</code></p><p><code>bootm 20000000 - 21000000</code></p><p>这个函数会在之前定义的boot_list中找命令对应的函数，比如nfs、bootm等，找到后将其填充到 <code>cmd_tbl_t *cmdtp</code>中，然后跳入<code>cmd_call</code>中</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">enum</span> <span class="hljs-type">command_ret_t</span> <span class="hljs-title function_">cmd_process</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[],</span><br><span class="hljs-params">       <span class="hljs-type">int</span> *repeatable, ulong *ticks)</span><br>{<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">command_ret_t</span> <span class="hljs-title">rc</span> =</span> CMD_RET_SUCCESS;<br><span class="hljs-type">cmd_tbl_t</span> *cmdtp;<br>debug(<span class="hljs-string">"flag:%d argc:%d\r\n"</span>,flag,argc);<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;i&lt;argc;i++){<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv[%d]:%s\r\n"</span>,i,argv[i]);<br>}<br><span class="hljs-comment">/* Look up command in command table */</span><br>cmdtp = find_cmd(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">if</span> (cmdtp == <span class="hljs-literal">NULL</span>) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Unknown command '%s' - try 'help'\n"</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-comment">/* found - check max args */</span><br><span class="hljs-keyword">if</span> (argc &gt; cmdtp-&gt;maxargs)<br>rc = CMD_RET_USAGE;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_CMD_BOOTD)</span><br><span class="hljs-comment">/* avoid "bootd" recursion */</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmdtp-&gt;cmd == do_bootd) {<br><span class="hljs-keyword">if</span> (flag &amp; CMD_FLAG_BOOTD) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"'bootd' recursion detected\n"</span>);<br>rc = CMD_RET_FAILURE;<br>} <span class="hljs-keyword">else</span> {<br>flag |= CMD_FLAG_BOOTD;<br>}<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* If OK so far, then do the command */</span><br><span class="hljs-keyword">if</span> (!rc) {<br><span class="hljs-keyword">if</span> (ticks)<br>*ticks = get_timer(<span class="hljs-number">0</span>);<br>debug(<span class="hljs-string">"cmd_call cmdtp-&gt;name:%s\r\n"</span>,cmdtp-&gt;name);<br>rc = cmd_call(cmdtp, flag, argc, argv);<br><span class="hljs-keyword">if</span> (ticks)<br>*ticks = get_timer(*ticks);<br>*repeatable &amp;= cmdtp-&gt;repeatable;<br>}<br><span class="hljs-keyword">if</span> (rc == CMD_RET_USAGE)<br>rc = cmd_usage(cmdtp);<br><span class="hljs-keyword">return</span> rc;<br>}<br></code></pre></td></tr></tbody></table></figure><h6 id="cmd-call"><a href="#cmd-call" class="headerlink" title="cmd_call"></a>cmd_call</h6><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cmd_call</span><span class="hljs-params">(<span class="hljs-type">cmd_tbl_t</span> *cmdtp, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[])</span><br>{<br><span class="hljs-type">int</span> result;<br>debug(<span class="hljs-string">"cmdtp:%p flag:%d argc:%d\r\n"</span>,cmdtp,flag,argc);<br>debug(<span class="hljs-string">"cmdtp-&gt;name:%s maxargs:%d cmd:%p usage:%s \r\n"</span>,cmdtp-&gt;name,cmdtp-&gt;maxargs,cmdtp-&gt;cmd,cmdtp-&gt;usage);<br>result = (cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);<br><span class="hljs-keyword">if</span> (result)<br>debug(<span class="hljs-string">"Command failed, result=%d"</span>, result);<br><span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure><p>首先看下是怎么调用的，最终在cmd_call中完成调用，最关键的一句<code>result = (cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);</code>此时并不能发现什么猫腻，无法就是<code>cmdtp-&gt;cmd</code>是一个函数地址，后面这一堆是参数，那么，这个地址指向的是什么呢？肯定是一个<code>函数</code>。由于我们DEBUG模式下加了许多打印，所以可以轻松得到这个地址值为<code>3ff8b590</code>，前面我们有个重定位还有印象吗？没有印象去查看一下<a href="#relocate_code">relocate_code</a>，<code>代码的地址：编译后函数的地址+重定位偏移量</code> 接着查日志中，发现relocate偏移量为<code>1ff7b000</code>，那么这个函数偏移前地址也就是<code>3ff8b590-1ff7b000=20010590</code>，看一下u-boot.map文件下该地址对应的是什么，对应的是<code>do_nfs</code>。<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204211947823.png"></p><p>查一下该符号<code>grep -nr do_nfs</code>，发现存在该函数。那么我们就可以理解了，在<code>cmd_call</code>之前通过一系列的骚操作，得到<code>某指令</code>对应的<code>do_某指令</code>函数地址，然后跳转到这个函数地址就可以进行后面的操作了。<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204211950205.png"></p><p>在do_nfs附近有一个<code>U_BOOT_CMD ...</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_nfs</span><span class="hljs-params">(<span class="hljs-type">cmd_tbl_t</span> *cmdtp, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[])</span><br>{<br><span class="hljs-keyword">return</span> netboot_common(NFS, cmdtp, argc, argv);<br>}<br><br>U_BOOT_CMD(<br>nfs,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,do_nfs,<br><span class="hljs-string">"boot image via network using NFS protocol"</span>,<br><span class="hljs-string">"[loadAddress] [[hostIPaddr:]bootfilename]"</span><br>);<br></code></pre></td></tr></tbody></table></figure><p>该宏在<code>include/command.h</code>定义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/command.h</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    　各个参数的意义如下：</span><br><span class="hljs-comment">       _name：命令名，非字符串，但在U_BOOT_CMD中用“#”符号转化为字符串</span><br><span class="hljs-comment">       _maxargs：命令的最大参数个数</span><br><span class="hljs-comment">       _rep：是否自动重复（按Enter键是否会重复执行）</span><br><span class="hljs-comment">       _cmd：该命令对应的响应函数指针</span><br><span class="hljs-comment">       _usage：简短的使用说明（字符串）</span><br><span class="hljs-comment">       _help：较详细的使用说明（字符串）</span><br><span class="hljs-comment">       */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL)</span><br><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \</span><br><span class="hljs-meta">ll_entry_declare(cmd_tbl_t, _name, cmd) =\</span><br><span class="hljs-meta">U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,_usage, _help, _comp);</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,_usage, _help, _comp)\</span><br><span class="hljs-meta">{ #_name, _maxargs, _rep, _cmd, _usage,_CMD_HELP(_help) _CMD_COMPLETE(_comp) }</span><br>--------------------------------------------------------------------------------------------------------------------<br><span class="hljs-comment">// 手动替换 U_BOOT_CMD_COMPLETE 以及 U_BOOT_CMD_MKENT_COMPLETE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)\</span><br><span class="hljs-meta">ll_entry_declare(cmd_tbl_t, _name, cmd) = { #_name, _maxargs, _rep, _cmd, _usage,_help ,NULL }</span><br>--------------------------------------------------------------------------------------------------------------------<br><span class="hljs-comment">// include/linker_lists.h</span><br><span class="hljs-comment">// ll_entry_declare 在 include/linker_lists.h 定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll_entry_declare(_type, _name, _list)\</span><br><span class="hljs-meta">_type _u_boot_list_2_##_list##_2_##_name __aligned(4) __attribute__((unused,section(<span class="hljs-string">".u_boot_list_2_"</span>#_list<span class="hljs-string">"_2_"</span>#_name)))</span><br>--------------------------------------------------------------------------------------------------------------------    <br><span class="hljs-comment">// 示例 -- 手动解释这段宏</span><br> U_BOOT_CMD(<br>nfs,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,do_nfs,<br><span class="hljs-string">"boot image via network using NFS protocol"</span>,<br><span class="hljs-string">"[loadAddress] [[hostIPaddr:]bootfilename]"</span><br>);<br><span class="hljs-comment">// 替换后也就是</span><br><span class="hljs-type">cmd_tbl_t</span>  _u_boot_list_2_cmd_2_nfs __aligned(<span class="hljs-number">4</span>) __attribute__((unused,section(<span class="hljs-string">".u_boot_list_2_cmd_2_nfs"</span>))) = \<br>{nfs,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,do_nfs,<span class="hljs-string">"boot image via network using NFS protocol"</span>,<span class="hljs-string">"[loadAddress] [[hostIPaddr:]bootfilename]"</span>}<br></code></pre></td></tr></tbody></table></figure><p><code>cmdtp-&gt;cmd</code>我们知道是什么了，<code>cmdtp</code>呢？看下地址：<code>3ffb8f64</code>（通过日志查看）在减去重定位偏移<code>1ff7b000</code>，也就是<code>2003DF64</code>，通过在<code>u-boot.map</code>中查看对应地址<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204220931044.png"></p><p>发现其也就是我们上面使用<code>U_BOOT_CMD</code>定义的这一串，而这一串的格式也恰恰与<code>struct cmd_tbl_s</code>一致。<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204220934517.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmd_tbl_s</span> {</span><br><span class="hljs-type">char</span>*name;<span class="hljs-comment">/* 指令名称 */</span><br><span class="hljs-type">int</span>maxargs; <span class="hljs-comment">/* 命令的最大参数个数*/</span><br><span class="hljs-type">int</span>repeatable;    <span class="hljs-comment">/* 是否自动重复*/</span><br>    <span class="hljs-comment">/* Implementation function*/</span><br><span class="hljs-type">int</span>(*cmd)(<span class="hljs-keyword">struct</span> cmd_tbl_s *, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> []);<br><span class="hljs-type">char</span>*usage;<span class="hljs-comment">/* 简短的使用说明 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_SYS_LONGHELP</span><br><span class="hljs-type">char</span>*help;<span class="hljs-comment">/* 较详细的使用说明 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_AUTO_COMPLETE</span><br><span class="hljs-comment">/* do auto completion on the arguments */</span><br><span class="hljs-type">int</span>(*complete)(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> last_char, <span class="hljs-type">int</span> maxv, <span class="hljs-type">char</span> *cmdv[]);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>};<br></code></pre></td></tr></tbody></table></figure><h6 id="do-nfs"><a href="#do-nfs" class="headerlink" title="do_nfs"></a>do_nfs</h6><p>前面我们知道了在<code>cmd_call</code>中会调用<code>do_nfs</code>函数，接下来就分析一下该函数。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">do_nfs<br>|<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">netboot_common</span><br>|<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">NetLoop</span><br>|<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">eth_halt</span><br>|<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash"> dm9000_halt</span><br>|<br>        eth_set_current<br>                  eth_init <br>|<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">dm9000_init</span><br>             |<br>              --&gt; NfsStart<br>                   |<br>                   --&gt;  Nfs_Send<br>                   --&gt; eth_rx<br>|<br>--&gt; dm9000_rx<br></code></pre></td></tr></tbody></table></figure><p>根据日志，我们接着分析。先分析这一段<img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204221402853.png"></p><p>通过上面调用关系，直接看<code>netboot_common</code>，在这个函数中，上面首先是各种初始化，根据参数的不同设定对应的<code>load_addr</code>，这部分我们先不看，在函数的中间有一个<code>NetLoop</code>函数，其中参数为协议类型，此处也就是nfs</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/cmd_net.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">netboot_common</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> <span class="hljs-type">proto_t</span> proto, <span class="hljs-type">cmd_tbl_t</span> *cmdtp, <span class="hljs-type">int</span> argc,</span><br><span class="hljs-params"><span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[])</span><br>{<br>...<br><span class="hljs-keyword">if</span> ((size = NetLoop(proto)) &lt; <span class="hljs-number">0</span>) {<br>bootstage_error(BOOTSTAGE_ID_NET_NETLOOP_OK);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br>...<br>}<br></code></pre></td></tr></tbody></table></figure><p>由于<code>eth_is_on_demand_init</code>返回值为1，所以会进入if分支下，然后 <code>eth_halt</code>也就是调用 <code>eth_current-&gt;halt(eth_current)</code></p><p>接着<code>eth_set_current</code>：在环境变量中找到ethact的名字，在<code>eth_current</code>链表中查找该设备，找到就退出</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// net/net.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">NetLoop</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> <span class="hljs-type">proto_t</span> protocol)</span><br>{<br><span class="hljs-type">bd_t</span> *bd = gd-&gt;bd;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">-1</span>;<br><br>NetRestarted = <span class="hljs-number">0</span>;<br>NetDevExists = <span class="hljs-number">0</span>;<br>NetTryCount = <span class="hljs-number">1</span>;<br>debug_cond(DEBUG_INT_STATE, <span class="hljs-string">"--- NetLoop Entry\n"</span>);<br><br>bootstage_mark_name(BOOTSTAGE_ID_ETH_START, <span class="hljs-string">"eth_start"</span>);<br>net_init();<br><span class="hljs-keyword">if</span> (eth_is_on_demand_init() || protocol != NETCONS) {<br>eth_halt();<br>eth_set_current();<br><span class="hljs-keyword">if</span> (eth_init(bd) &lt; <span class="hljs-number">0</span>) {<br>eth_halt();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br>} <span class="hljs-keyword">else</span><br>eth_init_state_only(bd);<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>在<code>eth_init</code>中，先是打印<code>Trying ...</code>，然后调用<code>eth_current-&gt;init(eth_current, bis)</code> ，这个init函数调到什么地方去了呢？</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">eth_init</span><span class="hljs-params">(<span class="hljs-type">bd_t</span> *bis)</span><br>{<br>    ...<br><span class="hljs-keyword">do</span> {<br>debug(<span class="hljs-string">"Trying %s\n"</span>, eth_current-&gt;name);<br><br><span class="hljs-keyword">if</span> (eth_current-&gt;init(eth_current, bis) &gt;= <span class="hljs-number">0</span>) {<br>eth_current-&gt;state = ETH_STATE_ACTIVE;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br>debug(<span class="hljs-string">"FAIL\n"</span>);<br>eth_try_another(<span class="hljs-number">0</span>);<br>} <span class="hljs-keyword">while</span> (old_current != eth_current);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>不知各位看官还有印象没，我们在前面 board_init_r 中的<a href="#eth_initialize">eth_initialize</a>初始化的时候，会调用到</p><p><code>int dm9000_initialize(bd_t *bis)</code>，在此函数中，绑定了针对dm9000芯片的操作，然后注册到了<code>eth_devices</code>，所以我们刚刚调用<code>eth_current-&gt;init(eth_current, bis)</code>就是直接执行 <code>dm9000_init(struct eth_device *dev, bd_t *bd)</code>，所以日志中也就会这些输出了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dm9000_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eth_device *dev, <span class="hljs-type">bd_t</span> *bd)</span><br>{<br><span class="hljs-type">int</span> i, oft, lnk;<br>u8 io_mode;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">board_info</span> *<span class="hljs-title">db</span> =</span> &amp;dm9000_info;<br><br>DM9000_DBG(<span class="hljs-string">"%s\n"</span>, __func__);<br><br><span class="hljs-comment">/* RESET device */</span><br>dm9000_reset();<br><br><span class="hljs-keyword">if</span> (dm9000_probe() &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">/* Auto-detect 8/16/32 bit mode, ISR Bit 6+7 indicate bus width */</span><br>io_mode = DM9000_ior(DM9000_ISR) &gt;&gt; <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">switch</span> (io_mode) {<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x0</span>:  <span class="hljs-comment">/* 16-bit mode */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"DM9000: running in 16 bit mode\n"</span>);<br>db-&gt;outblk    = dm9000_outblk_16bit;<br>db-&gt;inblk     = dm9000_inblk_16bit;<br>db-&gt;rx_status = dm9000_rx_status_16bit;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x01</span>:  <span class="hljs-comment">/* 32-bit mode */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"DM9000: running in 32 bit mode\n"</span>);<br>db-&gt;outblk    = dm9000_outblk_32bit;<br>db-&gt;inblk     = dm9000_inblk_32bit;<br>db-&gt;rx_status = dm9000_rx_status_32bit;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x02</span>: <span class="hljs-comment">/* 8 bit mode */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"DM9000: running in 8 bit mode\n"</span>);<br>db-&gt;outblk    = dm9000_outblk_8bit;<br>db-&gt;inblk     = dm9000_inblk_8bit;<br>db-&gt;rx_status = dm9000_rx_status_8bit;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">/* Assume 8 bit mode, will probably not work anyway */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"DM9000: Undefined IO-mode:0x%x\n"</span>, io_mode);<br>db-&gt;outblk    = dm9000_outblk_8bit;<br>db-&gt;inblk     = dm9000_inblk_8bit;<br>db-&gt;rx_status = dm9000_rx_status_8bit;<br><span class="hljs-keyword">break</span>;<br>}<br><br><span class="hljs-comment">/* Program operating register, only internal phy supported */</span><br>DM9000_iow(DM9000_NCR, <span class="hljs-number">0x0</span>);<br><span class="hljs-comment">/* TX Polling clear */</span><br>DM9000_iow(DM9000_TCR, <span class="hljs-number">0</span>);<br><span class="hljs-comment">/* Less 3Kb, 200us */</span><br>DM9000_iow(DM9000_BPTR, BPTR_BPHW(<span class="hljs-number">3</span>) | BPTR_JPT_600US);<br><span class="hljs-comment">/* Flow Control : High/Low Water */</span><br>DM9000_iow(DM9000_FCTR, FCTR_HWOT(<span class="hljs-number">3</span>) | FCTR_LWOT(<span class="hljs-number">8</span>));<br><span class="hljs-comment">/* SH <span class="hljs-doctag">FIXME:</span> This looks strange! Flow Control */</span><br>DM9000_iow(DM9000_FCR, <span class="hljs-number">0x0</span>);<br><span class="hljs-comment">/* Special Mode */</span><br>DM9000_iow(DM9000_SMCR, <span class="hljs-number">0</span>);<br><span class="hljs-comment">/* clear TX status */</span><br>DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);<br><span class="hljs-comment">/* Clear interrupt status */</span><br>DM9000_iow(DM9000_ISR, ISR_ROOS | ISR_ROS | ISR_PTS | ISR_PRS);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"MAC: %pM\n"</span>, dev-&gt;enetaddr);<br><span class="hljs-keyword">if</span> (!is_valid_ether_addr(dev-&gt;enetaddr)) {<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_RANDOM_MACADDR</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Bad MAC address (uninitialized EEPROM?), randomizing\n"</span>);<br>eth_random_enetaddr(dev-&gt;enetaddr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"MAC: %pM\n"</span>, dev-&gt;enetaddr);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"WARNING: Bad MAC address (uninitialized EEPROM?)\n"</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br><br><span class="hljs-comment">/* fill device MAC address registers */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, oft = DM9000_PAR; i &lt; <span class="hljs-number">6</span>; i++, oft++)<br>DM9000_iow(oft, dev-&gt;enetaddr[i]);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, oft = <span class="hljs-number">0x16</span>; i &lt; <span class="hljs-number">8</span>; i++, oft++)<br>DM9000_iow(oft, <span class="hljs-number">0xff</span>);<br><br><span class="hljs-comment">/* read back mac, just to be sure */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, oft = <span class="hljs-number">0x10</span>; i &lt; <span class="hljs-number">6</span>; i++, oft++)<br>DM9000_DBG(<span class="hljs-string">"%02x:"</span>, DM9000_ior(oft));<br>DM9000_DBG(<span class="hljs-string">"\n"</span>);<br><br><span class="hljs-comment">/* Activate DM9000 */</span><br><span class="hljs-comment">/* RX enable */</span><br>DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);<br><span class="hljs-comment">/* Enable TX/RX interrupt mask */</span><br>DM9000_iow(DM9000_IMR, IMR_PAR);<br><br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!(dm9000_phy_read(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x20</span>)) {<span class="hljs-comment">/* autonegation complete bit */</span><br>udelay(<span class="hljs-number">1000</span>);<br>i++;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">10000</span>) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"could not establish link\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br>}<br><br><span class="hljs-comment">/* see what we've got */</span><br>lnk = dm9000_phy_read(<span class="hljs-number">17</span>) &gt;&gt; <span class="hljs-number">12</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"operating at "</span>);<br><span class="hljs-keyword">switch</span> (lnk) {<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"10M half duplex "</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"10M full duplex "</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"100M half duplex "</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"100M full duplex "</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"unknown: %d "</span>, lnk);<br><span class="hljs-keyword">break</span>;<br>}<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"mode\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着看下<code>NfsStart</code>，首先是获取一些关键参数并打印。设置nfs的一些关键参数，比如要传输的地址，超时等等，设置回调函数<code>NfsHandler</code>，然后<code>NfsSend</code>发送请求。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// net/nfs.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">NfsStart</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>debug(<span class="hljs-string">"%s\n"</span>, __func__);<br>nfs_download_state = NETLOOP_FAIL;<br><br>NfsServerIP = NetServerIP;<br>nfs_path = (<span class="hljs-type">char</span> *)nfs_path_buff;<br><br><span class="hljs-keyword">if</span> (nfs_path == <span class="hljs-literal">NULL</span>) {<br>net_set_state(NETLOOP_FAIL);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"*** ERROR: Fail allocate memory\n"</span>);<br><span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-keyword">if</span> (BootFile[<span class="hljs-number">0</span>] == <span class="hljs-string">'\0'</span>) {<br><span class="hljs-built_in">sprintf</span>(default_filename, <span class="hljs-string">"/nfsroot/%02X%02X%02X%02X.img"</span>,NetOurIP &amp; <span class="hljs-number">0xFF</span>,(NetOurIP &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>,(NetOurIP &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>,(NetOurIP &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xFF</span>);<br><span class="hljs-built_in">strcpy</span>(nfs_path, default_filename);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"*** Warning: no boot file name; using '%s'\n"</span>,nfs_path);<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-type">char</span> *p = BootFile;<br>p = <span class="hljs-built_in">strchr</span>(p, <span class="hljs-string">':'</span>);<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) {<br>NfsServerIP = string_to_ip(BootFile);<br>++p;<br><span class="hljs-built_in">strcpy</span>(nfs_path, p);<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-built_in">strcpy</span>(nfs_path, BootFile);<br>}<br>}<br><br>nfs_filename = basename(nfs_path);<br>nfs_path     = dirname(nfs_path);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Using %s device\n"</span>, eth_get_name());<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"File transfer via NFS from server %pI4"</span> <span class="hljs-string">"; our IP address is %pI4"</span>, &amp;NfsServerIP, &amp;NetOurIP);<br><br><span class="hljs-comment">/* Check if we need to send across this subnet */</span><br><span class="hljs-keyword">if</span> (NetOurGatewayIP &amp;&amp; NetOurSubnetMask) {<br>IPaddr_t OurNet    = NetOurIP  &amp; NetOurSubnetMask;<br>IPaddr_t ServerNet  = NetServerIP &amp; NetOurSubnetMask;<br><br><span class="hljs-keyword">if</span> (OurNet != ServerNet)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"; sending through gateway %pI4"</span>,&amp;NetOurGatewayIP);<br>}<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nFilename '%s/%s'."</span>, nfs_path, nfs_filename);<br><br><span class="hljs-keyword">if</span> (NetBootFileSize) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">" Size is 0x%x Bytes = "</span>, NetBootFileSize&lt;&lt;<span class="hljs-number">9</span>);<br>print_size(NetBootFileSize&lt;&lt;<span class="hljs-number">9</span>, <span class="hljs-string">""</span>);<br>}<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nLoad address: 0x%lx\n"</span> <span class="hljs-string">"Loading: *\b"</span>, load_addr);<br><br>NetSetTimeout(nfs_timeout, NfsTimeout);<br>net_set_udp_handler(NfsHandler);<br><br>NfsTimeoutCount = <span class="hljs-number">0</span>;<br>NfsState = STATE_PRCLOOKUP_PROG_MOUNT_REQ;<br><br><span class="hljs-comment">/*NfsOurPort = 4096 + (get_ticks() % 3072);*/</span><br><span class="hljs-comment">/*FIX ME !!!*/</span><br>NfsOurPort = <span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">/* zero out server ether in case the server ip has changed */</span><br><span class="hljs-built_in">memset</span>(NetServerEther, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>NfsSend();<br>}<br></code></pre></td></tr></tbody></table></figure><p>接着就是<code>eth_rx</code>，由于我们前面已经初始化过<code>dev-&gt;recv = dm9000_rx;</code>所以这个函数中返回也就是调用我们前面初始化的网卡，DM9000的<code>dm9000_rx</code>函数。</p><p>也就是下面那一块，在这个里面完成数据的接收。如要查看接收的数据，可以打开 <code>CONFIG_DM9000_DEBUG</code>开关。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// net/eth.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eth_rx</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br><span class="hljs-keyword">if</span> (!eth_current)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">return</span> eth_current-&gt;recv(eth_current);<br>}<br><br><span class="hljs-comment">// drivers/net/dm9000x.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dm9000_rx</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eth_device *netdev)</span><br>{<br>u8 rxbyte, *rdptr = (u8 *) NetRxPackets[<span class="hljs-number">0</span>];<br>u16 RxStatus, RxLen = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">board_info</span> *<span class="hljs-title">db</span> =</span> &amp;dm9000_info;<br><span class="hljs-comment">/* Check packet ready or not, we must check</span><br><span class="hljs-comment">   the ISR status first for DM9000A */</span><br><span class="hljs-keyword">if</span> (!(DM9000_ior(DM9000_ISR) &amp; <span class="hljs-number">0x01</span>)) <span class="hljs-comment">/* Rx-ISR bit must be set. */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>DM9000_iow(DM9000_ISR, <span class="hljs-number">0x01</span>); <span class="hljs-comment">/* clear PR status latched in bit 0 */</span><br><br><span class="hljs-comment">/* There is _at least_ 1 package in the fifo, read them all */</span><br><span class="hljs-keyword">for</span> (;;) {<br>DM9000_ior(DM9000_MRCMDX);<span class="hljs-comment">/* Dummy read */</span><br><br><span class="hljs-comment">/* Get most updated data,</span><br><span class="hljs-comment">   only look at bits 0:1, See application notes DM9000 */</span><br>rxbyte = DM9000_inb(DM9000_DATA) &amp; <span class="hljs-number">0x03</span>;<br><br><span class="hljs-comment">/* Status check: this byte must be 0 or 1 */</span><br><span class="hljs-keyword">if</span> (rxbyte &gt; DM9000_PKT_RDY) {<br>DM9000_iow(DM9000_RCR, <span class="hljs-number">0x00</span>);<span class="hljs-comment">/* Stop Device */</span><br>DM9000_iow(DM9000_ISR, <span class="hljs-number">0x80</span>);<span class="hljs-comment">/* Stop INT request */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"DM9000 error: status check fail: 0x%x\n"</span>,rxbyte);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-keyword">if</span> (rxbyte != DM9000_PKT_RDY)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* No packet received, ignore */</span><br><br>DM9000_DBG(<span class="hljs-string">"receiving packet\n"</span>);<br><br><span class="hljs-comment">/* A packet ready now  &amp; Get status/length */</span><br>(db-&gt;rx_status)(&amp;RxStatus, &amp;RxLen);<br><br>DM9000_DBG(<span class="hljs-string">"rx status: 0x%04x rx len: %d\n"</span>, RxStatus, RxLen);<br><br><span class="hljs-comment">/* Move data from DM9000 */</span><br><span class="hljs-comment">/* Read received packet from RX SRAM */</span><br>(db-&gt;inblk)(rdptr, RxLen);<br><br><span class="hljs-keyword">if</span> ((RxStatus &amp; <span class="hljs-number">0xbf00</span>) || (RxLen &lt; <span class="hljs-number">0x40</span>)<br>|| (RxLen &gt; DM9000_PKT_MAX)) {<br><span class="hljs-keyword">if</span> (RxStatus &amp; <span class="hljs-number">0x100</span>) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"rx fifo error\n"</span>);<br>}<br><span class="hljs-keyword">if</span> (RxStatus &amp; <span class="hljs-number">0x200</span>) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"rx crc error\n"</span>);<br>}<br><span class="hljs-keyword">if</span> (RxStatus &amp; <span class="hljs-number">0x8000</span>) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"rx length error\n"</span>);<br>}<br><span class="hljs-keyword">if</span> (RxLen &gt; DM9000_PKT_MAX) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"rx length too big\n"</span>);<br>dm9000_reset();<br>}<br>} <span class="hljs-keyword">else</span> {<br>DM9000_DMP_PACKET(__func__ , rdptr, RxLen);<br><br>DM9000_DBG(<span class="hljs-string">"passing packet to upper layer\n"</span>);<br>NetReceive(NetRxPackets[<span class="hljs-number">0</span>], RxLen);<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们接着看下，接收完成呢？又该去干什么了？别忘了，接收只是其中一步，我们在<code>bootcmd</code>中一共有三部分，传送内核到内存20000000处，传送设备树到21000000处，使用bootm启动。现在就当已经接收完成，接着看看后面做了什么。清除接收函数，如果接收的数据大小大于0，设置<code>filesize</code>为接收的数字大小，<code>fileaddr</code>为接收的地址。然后跳转到done处，done处又是清除udp、icmp句柄，然后函数就退出了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// net/net.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">NetLoop</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> <span class="hljs-type">proto_t</span> protocol)</span><br>{<br>...<br>net_cleanup_loop();<br><span class="hljs-keyword">if</span> (NetBootFileXferSize &gt; <span class="hljs-number">0</span>) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Bytes transferred = %ld (%lx hex)\n"</span>,<br>NetBootFileXferSize,<br>NetBootFileXferSize);<br>setenv_hex(<span class="hljs-string">"filesize"</span>, NetBootFileXferSize);<br>setenv_hex(<span class="hljs-string">"fileaddr"</span>, load_addr);<br>}<br>...<br><span class="hljs-keyword">goto</span> done;<br>done:<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_USB_KEYBOARD</span><br>net_busy_flag = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMD_TFTPPUT</span><br><span class="hljs-comment">/* Clear out the handlers */</span><br>net_set_udp_handler(<span class="hljs-literal">NULL</span>);<br>net_set_icmp_handler(<span class="hljs-literal">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> ret;<br>}<br></code></pre></td></tr></tbody></table></figure><p>返回到<code>netboot_common</code>中去继续执行，设置参数，刷新缓存，查看是否要自动开始，也就是环境变量中的<code>autostart</code>为<code>yes</code>时，然后跳转到<code>do_bootm</code>中，此处就不再分析了。</p><p>下面接着分析do_bootm。</p><h6 id="do-bootm"><a href="#do-bootm" class="headerlink" title="do_bootm"></a>do_bootm</h6><p>首先了解一下uImage 和 zImage的区别。</p><blockquote><p>编译kernel之后，会生成Image或者压缩过的zImage。但是这两种镜像的格式并没有办法提供给uboot的足够的信息来进行load、jump或者验证操作等等。因此，uboot提供了mkimage工具，来将kernel制作为uboot可以识别的格式，将生成的文件称之为uImage。<br>uboot支持两种类型的uImage，如下</p><ul><li><p>Legacy-uImage<br>  在kernel镜像的基础上，加上64Byte的信息提供给uboot使用。</p></li><li><p>FIT-uImage<br>  以类似FDT的方式，将kernel、fdt、ramdisk等等镜像打包到一个image file中，并且加上一些需要的信息（属性）。uboot只要获得了这个image file，就可以得到kernel、fdt、ramdisk等等镜像的具体信息和内容。</p></li></ul><p>Legacy-uImage实现较为简单，并且长度较小。但是实际上使用较为麻烦，需要在启动kernel的命令中额外添加fdt、ramdisk的加载信息。<br>而FIT-uImage实现较为复杂，但是使用起来较为简单，兼容性较好,（可以兼容多种配置）。但是需要的额外信息也较长。</p><p>uImage 相较于 zImage 其在头部添加了64bytes <code>image_header</code>用来表示Legacy-uImage的头部</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">image_header</span> {</span><br>    __be32      ih_magic;   <span class="hljs-comment">/* Image Header Magic Number    */</span>   <span class="hljs-comment">// 幻数头，用来校验是否是一个Legacy-uImage</span><br>    __be32      ih_hcrc;    <span class="hljs-comment">/* Image Header CRC Checksum    */</span> <span class="hljs-comment">// 头部的CRC校验值</span><br>    __be32      ih_time;    <span class="hljs-comment">/* Image Creation Timestamp */</span> <span class="hljs-comment">// 镜像创建的时间戳</span><br>    __be32      ih_size;    <span class="hljs-comment">/* Image Data Size      */</span> <span class="hljs-comment">// 镜像数据长度</span><br>    __be32      ih_load;    <span class="hljs-comment">/* Data  Load  Address      */</span> <span class="hljs-comment">// 加载地址</span><br>    __be32      ih_ep;      <span class="hljs-comment">/* Entry Point Address      */</span> <span class="hljs-comment">// 入口地址</span><br>    __be32      ih_dcrc;    <span class="hljs-comment">/* Image Data CRC Checksum  */</span> <span class="hljs-comment">// 镜像的CRC校验</span><br>    <span class="hljs-type">uint8_t</span>     ih_os;      <span class="hljs-comment">/* Operating System     */</span> <span class="hljs-comment">// 操作系统类型</span><br>    <span class="hljs-type">uint8_t</span>     ih_arch;    <span class="hljs-comment">/* CPU architecture     */</span> <span class="hljs-comment">// 体系 </span><br>    <span class="hljs-type">uint8_t</span>     ih_type;    <span class="hljs-comment">/* Image Type           */</span> <span class="hljs-comment">// 镜像类型</span><br>    <span class="hljs-type">uint8_t</span>     ih_comp;    <span class="hljs-comment">/* Compression Type     */</span> <span class="hljs-comment">// 压缩类型</span><br>    <span class="hljs-type">uint8_t</span>     ih_name[IH_NMLEN];  <span class="hljs-comment">/* Image Name       */</span> <span class="hljs-comment">// 镜像名</span><br>} <span class="hljs-type">image_header_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IH_NMLEN        32  <span class="hljs-comment">/* Image Name Length        */</span></span><br></code></pre></td></tr></tbody></table></figure><p>通过比较编译出的uImage和zImage，其大小符合上述我们说的，并且可以通过这64字节得到</p><ul><li><p>ih_magic 0x27051956 幻术头</p></li><li><p>ih_size 003fe868 4188264 zImage大小</p></li><li><p>ih_load 0x20008000 数据加载地址</p></li><li><p>ih_ep 0x20008000 入口地址</p></li><li><p>etc</p><p>  <img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204241433964.png"></p></li></ul></blockquote><p>bootm 格式如下</p><p><code>bootm Legacy-uImage加载地址 ramdisk加载地址 dtb加载地址</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 假设Legacy-uImage的加载地址是0x20008000，ramdisk的加载地址是0x21000000，fdt的加载地址是0x22000000</span><br><br><span class="hljs-comment">// 1.只加载kernel的情况下</span><br>bootm <span class="hljs-number">0x20008000</span><br><br><span class="hljs-comment">// 2. 加载kernel和ramdisk</span><br>bootm <span class="hljs-number">0x20008000</span> <span class="hljs-number">0x21000000</span><br><br><span class="hljs-comment">// 3.加载kernel和fdt</span><br>bootm <span class="hljs-number">0x20008000</span> - <span class="hljs-number">0x22000000</span><br><br><span class="hljs-comment">// 4.加载kernel、ramdisk、fdt</span><br>bootm <span class="hljs-number">0x20008000</span> <span class="hljs-number">0x21000000</span> <span class="hljs-number">0x22000000</span><br></code></pre></td></tr></tbody></table></figure><p>看一下do_bootm的代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">do_bootm</span><span class="hljs-params">(<span class="hljs-type">cmd_tbl_t</span> *cmdtp, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[])</span><br>{<br>debug(<span class="hljs-string">"argc:%d\r\n"</span>,argc);<br><span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(;idx&lt;argc;idx++){<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"argv[%d]:%s\r\n"</span>,idx,argv[idx]);<br>}<br><span class="hljs-comment">//  在这里，bootm的第一个参数会被去掉。</span><br>        <span class="hljs-comment">//  也就是当"bootm 0x20000000 - 0x21000000 "时，</span><br>        <span class="hljs-comment">//  argc = 3，argv[0] = "0x20000000"，argv[1]= "-"，argv[2]="0x21000000"</span><br>        <span class="hljs-comment">//  当"bootm 0x20000000"时，argc=1，argv[0]="0x20000000"</span><br>argc--; argv++;<br><span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">0</span>) {<br><span class="hljs-type">char</span> *endp;<br>simple_strtoul(argv[<span class="hljs-number">0</span>], &amp;endp, <span class="hljs-number">16</span>);<br><span class="hljs-keyword">if</span> ((*endp != <span class="hljs-number">0</span>) &amp;&amp; (*endp != <span class="hljs-string">':'</span>) &amp;&amp; (*endp != <span class="hljs-string">'#'</span>)) <span class="hljs-comment">// 判断是否有子命令，这里我们不管。</span><br><span class="hljs-keyword">return</span> do_bootm_subcommand(cmdtp, flag, argc, argv);<br>}<br><br><span class="hljs-keyword">return</span> do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |<br>BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |<br>BOOTM_STATE_LOADOS |<br>BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |<br>BOOTM_STATE_OS_GO, &amp;images, <span class="hljs-number">1</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过日志可得，其传入的参数也就是我们在bootcmd中配置的bootm及其参数，也就是加载在0x20000000处的kernel和0x21000000处的设备树。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[File:common/cmd_bootm.c, Line:797, Function:do_bootm] argc:4<br>argv[0]:bootm<br>argv[1]:20000000<br>argv[2]:-<br>argv[3]:21000000<br></code></pre></td></tr></tbody></table></figure><p>最后，跳转到 <code>do_bootm_states</code>中，此时标志有 </p><ul><li>BOOTM_STATE_START</li><li>BOOTM_STATE_FINDOS</li><li>BOOTM_STATE_FINDOTHER</li><li>BOOTM_STATE_LOADOS</li><li>BOOTM_STATE_OS_PREP</li><li>BOOTM_STATE_OS_FAKE_GO</li><li>BOOTM_STATE_OS_GO</li></ul><p>还有一个全局参数 <code>images</code>的地址，而<code>images</code>的格式是<code>struct bootm_headers</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">do_bootm<br>    |<br>    --&gt; do_bootm_states<br></code></pre></td></tr></tbody></table></figure><p><code>struct bootm_headers</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bootm_headers</span> {</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Legacy os image header, if it is a multi component image</span><br><span class="hljs-comment"> * then boot_get_ramdisk() and get_fdt() will attempt to get</span><br><span class="hljs-comment"> * data from second and third component accordingly.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">image_header_t</span>*legacy_hdr_os;<span class="hljs-comment">/* image header pointer */</span> <span class="hljs-comment">//Legacy-uImage的镜像头</span><br><span class="hljs-type">image_header_t</span>legacy_hdr_os_copy;<span class="hljs-comment">/* header copy */</span><span class="hljs-comment">//Legacy-uImage的镜像头备份</span><br>ulonglegacy_hdr_valid;<span class="hljs-comment">// Legacy-uImage的镜像头是否存在的标记</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_FIT)</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*fit_uname_cfg;<span class="hljs-comment">/* configuration node unit name */</span>     <span class="hljs-comment">// 配置节点名</span><br><br><span class="hljs-type">void</span>*fit_hdr_os;<span class="hljs-comment">/* os FIT image header */</span><span class="hljs-comment">// FIT-uImage中kernel镜像头</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*fit_uname_os;<span class="hljs-comment">/* os subimage node unit name */</span>   <span class="hljs-comment">// FIT-uImage中kernel的节点名</span><br><span class="hljs-type">int</span>fit_noffset_os;<span class="hljs-comment">/* os subimage node offset */</span>             <span class="hljs-comment">//  FIT-uImage中kernel的节点偏移</span><br><br><span class="hljs-type">void</span>*fit_hdr_rd;<span class="hljs-comment">/* init ramdisk FIT image header */</span> <span class="hljs-comment">// FIT-uImage中ramdisk的镜像头</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*fit_uname_rd;<span class="hljs-comment">/* init ramdisk subimage node unit name */</span> <span class="hljs-comment">// FIT-uImage中ramdisk的节点名</span><br><span class="hljs-type">int</span>fit_noffset_rd;<span class="hljs-comment">/* init ramdisk subimage node offset */</span>       <span class="hljs-comment">// FIT-uImage中ramdisk的节点偏移</span><br><br><span class="hljs-type">void</span>*fit_hdr_fdt;<span class="hljs-comment">/* FDT blob FIT image header */</span>      <span class="hljs-comment">// FIT-uImage中FDT的镜像头</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*fit_uname_fdt;<span class="hljs-comment">/* FDT blob subimage node unit name */</span><span class="hljs-comment">// FIT-uImage中FDT的节点名</span><br><span class="hljs-type">int</span>fit_noffset_fdt;<span class="hljs-comment">/* FDT blob subimage node offset */</span>  <span class="hljs-comment">// FIT-uImage中ramdisk的节点偏移</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> USE_HOSTCC</span><br><span class="hljs-type">image_info_t</span>os;<span class="hljs-comment">/* os image info */</span><span class="hljs-comment">// 操作系统信息的结构体</span><br>ulongep;<span class="hljs-comment">/* entry point of OS */</span><span class="hljs-comment">// 操作系统的入口地址</span><br><br>ulongrd_start, rd_end;<span class="hljs-comment">/* ramdisk start/end */</span><span class="hljs-comment">// ramdisk在内存上的起始地址和结束地址</span><br><br><span class="hljs-type">char</span>*ft_addr;<span class="hljs-comment">/* flat dev tree address */</span><span class="hljs-comment">// fdt在内存上的地址</span><br>ulongft_len;<span class="hljs-comment">/* length of flat device tree */</span>     <span class="hljs-comment">// fdt在内存上的长度</span><br><br>ulonginitrd_start;<br>ulonginitrd_end;<br>ulongcmdline_start;<br>ulongcmdline_end;<br><span class="hljs-type">bd_t</span>*kbd;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span>verify;<span class="hljs-comment">/* getenv("verify")[0] != 'n' */</span>   <span class="hljs-comment">// 是否需要验证</span><br><span class="hljs-type">int</span>state;<span class="hljs-comment">// 状态标识，用于标识对应的bootm需要做什么操作，具体看下面宏</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_LMB</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lmb</span><span class="hljs-title">lmb</span>;</span><span class="hljs-comment">/* for memory mgmt */</span>   <span class="hljs-comment">// 内存管理 </span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>} <span class="hljs-type">bootm_headers_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_START(0x00000001) <span class="hljs-comment">//开始执行bootm的准备动作</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_FINDOS(0x00000002) <span class="hljs-comment">// 查找操作系统镜像</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_FINDOTHER(0x00000004)       <span class="hljs-comment">// 查找操作系统镜像外的其他镜像，比如FDT/ramdisk等</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_LOADOS(0x00000008) <span class="hljs-comment">// 加载操作系统</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_RAMDISK(0x00000010)<span class="hljs-comment">// 操作ramdisk</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_FDT(0x00000020)   <span class="hljs-comment">// 操作FDT</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_OS_CMDLINE(0x00000040)<span class="hljs-comment">// 操作commandline</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_OS_BD_T(0x00000080)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_OS_PREP(0x00000100)<span class="hljs-comment">// 跳转到操作系统前的准备动作</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_OS_FAKE_GO(0x00000200)<span class="hljs-comment">// 伪跳转，一般都能直接跳转到kernel中去</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>BOOTM_STATE_OS_GO(0x00000400)  <span class="hljs-comment">// 跳转到kernel中去</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">bootm_headers_t</span> images;<br></code></pre></td></tr></tbody></table></figure><p><code>do_bootm_states</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_bootm_states</span><span class="hljs-params">(<span class="hljs-type">cmd_tbl_t</span> *cmdtp, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> argc,</span><br><span class="hljs-params"><span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[], <span class="hljs-type">int</span> states, <span class="hljs-type">bootm_headers_t</span> *images,</span><br><span class="hljs-params"><span class="hljs-type">int</span> boot_progress)</span><br>{<br>boot_os_fn *boot_fn;<br>ulong iflag = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, need_boot_fn;<br><span class="hljs-comment">// 更新images-&gt;state中的状态标志</span><br>images-&gt;state |= states;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Work through the states and see how far we get. We stop on</span><br><span class="hljs-comment"> * any error.</span><br><span class="hljs-comment"> */</span><br>         <span class="hljs-comment">// 判断当前状态是否有BOOTM_STATE_START，也就是是否需要执行前的准备动作，如果需要则调用bootm_start</span><br><span class="hljs-keyword">if</span> (states &amp; BOOTM_STATE_START)<br>ret = bootm_start(cmdtp, flag, argc, argv);<br><span class="hljs-comment">// 判断当前状态是否有BOOTM_STATE_FINDOS，也就是是否需要执行查找OS，如果需要则调用 bootm_find_os，注意此步是紧接着上一步的</span><br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))<br>ret = bootm_find_os(cmdtp, flag, argc, argv);<br><span class="hljs-comment">// 判断当前状态是否有BOOTM_STATE_FINDOTHER，也就是是否需要执行查找其它FDT/ramdisk等，如果需要则调用bootm_find_other，注意此步是紧接着上一步的</span><br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER)) {<br>ret = bootm_find_other(cmdtp, flag, argc, argv);<br>argc = <span class="hljs-number">0</span>;<span class="hljs-comment">/* consume the args */</span><br>}<br><br>        <span class="hljs-comment">// 注意：之前都是查找os，查找fdt等填充images中的结构，下面则是利用images中的结构数据。</span><br><span class="hljs-comment">/* Load the OS */</span><br>         <span class="hljs-comment">// 判断当前状态是否有BOOTM_STATE_LOADOS，也就是是否需要执行加载OS，如果需要则调用bootm_load_os，注意此步是紧接着上一步的</span><br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_LOADOS)) {<br>ulong load_end;<br><br>iflag = bootm_disable_interrupts();<br>ret = bootm_load_os(images, &amp;load_end, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>lmb_reserve(&amp;images-&gt;lmb, images-&gt;os.load,<br>    (load_end - images-&gt;os.load));<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &amp;&amp; ret != BOOTM_ERR_OVERLAP)<br><span class="hljs-keyword">goto</span> err;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == BOOTM_ERR_OVERLAP)<br>ret = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SILENT_CONSOLE) &amp;&amp; !defined(CONFIG_SILENT_U_BOOT_ONLY)</span><br><span class="hljs-keyword">if</span> (images-&gt;os.os == IH_OS_LINUX)<br>fixup_silent_linux();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br><br><span class="hljs-comment">/* Relocate the ramdisk */</span> <span class="hljs-comment">// 是否需要重定向ramdinsk，do_bootm流程的话是不需要的</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYS_BOOT_RAMDISK_HIGH</span><br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_RAMDISK)) {<br>ulong rd_len = images-&gt;rd_end - images-&gt;rd_start;<br><br>ret = boot_ramdisk_high(&amp;images-&gt;lmb, images-&gt;rd_start,<br>rd_len, &amp;images-&gt;initrd_start, &amp;images-&gt;initrd_end);<br><span class="hljs-keyword">if</span> (!ret) {<br>setenv_hex(<span class="hljs-string">"initrd_start"</span>, images-&gt;initrd_start);<br>setenv_hex(<span class="hljs-string">"initrd_end"</span>, images-&gt;initrd_end);<br>}<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_OF_LIBFDT) &amp;&amp; defined(CONFIG_LMB)</span><br>         <span class="hljs-comment">// 是否需要重定向fdt，do_bootm流程的话是不需要的</span><br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FDT)) {<br>boot_fdt_add_mem_rsv_regions(&amp;images-&gt;lmb, images-&gt;ft_addr);<br>ret = boot_relocate_fdt(&amp;images-&gt;lmb, &amp;images-&gt;ft_addr,<br>&amp;images-&gt;ft_len);<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* From now on, we need the OS boot function */</span><br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br>        <span class="hljs-comment">// 获取对应操作系统的启动函数，存放到boot_fn中</span><br>boot_fn = boot_os[images-&gt;os.os];<br>need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |<br>BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |<br>BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);<br><span class="hljs-keyword">if</span> (boot_fn == <span class="hljs-literal">NULL</span> &amp;&amp; need_boot_fn) {<br><span class="hljs-keyword">if</span> (iflag)<br>enable_interrupts();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"ERROR: booting os '%s' (%d) is not supported\n"</span>,<br>       genimg_get_os_name(images-&gt;os.os), images-&gt;os.os);<br>bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-comment">/* Call various other states that are not generally used */</span><br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE))<br>ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);<br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T))<br>ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);<br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP))<span class="hljs-comment">// 判断当前状态是否有BOOTM_STATE_OS_PREP，也就是跳转前的最后准备动作，如果需要则调用boot_fn</span><br>ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TRACE</span><br> <span class="hljs-comment">// 判断当前状态是否有BOOTM_STATE_OS_FAKE_GO，伪跳转到操作系统。</span><br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) {<br><span class="hljs-type">char</span> *cmd_list = getenv(<span class="hljs-string">"fakegocmd"</span>);<br><br>ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,<br>images, boot_fn);<br><span class="hljs-keyword">if</span> (!ret &amp;&amp; cmd_list)<br>ret = run_command_list(cmd_list, <span class="hljs-number">-1</span>, flag);<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* Check for unsupported subcommand. */</span><br><span class="hljs-keyword">if</span> (ret) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"subcommand not supported\n"</span>);<br><span class="hljs-keyword">return</span> ret;<br>}<br><br><span class="hljs-comment">/* Now run the OS! We hope this doesn't return */</span> <span class="hljs-comment">// 判断当前状态是否有BOOTM_STATE_OS_GO，也就是现在直接跳转到SO，并且不需要返回</span><br><span class="hljs-keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))<br>ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,<br>images, boot_fn);<br><br><span class="hljs-comment">/* Deal with any fallout */</span><br>err:<br><span class="hljs-keyword">if</span> (iflag)<br>enable_interrupts();<br><br><span class="hljs-keyword">if</span> (ret == BOOTM_ERR_UNIMPLEMENTED)<br>bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == BOOTM_ERR_RESET)<br>do_reset(cmdtp, flag, argc, argv);<br><br><span class="hljs-keyword">return</span> ret;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>BOOTM_STATE_START</strong></p><p>bootm_start，简单看一下，其实也就是初始化<code>bootm_headers_t images</code>，也就是从环境变量中获取 <code>verify</code>对应的value，然后返回0或1，赋值给<code>images.verify</code>。配置images中的内存保留区域，标记images中的当前状态。</p><p><strong>实现verify和lmb</strong></p><blockquote><p>LMB是指logical memory blocks，主要是用于表示内存的保留区域，主要有fdt的区域，ramdisk的区域等等。</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/cmd_bootm.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bootm_start</span><span class="hljs-params">(<span class="hljs-type">cmd_tbl_t</span> *cmdtp, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[])</span><br>{<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)&amp;images, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(images));<br>images.verify = getenv_yesno(<span class="hljs-string">"verify"</span>);<br><br>boot_start_lmb(&amp;images);<br><br>bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, <span class="hljs-string">"bootm_start"</span>);<br>images.state = BOOTM_STATE_START;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">// ----------------------------------------------------------------------------------------------------------</span><br><span class="hljs-comment">// common/cmd_bootm.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">boot_start_lmb</span><span class="hljs-params">(<span class="hljs-type">bootm_headers_t</span> *images)</span><br>{<br>ulongmem_start;<br><span class="hljs-type">phys_size_t</span>mem_size;<br><span class="hljs-comment">// 先初始化images的lmb内存管理，注意cnt为1</span><br>lmb_init(&amp;images-&gt;lmb);<br><span class="hljs-comment">// 然后从环境变量中获取bootm_low，我们的板子上没有但是定义了CONFIG_SYS_SDRAM_BASE，所以此处返回 CONFIG_SYS_SDRAM_BASE</span><br>mem_start = getenv_bootm_low();<br>mem_size = getenv_bootm_size(); <span class="hljs-comment">// 从环境变量中获取 bootm_size，但是我们的板子上又没有，所以此函数中tmp为0，然后CONFIG_ARM有定义，所以此处的值为 gd-&gt;bd-&gt;bi_dram[0].size - tmp，也就是 gd-&gt;bd-&gt;bi_dram[0].size，也就是 PHYS_SDRAM_1_SIZE</span><br><span class="hljs-comment">// 此处也就是将 mem_start, mem_size，配置到images-&gt;lmb中，在此处会用到cnt=1</span><br>lmb_add(&amp;images-&gt;lmb, (<span class="hljs-type">phys_addr_t</span>)mem_start, mem_size);<br><span class="hljs-comment">// 这两个函数的作用暂时不理解</span><br>arch_lmb_reserve(&amp;images-&gt;lmb);<br>board_lmb_reserve(&amp;images-&gt;lmb);<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>BOOTM_STATE_FINDOS</strong></p><p>bootm_find_os，主要是验证内核，从<code>bootm</code>命令及<code>image_header</code>中获取内核信息并更新到<code>images</code>。</p><p>实现os和ep。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bootm_find_os</span><span class="hljs-params">(<span class="hljs-type">cmd_tbl_t</span> *cmdtp, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> argc,</span><br><span class="hljs-params"> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[])</span><br>{<br><span class="hljs-type">const</span> <span class="hljs-type">void</span> *os_hdr;<br><br><span class="hljs-comment">/* get kernel image header, start address and length */</span><br><span class="hljs-comment">// 验证内核，获取kernel起始地址和长度</span><br>os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,<br>&amp;images, &amp;images.os.image_start, &amp;images.os.image_len);<br><span class="hljs-keyword">if</span> (images.os.image_len == <span class="hljs-number">0</span>) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"ERROR: can't get kernel image!\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-comment">/* get image parameters */</span> <br><span class="hljs-comment">// 更新images中的参数</span><br><span class="hljs-keyword">switch</span> (genimg_get_format(os_hdr)) {<br><span class="hljs-keyword">case</span> IMAGE_FORMAT_LEGACY:<br>images.os.type = image_get_type(os_hdr);<br>images.os.comp = image_get_comp(os_hdr);<br>images.os.os = image_get_os(os_hdr);<br><br>images.os.end = image_get_image_end(os_hdr);<br>images.os.load = image_get_load(os_hdr);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_FIT)</span><br><span class="hljs-keyword">case</span> IMAGE_FORMAT_FIT:<br><span class="hljs-keyword">if</span> (fit_image_get_type(images.fit_hdr_os,<br>images.fit_noffset_os, &amp;images.os.type)) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Can't get image type!\n"</span>);<br>bootstage_error(BOOTSTAGE_ID_FIT_TYPE);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-keyword">if</span> (fit_image_get_comp(images.fit_hdr_os,<br>images.fit_noffset_os, &amp;images.os.comp)) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Can't get image compression!\n"</span>);<br>bootstage_error(BOOTSTAGE_ID_FIT_COMPRESSION);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-keyword">if</span> (fit_image_get_os(images.fit_hdr_os,<br>images.fit_noffset_os, &amp;images.os.os)) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Can't get image OS!\n"</span>);<br>bootstage_error(BOOTSTAGE_ID_FIT_OS);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br>images.os.end = fit_get_end(images.fit_hdr_os);<br><br><span class="hljs-keyword">if</span> (fit_image_get_load(images.fit_hdr_os, images.fit_noffset_os,<br>&amp;images.os.load)) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Can't get image load address!\n"</span>);<br>bootstage_error(BOOTSTAGE_ID_FIT_LOADADDR);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"ERROR: unknown image format type!\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-comment">/* find kernel entry point */</span> <br><span class="hljs-comment">// 获取内核的entry point</span><br><span class="hljs-keyword">if</span> (images.legacy_hdr_valid) {<br>images.ep = image_get_ep(&amp;images.legacy_hdr_os_copy);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_FIT)</span><br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (images.fit_uname_os) {<br><span class="hljs-type">int</span> ret;<br><br>ret = fit_image_get_entry(images.fit_hdr_os,<br>  images.fit_noffset_os, &amp;images.ep);<br><span class="hljs-keyword">if</span> (ret) {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Can't get entry point property!\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Could not find kernel entry point!\n"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-keyword">if</span> (images.os.type == IH_TYPE_KERNEL_NOLOAD) {<br>images.os.load = images.os.image_start;<br>images.ep += images.os.load;<br>}<br><br>images.os.start = (ulong)os_hdr;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>BOOTM_STATE_FINDOTHER</strong></p><p>bootm_find_other</p><p>实现rd_start，rd_end，ft_addr和initrd_end。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bootm_find_other</span><span class="hljs-params">(<span class="hljs-type">cmd_tbl_t</span> *cmdtp, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> argc,</span><br><span class="hljs-params">    <span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[])</span><br>{<br><span class="hljs-keyword">if</span> (((images.os.type == IH_TYPE_KERNEL) ||<br>     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||<br>     (images.os.type == IH_TYPE_MULTI)) &amp;&amp;<br>    (images.os.os == IH_OS_LINUX ||<br> images.os.os == IH_OS_VXWORKS)) {<br><span class="hljs-keyword">if</span> (bootm_find_ramdisk(flag, argc, argv))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_OF_LIBFDT)</span><br><span class="hljs-keyword">if</span> (bootm_find_fdt(flag, argc, argv))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>先看<code>bootm_find_ramdisk</code>，由于我们在bootm中传递的ramfs值为<code>-</code>，也就是忽略ramfs的意思，所以会直接跳过，详见下面的日志。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[File:common/image.c, Line:814, Function:boot_get_ramdisk] ## Skipping init Ramdisk<br>[File:common/image.c, Line:944, Function:boot_get_ramdisk] ## No init Ramdisk<br>[File:common/image.c, Line:950, Function:boot_get_ramdisk]    ramdisk start = 0x00000000, ramdisk end = 0x00000000<br></code></pre></td></tr></tbody></table></figure><p>接着看一下<code>bootm_find_fdt</code>，无非就是验证bootm中的第三个参数以及是否可用，并确认设备树的类型，根据日志对应着代码看就可，此处不在展开说。</p><p>另外，此处会把</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">[File:common/image-fdt.c, Line:<span class="hljs-number">271</span>, Function:boot_get_fdt] *  fdt: cmdline image address = <span class="hljs-number">0x21000000</span><br>[File:common/image-fdt.c, Line:<span class="hljs-number">289</span>, Function:boot_get_fdt] ## Checking <span class="hljs-keyword">for</span> <span class="hljs-string">'FDT'</span>/<span class="hljs-string">'FDT Image'</span> at <span class="hljs-number">21000000</span><br>[File:common/image-fdt.c, Line:<span class="hljs-number">370</span>, Function:boot_get_fdt] *  fdt: raw FDT blob<br>## Flattened Device Tree blob at <span class="hljs-number">21000000</span><br>   Booting using the fdt blob at <span class="hljs-number">0x21000000</span><br></code></pre></td></tr></tbody></table></figure><p><strong>BOOTM_STATE_LOADOS</strong></p><p>bootm_load_os</p><p>在<a href="#do_bootm">do_bootm</a>中可知uImage header的定义，所以我们可以得出镜像压缩类型值为0，此处也即走<code>IH_COMP_NONE</code>分支，所以会有如下打印</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">   Loading Kernel Image ... OK<br>[File:common/cmd_bootm.c, Line:481, Function:bootm_load_os]    kernel loaded at 0x20008000, end = 0x20406868<br>[File:common/cmd_bootm.c, Line:486, Function:bootm_load_os] images.os.start = 0x20000000, images.os.end = 0x203fe8a8<br>[File:common/cmd_bootm.c, Line:488, Function:bootm_load_os] images.os.load = 0x20008000, load_end = 0x20406868<br></code></pre></td></tr></tbody></table></figure><p>精简一下代码，去掉不走的分支，如下，此处功能就是通过<code>images</code>获得镜像信息，看是否需要解压镜像，验证类型等。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/cmd_bootm.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bootm_load_os</span><span class="hljs-params">(<span class="hljs-type">bootm_headers_t</span> *images, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *load_end,</span><br><span class="hljs-params"><span class="hljs-type">int</span> boot_progress)</span><br>{<br><span class="hljs-type">image_info_t</span> os = images-&gt;os;<br><span class="hljs-type">uint8_t</span> comp = os.comp;<br>ulong load = os.load;<br>ulong blob_start = os.start;<br>ulong blob_end = os.end;<br>ulong image_start = os.image_start;<br>ulong image_len = os.image_len;<br>__maybe_unused uint unc_len = CONFIG_SYS_BOOTM_LEN;<br><span class="hljs-type">int</span> no_overlap = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> *load_buf, *image_buf;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_LZMA) || defined(CONFIG_LZO)</span><br><span class="hljs-type">int</span> ret;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *type_name = genimg_get_type_name(os.type);<br><br>load_buf = map_sysmem(load, unc_len);<br>image_buf = map_sysmem(image_start, image_len);<br><span class="hljs-keyword">switch</span> (comp) {<br><span class="hljs-keyword">case</span> IH_COMP_NONE:<br><span class="hljs-keyword">if</span> (load == blob_start || load == image_start) {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"   XIP %s ... "</span>, type_name);<br>no_overlap = <span class="hljs-number">1</span>;<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"   Loading %s ... "</span>, type_name);<br>memmove_wd(load_buf, image_buf, image_len, CHUNKSZ);<br>}<br>*load_end = load + image_len;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GZIP</span><br><span class="hljs-keyword">case</span> IH_COMP_GZIP:<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_GZIP */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BZIP2</span><br><span class="hljs-keyword">case</span> IH_COMP_BZIP2:<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_BZIP2 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_LZMA</span><br><span class="hljs-keyword">case</span> IH_COMP_LZMA: <br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_LZMA */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_LZO</span><br><span class="hljs-keyword">case</span> IH_COMP_LZO: <br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_LZO */</span></span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Unimplemented compression type %d\n"</span>, comp);<br><span class="hljs-keyword">return</span> BOOTM_ERR_UNIMPLEMENTED;<br>}<br><br>flush_cache(load, (*load_end - load) * <span class="hljs-keyword">sizeof</span>(ulong));<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"OK\n"</span>);<br>debug(<span class="hljs-string">"   kernel loaded at 0x%08lx, end = 0x%08lx\n"</span>, load, *load_end);<br>bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);<br><br><span class="hljs-keyword">if</span> (!no_overlap &amp;&amp; (load &lt; blob_end) &amp;&amp; (*load_end &gt; blob_start)) {<br>debug(<span class="hljs-string">"images.os.start = 0x%lX, images.os.end = 0x%lx\n"</span>,blob_start, blob_end);<br>debug(<span class="hljs-string">"images.os.load = 0x%lx, load_end = 0x%lx\n"</span>, load,*load_end);<br><br><span class="hljs-comment">/* Check what type of image this is. */</span><br><span class="hljs-keyword">if</span> (images-&gt;legacy_hdr_valid) {<br><span class="hljs-keyword">if</span> (image_get_type(&amp;images-&gt;legacy_hdr_os_copy)== IH_TYPE_MULTI)<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"WARNING: legacy format multi component image overwritten\n"</span>);<br><span class="hljs-keyword">return</span> BOOTM_ERR_OVERLAP;<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"ERROR: new format image overwritten - must RESET the board to recover\n"</span>);<br>bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);<br><span class="hljs-keyword">return</span> BOOTM_ERR_RESET;<br>}<br>}<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>回到 do_bootm_states函数，调用<code>lmb_reserve</code>对剩余的内存进行管理。</p><p><code>BOOTM_STATE_RAMDISK</code></p><p>接着调用<code>boot_ramdisk_high</code>，然而其中的rd_data为0，所以整个函数退出。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[File:common/image.c, Line:1003, Function:boot_ramdisk_high] ## initrd_high = 0xffffffff, copy_to_ram = 1<br>[File:common/image.c, Line:1047, Function:boot_ramdisk_high]    ramdisk load start = 0x00000000, ramdisk load end = 0x00000000<br></code></pre></td></tr></tbody></table></figure><p><code>BOOTM_STATE_FDT</code> </p><p>验证FDT，将代码从<code>21000000</code>重定位到<code>3fe30000</code>处。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[File:common/image-fdt.c, Line:175, Function:boot_relocate_fdt] ## device tree at 21000000 ... 210063a5 (len=37798 [0x93A6])<br>   Loading Device Tree to 3fe30000, end 3fe393a5 ... OK<br></code></pre></td></tr></tbody></table></figure><p>接着配置<code>boot_fn</code>，由于是<code>images-&gt;os.os</code>为1，也就是linux，所以 <code>boot_fn=do_bootm_linux</code></p><p>由于上面 states 中含有这几个标志，</p><ul><li>BOOTM_STATE_START</li><li>BOOTM_STATE_FINDOS</li><li>BOOTM_STATE_FINDOTHER</li><li>BOOTM_STATE_LOADOS</li><li>BOOTM_STATE_OS_PREP</li><li>BOOTM_STATE_OS_FAKE_GO</li><li>BOOTM_STATE_OS_GO</li></ul><p>当前要配置的状态有</p><ul><li>BOOTM_STATE_OS_CMDLINE</li><li>BOOTM_STATE_OS_BD_T</li><li>BOOTM_STATE_OS_PREP</li><li>BOOTM_STATE_OS_FAKE_GO</li><li>BOOTM_STATE_OS_GO</li></ul><p><code>need_boot_fn</code>状态为二者共有的，也即BOOTM_STATE_OS_PREP、BOOTM_STATE_OS_FAKE_GO、BOOTM_STATE_OS_GO</p><p>所以，接着会调用 <code>do_bootm_linux(BOOTM_STATE_OS_PREP, argc, argv, images);</code></p><p>也就是会调用 <code>boot_jump_linux</code></p><p>看下 <code>boot_jump_linux</code>，我们是32位的ARM，所以删掉64位的代码。直接看剩下的，获取设备id，并从环境变量中获取<code>machid</code>对应的value，打印。</p><p>然后定义一个函数指针，有三个参数，其类型分别为 <code>int, int, uint</code>，</p><blockquote><p>内核启动之前要求r0为0，r1为machid，r2为atags或设备树地址。</p></blockquote><p>所以对应的为r0，r1，r2。</p><p>然后<code>kernel_entry(0, machid, r2)</code>也就是直接执行内核entry point处的代码，换句话说也就是跳转到了kernel中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">boot_jump_linux</span><span class="hljs-params">(<span class="hljs-type">bootm_headers_t</span> *images, <span class="hljs-type">int</span> flag)</span><br>{<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARM64</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> machid = gd-&gt;bd-&gt;bi_arch_number;<br><span class="hljs-type">char</span> *s;<br><span class="hljs-type">void</span> (*kernel_entry)(<span class="hljs-type">int</span> zero, <span class="hljs-type">int</span> arch, uint params);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r2;<br><span class="hljs-type">int</span> fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);<br><br>kernel_entry = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, uint))images-&gt;ep;<br><br>s = getenv(<span class="hljs-string">"machid"</span>);<br><span class="hljs-keyword">if</span> (s) {<br>strict_strtoul(s, <span class="hljs-number">16</span>, &amp;machid);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Using machid 0x%lx from environment\n"</span>, machid);<br>}<br><br>debug(<span class="hljs-string">"## Transferring control to Linux (at address %08lx)"</span> <span class="hljs-string">"...\n"</span>, (ulong) kernel_entry);<br>bootstage_mark(BOOTSTAGE_ID_RUN_OS);<br>announce_and_cleanup(fake);<br><br><span class="hljs-keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len)<br>r2 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)images-&gt;ft_addr;<br><span class="hljs-keyword">else</span><br>r2 = gd-&gt;bd-&gt;bi_boot_params;<br><br><span class="hljs-keyword">if</span> (!fake)<br>kernel_entry(<span class="hljs-number">0</span>, machid, r2);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.wowotech.net/u-boot/boot_flow_1.html">wowo的u-boot启动流程分析（1）平台相关部分_</a></li><li><a href="https://blog.csdn.net/ooonebook/category_6471981.html">ooonebook大佬的project-X系列</a></li><li><a href="https://blog.csdn.net/ooonebook/category_6484145.html">ooonebook大佬的u-boot系列</a></li><li><a href="https://github.com/limingth/ARM-Resources/blob/master/tiny210/Datasheet/S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf">S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</a></li><li><a href="https://github.com/limingth/ARM-Resources/blob/master/tiny210/Datasheet/S5PV210_UM_REV1.1.pdf">S5PV210_UM_REV1.1.pdf</a></li><li><a href="https://re-eject.gbadev.org/files/GasARMRef.pdf">https://re-eject.gbadev.org/files/GasARMRef.pdf</a></li><li><a href="https://blog.csdn.net/weixin_55796564/article/details/119949722">第三十二章 U-Boot启动流程详解 -摘自【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.0</a></li><li><a href="https://blog.csdn.net/u012176730/article/details/54670569">嵌入式Linux学习：u-boot源码分析（1）–AM335X系列的2014.10版</a></li><li><a href="https://blog.csdn.net/qq_40531974/article/details/83897559">ARM汇编指令集汇总</a></li><li><a href="https://blog.csdn.net/zhouqt/article/details/78172332">ARM指令CMP详解</a></li><li><a href="https://www.cnblogs.com/zackary/p/9343253.html"></a><a href="https://www.cnblogs.com/zackary/p/9343253.html">ARM 汇编指令 ADR 与 LDR 使用 </a></li><li><a href="https://0uyangsheng.github.io/2018/04/25/Deep-into-Rk3399-uboot/">谈谈 U-boot 启动流程</a></li><li><a href="https://blog.csdn.net/gzxb1995/article/details/103458589">u-boot-2019.10源码分析——init_sequence_f中的函数</a></li><li><a href="https://blog.csdn.net/skyflying2012/article/details/39005705">uboot环境变量实现分析</a></li><li><a href="https://sourceware.org/binutils/docs/ld/Scripts.html">LD脚本</a></li><li><a href="https://www.jianshu.com/p/ec39403db315">u-boot.lds链接文件详解</a></li><li><a href="http://blog.chinaunix.net/uid-23193900-id-3251565.html">Arm汇编指令</a></li><li><a href="https://www.jianshu.com/p/0c6192da2fd0">ARM汇编之解惑条件标志，条件码，条件执行</a></li><li><a href="https://blog.csdn.net/qq_16777851/article/details/81749077">从零开始之uboot、移植uboot2017.01 @奔跑的小刺猬</a></li><li><a href="https://www.cnblogs.com/lifexy/p/7203786.html">协处理器CP15介绍—MCR/MRC指令</a></li><li><a href="https://zhuanlan.zhihu.com/p/374941834">网卡DM9000裸机驱动详解</a></li><li><a href="https://www.crifan.com/files/doc/docbook/linux_nand_driver/release/html/linux_nand_driver.html">【详解】如何编写Linux下Nand Flash驱动</a></li><li><a href="https://wushifu-notes.readthedocs.io/zh/latest/u-boot%20%E4%B8%AD%E7%9A%84%20shell/">u-boot 中的 shell</a></li><li><a href="https://blog.csdn.net/qq_33894122/article/details/86129765">Uboot命令U_BOOT_CMD分析</a></li><li><a href="https://oska874.github.io/%E6%BA%90%E7%A0%81/uboot%E7%9A%84%E7%BD%91%E7%BB%9C.html">u-boot的网络</a></li><li><a href="https://git.busybox.net/busybox/tree/shell/hush_doc.txt">busybox中hush_doc的说明</a></li><li><a href="https://www.jianshu.com/p/2f4a5f74ac7a">ARM64 汇编——寄存器和指令</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux从安装到使用（持续更新中）</title>
      <link href="/posts/d78cdbc6/"/>
      <url>/posts/d78cdbc6/</url>
      
        <content type="html"><![CDATA[<img src="https://archlinux.org/static/logos/archlinux-logo-dark-1200dpi.b42bd35d5916.png" alt="" style="width:100%"> <p><strong>Archlinux 从安装到使用（持续更新中）</strong></p><h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>关于Archlinux的介绍，自行查看<a href="https://wiki.archlinux.org/title/Main_page_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">主页</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本文尝试过手动输入命令安装和archinstall 安装两种形式，手动命令安装参考 <a href="https://www.zhihu.com/people/viseator">吴迪</a>大佬的三部曲 <a href="https://www.viseator.com/2017/05/17/arch_install/">安装</a> <a href="https://www.viseator.com/2017/05/19/arch_setup/">配置</a> <a href="https://www.viseator.com/2017/07/02/arch_more/">常用软件</a>。</p><p>经实验，可完美安装在redmibook pro15s 上，但由于一些软件体验不友好（此处点名腾讯类），所以切换为 Windows10 + Vmware ，在Vmware中安装archlinux。以下为在虚拟机中安装</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203261703560.png"></p><h2 id="虚拟机软件配置向导"><a href="#虚拟机软件配置向导" class="headerlink" title="虚拟机软件配置向导"></a>虚拟机软件配置向导</h2><p>首先打开Vmware Workstation，点击文件 - 新建虚拟机，选择自定义（高级），</p><p>点击下一步，在安装来源中选择 <strong>安装程序光盘映像文件</strong>，点击右边的浏览找到你下载的archlinux-2022.03.01-x86_64.iso ，</p><p>点击下一步，选择操作系统为Linux，版本为 其他Linux5.x内核64位，</p><p>点击下一步，填写虚拟机的名称和要放置的位置，</p><p>点击下一步，选择处理器数量（本文1），每个处理器的内核数量（我的系统有12个，所填12），</p><p>下一步，选择虚拟机的内存（我分配的8G，因为后续要安装GNOME桌面，可能会比较占用内存），</p><p>下一步，网络连接选择 <strong>NAT模式</strong>，剩下的默认就可以了（硬盘大小按照自己需求分配），</p><p>一直点下一步，然后点击完成。</p><h2 id="进入到iso中开始安装系统"><a href="#进入到iso中开始安装系统" class="headerlink" title="进入到iso中开始安装系统"></a>进入到iso中开始安装系统</h2><p>打开虚拟机，进入到iso安装模式下，选择第一个，等出现 <code>root@archiso ~#</code>就可以继续了。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220325155433.png"></p><p>首先更改本机默认密码，输入命令 <code>passwd</code>，连续敲击两次 <code>0</code>（默认密码改成0）</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323181031.png"></p><p>通过<code>ip addr</code> 命令确认本机 ip，图中 ip 为<code>192.168.33.129</code></p><p>使用命令<code>ssh root@192.168.33.129</code> 连接（可以使用 ssh 工具或者直接在 windows 下通过 ssh 命令等）</p><h3 id="Archinstall方式安装"><a href="#Archinstall方式安装" class="headerlink" title="Archinstall方式安装"></a>Archinstall方式安装</h3><p>然后输入 <code>archinstall</code> 开始安装，开始进入到archinstall 脚本中（**此过程不可输入 &lt;CTRL + c&gt;**，否则需要从头开始配置）</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323181257.png"></p><p>然后输入 键盘语言编号：<code>26</code>，然后回车</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323181402.png"></p><p>选择地区：<code>11</code> ，中国 然后回车</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323181523.png"></p><p>选择要安装的位置的磁盘：<code>1</code>（我要安装到100G空间大小的磁盘中），然后回车。注意此时选中的块设备会多一个 &gt;&gt; 箭头，接着回车。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323181931.png"></p><p>注意此处是要擦除分区，由于我装在虚拟机中，所以擦盘中没有任何东西，直接擦除：<code>0</code>，然后回车</p><p>接着 让你选择磁盘类型，我选的是 <strong>ext4</strong>，所以输入：<code>1</code>，然后回车</p><p>接着 让你选择磁盘是否加密（此处若加密，开机时需先输入磁盘密码，在输入账户密码），为了简单起见，不加密。此处保持空白 直接回车。</p><p>是否开启zram，我选的否，n，回车。</p><p>然后让你配置主机名：</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323182425.png"></p><p>接着输入密码，空白时没有密码。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323182619.png"></p><p>然后配置用户（我第一次没有配置成功，好像是首字母要小写），配置用户密码。</p><p>然后是否为当前用户配置 sudo权限，是，配置sudo权限。</p><p>然后会让你再次添加用户，没有用户可添加了，直接回车。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/image-20220323182921830.png" alt="image-20220323182921830"></p><p>接着让你添加配置文件，我们选择<code>3-xorg</code></p><p>由于我们是在虚拟机中安装的，所以此处选择<code>5：VMware /</code>等等</p><p>选择音频服务器，1</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323183400.png"></p><p>选择<code>0</code>，linux内核（关于几个内核的区别，请自行百度）</p><p>下一步选择要安装的软件，默认回车</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323184038.png"></p><p>选择网络接口，<code>1</code></p><p>选择时区，默认回车</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/image-20220323184131200.png" alt="image-20220323184131200"></p><p>然后配置结束后，让你确认，直接回车。</p><p>然后就会在下载，安装中。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323184407.png"></p><p>安装结束后，<code>poweroff</code> 关机。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/image-20220323185646499.png" alt="image-20220323185646499"></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323185750.png"></p><p>接着移除<code>CD/DVD</code>的文件，点击确认，开机。</p><h3 id="系统配置及软件安装"><a href="#系统配置及软件安装" class="headerlink" title="系统配置及软件安装"></a>系统配置及软件安装</h3><h4 id="安装openssh"><a href="#安装openssh" class="headerlink" title="安装openssh"></a>安装openssh</h4><p>通过 <code>ip addr</code>命令查看，发现<code>ip</code>已变，重新连接，发现还是连不上。</p><blockquote><p>注意，不要使用root账户，默认root账户是被禁止ssh连接的。</p><p>然后普通用户还是登不上，显示22端口拒绝，此时需要安装openssh</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Syyuu<br>sudo pacman -S openssh<br></code></pre></td></tr></tbody></table></figure><p>此时，sshd服务并没有启动，不信你通过 <code>sudo systemctl status sshd</code> 查看是否为<code>dead</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动sshd</span><br>sudo systemctl start sshd<br><span class="hljs-comment"># 开机自启</span><br>sudo systemctl <span class="hljs-built_in">enable</span> sshd<br></code></pre></td></tr></tbody></table></figure><p>启动应用并打开开机自启，此时在查看应该已经改为 <code>running</code> 状态了。</p><p>这个时候就可以通过xshell工具进行ssh连接了。（至于为什么要使用xshell，方便复制）</p><h4 id="安装xorg服务器"><a href="#安装xorg服务器" class="headerlink" title="安装xorg服务器"></a>安装xorg服务器</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S --needed xorg <br></code></pre></td></tr></tbody></table></figure><h4 id="安装gnome桌面环境"><a href="#安装gnome桌面环境" class="headerlink" title="安装gnome桌面环境"></a>安装gnome桌面环境</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S --needed gnome gnome-tweaks nautilus-sendto gnome-nettool adwaita-icon-theme  xdg-user-dirs-gtk fwupd arc-gtk-theme  gdm<br><br><span class="hljs-comment"># 配置gnome管理器开机自启</span><br>systemctl <span class="hljs-built_in">enable</span> gdm<br><span class="hljs-comment"># 配置右上角 网络管理器开机自启</span><br>systemctl <span class="hljs-built_in">enable</span> NetworkManager<br><span class="hljs-comment">#然后reboot</span><br>reboot<br><br><span class="hljs-comment"># 删除自带浏览器</span><br>sudo pacman -Rscn epiphany <br></code></pre></td></tr></tbody></table></figure><h4 id="桌面切换到xfce4"><a href="#桌面切换到xfce4" class="headerlink" title="桌面切换到xfce4"></a>桌面切换到xfce4</h4><p>由于gnome各种bug（安装open-vm-tools后不能复制东西，复制文件管理器就闪退；打开clion会卡屏；gnome-shell cpu占用高等），所以切换到xfce4</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装xorg服务器相关</span><br>sudo pacman -S xorg-server xorg-xinit <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装xfce4</span><br>sudo pacman -S xfce4 xfce4-goodies networkmanager network-manager-applet<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">网络自启</span><br>sudo systemctl enable NetworkManager<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>sudo pacman -S lightdm lightdm-gtk-greeter<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 开机自启</span></span><br>sudo systemct enable lightdm <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载</span><br>sudo pacman -Rscn gnome gnome-extra<br>sudo pacman -Rstn gdm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入法</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装中文输入法,基础包组</span><br>sudo pacman -S fcitx5 fcitx5-chinese-addons fcitx5-im fcitx5-configtool --noconfirm<br><br>sudo gedit ~/.pam_environment<br>------------------------------------------<br>INPUT_METHOD DEFAULT=fcitx5<br>GTK_IM_MODULE DEFAULT=fcitx5<br>QT_IM_MODULE DEFAULT=fcitx5<br>XMODIFIERS DEFAULT=\@im=fcitx5<br>SDL_IM_MODULE DEFAULT=fcitx<br><br>sudo gedit ~/.xprofile<br>------------------------------------------<br>export INPUT_METHOD=fcitx5<br>export GTK_IM_MODULE=fcitx5<br>export QT_IM_MODULE=fcitx5<br>export XMODIFIERS=@im=fcitx5<br></code></pre></td></tr></tbody></table></figure><h4 id="桌面切换成KDE"><a href="#桌面切换成KDE" class="headerlink" title="桌面切换成KDE"></a>桌面切换成KDE</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装kde</span><br>sudo pacman -S plasma <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装yakuake下拉终端</span><br>sudo pacman -S yakuake <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件管理器</span><br>sudo pacman -S nautilus ranger<br><br></code></pre></td></tr></tbody></table></figure><p>美化 <a href="https://acherstyx.github.io/2021/02/20/KDE%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97-2/">https://acherstyx.github.io/2021/02/20/KDE%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97-2/</a></p><h4 id="安装open-vm-tools"><a href="#安装open-vm-tools" class="headerlink" title="安装open-vm-tools"></a>安装open-vm-tools</h4><p>请参考 <a href="https://gonglja.github.io/posts/b9ab4680/">https://gonglja.github.io/posts/b9ab4680/</a> （此处应该会存在bug，不能拷贝除.tar.gz结尾的文件，否则虚拟机内的文件管理器会闪退）</p><p>安装后如果没有动画，开启虚拟机中的3D加速</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220323194202.png"></p><h4 id="安装-yay"><a href="#安装-yay" class="headerlink" title="安装 yay"></a>安装 yay</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://aur.archlinux.org/yay.git<br><span class="hljs-built_in">cd</span> yay<br>makepkg -si<br></code></pre></td></tr></tbody></table></figure><h4 id="安装-archlinuxcn"><a href="#安装-archlinuxcn" class="headerlink" title="安装 archlinuxcn"></a>安装 archlinuxcn</h4><p>参考 <a href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/">https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/pacman.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加到最后，按 !wq 保存退出</span><br>[archlinuxcn]<br>Server = https://repo.archlinuxcn.org/$arch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后安装 archlinuxcn-keyring</span><br>sudo pacman -S archlinuxcn-keyring<br></code></pre></td></tr></tbody></table></figure><p>archlinuxcn-keyring 报错解决方法</p><p>根据<a href="https://www.archlinuxcn.org/gnupg-2-1-and-the-pacman-keyring/">这篇文章</a>上的方法进行操作<br>如果是在普通用户权限下执行记得在每条命令前添加sudo</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Syu haveged<br>systemctl start haveged<br>systemctl <span class="hljs-built_in">enable</span> haveged<br><br><span class="hljs-built_in">rm</span> -fr /etc/pacman.d/gnupg<br>pacman-key --init<br>pacman-key --populate archlinux<br></code></pre></td></tr></tbody></table></figure><p>执行完毕后再次安装archlinuxcn-keyring</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S archlinuxcn-keyring<br></code></pre></td></tr></tbody></table></figure><p>然后执行下一条命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman-key --populate archlinuxcn<br></code></pre></td></tr></tbody></table></figure><p>然后就可以愉快的安装archlinuxcn的软件啦</p><h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><p>如果没有写权限，可能是创建账户时的问题，此时，需要通过root用户登录，然后删掉原来的账户，重新创建账户。</p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># userdel -r acoollib</span><br><span class="hljs-meta"># useradd -m -G wheel acoollib</span><br><span class="hljs-meta"># passwd acoollib</span><br></code></pre></td></tr></tbody></table></figure><p>然后<a href="https://www.viseator.com/2017/05/19/arch_setup/#%E9%85%8D%E7%BD%AEsudo">配置sudo 权限</a></p><h4 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h4><p>然后<a href="https://www.viseator.com/2017/07/02/arch_more/#zsh">安装zsh</a></p><h4 id="添加中文字体"><a href="#添加中文字体" class="headerlink" title="添加中文字体"></a>添加中文字体</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S wqy-zenhei<br></code></pre></td></tr></tbody></table></figure><h4 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h4><p>首先安装</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S ibus ibus-pinyin ibus-libpinyin<br></code></pre></td></tr></tbody></table></figure><p>然后在去设置中找到键盘，输入源 点击 <code>+</code> 号添加输入法，注意<strong>添加时选择 中文（pinyin）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203261639263.png"></p><h4 id="安装Qv2ray"><a href="#安装Qv2ray" class="headerlink" title="安装Qv2ray"></a>安装Qv2ray</h4><p>安装时注意 首先配置 archlinuxcn源，然后在安装</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Syy qv2ray <br></code></pre></td></tr></tbody></table></figure><p>参考链接：<a href="https://qv2ray.net/getting-started/step1.html#linux-manjaro">https://qv2ray.net/getting-started/step1.html#linux-manjaro</a></p><h4 id="安装-chrome-gnome-shell"><a href="#安装-chrome-gnome-shell" class="headerlink" title="安装 chrome-gnome-shell"></a>安装 chrome-gnome-shell</h4><p>安装火狐 <del><code>sudo pacman -S firebox</code></del> <code>sudo pacman -S firefox-developer-edition</code></p><p>详见 <a href="https://wiki.archlinux.org/title/Firefox_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/title/Firefox_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p><p>首先安装yay，使用yay安装 <code>yay -S chrome-gnome-shell</code> 或者安装archlinuxcn源通过pacman安装</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>一款Mac风格的主题 <a href="https://github.com/vinceliuice/Mojave-gtk-theme">Mojave-gtk-theme</a></p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 快速安装</span><br><span class="hljs-attribute">yay</span> -S mojave-gtk-theme-git<br></code></pre></td></tr></tbody></table></figure><p>另外一款主题</p><p><a href="https://github.com/EliverLara/Ant">https://github.com/EliverLara/Ant</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S numix-circle-icon-theme<br></code></pre></td></tr></tbody></table></figure><h4 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h4><p><a href="https://segmentfault.com/a/1190000039901064">https://segmentfault.com/a/1190000039901064</a></p><h3 id="内核编译相关"><a href="#内核编译相关" class="headerlink" title="内核编译相关"></a>内核编译相关</h3><h4 id="内核编译报错"><a href="#内核编译报错" class="headerlink" title="内核编译报错"></a>内核编译报错</h4><p><strong>缺少编译器 gcc 、交叉编译器等</strong></p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">sudo</span> pacman -S gcc<br><span class="hljs-symbol">sudo</span> pacman -S <span class="hljs-meta">arm</span>-linux-gnueabi-gcc<br></code></pre></td></tr></tbody></table></figure><p><strong>错误：/bin/sh:行1: bc</strong></p><p>缺少 <code>bc</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S bc<br></code></pre></td></tr></tbody></table></figure><p><strong>错误：”mkimage” command not found - U-Boot images will not be built</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S uboot-tools<br></code></pre></td></tr></tbody></table></figure><h3 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h3><h4 id="NFS配置"><a href="#NFS配置" class="headerlink" title="NFS配置"></a>NFS配置</h4><p>archlinux下配置nfs，使开发板能够通过nfs启动。</p><blockquote><p>注意如果是虚拟机，网络模式需改成桥接模式，而且要关闭windows防火墙（一定要把三个防火墙全关了。。。）</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203281331467.png"></p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装nfs服务</span><br>sudo pacman -S nfs-utils<br>sudo systemctl start nfs-server.service<br>sudo systemctl status  nfs-server.service<br><span class="hljs-comment"># 每次更改配置时，需重启nfs-server.service</span><br>sudo systemctl restart  nfs-server.service<br><br><span class="hljs-comment"># 2.更改要挂载的nfs路径</span><br>sudo gedit /etc/exports <br>----------------------------------------<br><span class="hljs-comment"># 本地路径 用户(权限)</span><br>/home/acoollib/workspace/git/smart210-SDK/rootfs  *(rw,<span class="hljs-built_in">sync</span>,no_root_squash,no_subtree_check)<br><span class="hljs-comment"># 更新一下，没有错误就ok了</span><br>sudo exportfs -arv<br><br><br><span class="hljs-comment"># 3.开启nfs服务，uboot2014版本中用的还是nfsv2版本</span><br>sudo vim /etc/nfs.conf<br>-----------------------------------------<br><span class="hljs-comment"># 在[nfsd]中开启（新增）以下</span><br>udp=y<br>tcp=y<br>vers2=y<br>vers3=y<br>vers4=y<br><br><span class="hljs-comment"># 3. 更改防火墙</span><br>sudo gedit /etc/iptables/iptables.rules<br>-----------------------------------------<br><span class="hljs-comment"># 将一下 -A等 加在OUTPUT下</span><br>:OUTPUT ACCEPT [81:6480]<br>-A INPUT -p tcp -m tcp --dport 3306 -j ACCEPT<br>-A INPUT -p tcp -m tcp --dport 2049 -j ACCEPT<br>-A INPUT -p tcp -m tcp --dport 111 -j ACCEPT<br>-A INPUT -p tcp -m tcp --dport 2049 -j ACCEPT<br>-A INPUT -p tcp -m tcp --dport 20048 -j ACCEPT<br>-A INPUT -p udp -m udp --dport 111 -j ACCEPT<br>-A INPUT -p udp -m udp --dport 2049 -j ACCEPT<br>-A INPUT -p udp -m udp --dport 20048 -j ACCEPT<br>-A INPUT -p tcp -m tcp --dport 32765 -j ACCEPT<br>-A INPUT -p tcp -m tcp --dport 32803 -j ACCEPT<br>-A INPUT -p udp -m udp --dport 32765 -j ACCEPT<br>-A INPUT -p udp -m udp --dport 32803 -j ACCEPT<br><br>sudo systemctl reload iptables.service<br>sudo systemctl restart iptables.service<br><br><br></code></pre></td></tr></tbody></table></figure><h4 id="gdb配置"><a href="#gdb配置" class="headerlink" title="gdb配置"></a>gdb配置</h4><p>使用pwndbg插件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 安装pwndbg</span><br>sudo pacman  -S gdb pwndbg<br><span class="hljs-comment"># 2. 打开gdbinit并添加pwndbg, 添加 source /usr/share/pwndbg/gdbinit.py</span><br><span class="hljs-comment"># 注意：不出意外是这个路径，但最好确认下，sudo find / -name gdbinit.py</span><br><span class="hljs-comment"># 输入后，通过 :wq 保存，打开gdb，此时应该就可以看到pwndbg了</span><br>vim ~/.gdbinit<br>-----------------------------------------<br><span class="hljs-built_in">source</span> /usr/share/pwndbg/gdbinit.py<br></code></pre></td></tr></tbody></table></figure><h4 id="grub配置"><a href="#grub配置" class="headerlink" title="grub配置"></a>grub配置</h4><p><a href="https://linuxhint.com/update_grub_arch_linux/">https://linuxhint.com/update_grub_arch_linux/</a></p><h5 id="grub配置不生效"><a href="#grub配置不生效" class="headerlink" title="grub配置不生效"></a>grub配置不生效</h5><p>查看fstab是否没有挂载boot分区，发现实际上是个空文件。</p><p>解决方法：添加启动盘，挂载所有分区，使用<code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code>；重启系统后再次<code>grub-mkconfig -o /boot/grub/grub.cfg</code></p><p>过程中可能碰到虚拟机无法从CD/DVD启动，此时需要修改虚拟机的bios，修改启动顺序；但是呢，虚拟机的bios不一定能进去，此处需要修改虚拟机启动时bios的时间。</p><p>然后进入到启动盘，挂载所有分区，首先用命令 <code>fdisk -l</code> 查看分区分布，我的<code>sda2</code> 是主分区，<code>sda1</code> 是启动分区，所以使用命令挂载 ，然后用命令 <code>lsblk</code> 查看一下，没有问题生成<code>fstab</code></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203281005872.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203281006011.png"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.创建boot文件夹</span><br><span class="hljs-built_in">mkdir</span> -p /mnt/boot<br><br><span class="hljs-comment"># 2. 挂载</span><br>mount /dev/sda2 /mnt <br>mount /dev/sda1 /mnt/boot<br><br><span class="hljs-comment"># 3.查看验证</span><br>lsblk <br><br><span class="hljs-comment"># 4.生成fstab</span><br>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br><br></code></pre></td></tr></tbody></table></figure><p>参考：</p><ol><li><a href="https://blog.csdn.net/qq_45069279/article/details/113879143">真没想到，vmware进入 bios设置 的方法是这样的</a></li><li><a href="https://www.keysou.com/post/850.html">重装ArchLinux后修改GRUB配置不生效问题的解决</a></li><li><a href="https://zhuanlan.zhihu.com/p/365975505">安装ArchLinux（一）仅命令行</a></li></ol><h3 id="Buildroot-构建"><a href="#Buildroot-构建" class="headerlink" title="Buildroot 构建"></a>Buildroot 构建</h3><p>安装依赖</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S rsync cpio<br></code></pre></td></tr></tbody></table></figure><p>开始构建，使用<code>make menuconfig</code>配置，然后<code>make -j$(proc)</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://linuxhint.com/arch_linux_ssh_server/#:~:text=The%20name%20of%20the%20program%20that%20provides%20SSH,cache%20of%20Arch%20Linux%20with%20the%20following%20command%3A">archlinux下开启openssh</a></li><li><a href="https://www.linuxmi.com/arch-linux-install-gnome-desktop.html">archlinux下安装gnome桌面环境</a></li><li><a href="https://www.viseator.com/2017/05/19/arch_setup/">archlinux安装</a></li><li><a href="https://blog.csdn.net/vict_wang/article/details/89532135">Linux用户组</a></li><li><a href="https://wiki.archlinux.org/title/NFS_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Archlinux NFS配置</a></li><li><a href="https://blog.csdn.net/helloworld573/article/details/108088174">Ubuntu开启NFS，从机端报错:ERROR: File lookup fail</a></li><li><a href="https://zhuanlan.zhihu.com/p/111790532">buildroot使用</a></li><li><a href="https://www.jianshu.com/p/7c2ab582e13d">https://www.jianshu.com/p/7c2ab582e13d</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GS87D键盘说明书</title>
      <link href="/posts/74f0a0fa/"/>
      <url>/posts/74f0a0fa/</url>
      
        <content type="html"><![CDATA[<p>有一个不太好的习惯，有时候喜欢收集说明书，每次都是攒一堆，然后越来越多的时候，直接一下丢了。</p><p>本文的主人公也是，在买来后就被丢到了角落。</p><p>最近需要使用在双电脑间切换键盘，依稀记得键盘支持最高三个蓝牙设备连接，凭着记忆怎么也没弄好，无奈百度一下，找到了一个教程，其中作者说明书也是找不着了，然后整理了一个博客。但按照上面的方法还是没有设置成功。遂又去找客服，不得不说，还是官方教程好使。记录下</p><h3 id="蓝牙连接"><a href="#蓝牙连接" class="headerlink" title="蓝牙连接"></a>蓝牙连接</h3><p>1、开关拨OFF，装电池，拨到ON，指示灯会闪烁一下<br>2、然后<strong>FN按住</strong>，再<strong>按一下Q</strong>，接着空格右边<strong>FN按住</strong>，<strong>再按住P，长按</strong>，<strong>第1个设备打开蓝牙搜索</strong>，连接。就可以正常输入，能打字了<br>3、<strong>FN按住</strong>，再<strong>按一下W</strong>，切换到第二个设备键盘无反应状态，接着空格右边<strong>FN按住</strong>，<strong>再按住P，长按</strong>，<strong>第2个设备打开蓝牙搜索</strong>，连接<br>4、都好了之后，<strong>FN按住</strong>，再<strong>按一下Q或者W</strong>可以切换设备</p><p>QWERT一共5个设备切换，先切换，再对码，操作</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/ce4fd3f3e598">https://www.jianshu.com/p/ce4fd3f3e598</a></p>]]></content>
      
      
      <categories>
          
          <category> 说明书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于实模式与保护模式</title>
      <link href="/posts/4bb7b00b/"/>
      <url>/posts/4bb7b00b/</url>
      
        <content type="html"><![CDATA[<p>首先到了80386时代，CPU有了<strong>四种运行模式，即实模式、保护模式、虚拟8086模式和SMM模式</strong>。</p><p>其中实模式指的是8086的运行模式，不过这个是后来提出的概念，在8086时代只有当时的运行模式。</p><blockquote><p>以下转自：<a href="https://zhuanlan.zhihu.com/p/42309472">https://zhuanlan.zhihu.com/p/42309472</a></p></blockquote><p>实模式和保护模式都是 CPU 的工作模式，而 CPU 的工作模式是指 CPU 的寻址方式、寄存器大小等用来反应 CPU 在该环境下如何工作的概念。</p><h2 id="实模式工作原理"><a href="#实模式工作原理" class="headerlink" title="实模式工作原理"></a>实模式工作原理</h2><p>实模式出现于早期 8088CPU 时期。当时由于 CPU 的性能有限，一共只有 20 位地址线（所以地址空间只有 1MB），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。所以为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：</p><p>　　<code>段基址：段偏移量</code></p><p>　 其中第一个字段是段基址，它的值是由<strong>段寄存器</strong>提供的 (一般来说，段寄存器有 6 种，分别为 <code>cs, ds, ss, es, fs, gs,</code>这几种段寄存器都有自己的特殊意义，这里不做介绍)。</p><p>　 第二字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的偏移。它的值就是由通用寄存器来提供的，所以也是 16 位。那么两个 16 位的值如何组合成一个 20 位的地址呢？CPU 采用的方式是把段寄存器所提供的段基址先向左移 4 位。这样就变成了一个 20 位的值，然后再与段偏移量相加。</p><p>即：<br>$$<br>物理地址 = 段基址 &lt;&lt;4 + 段内偏移<br>$$<br>　　所以假设段寄存器中的值是 <code>0xff00</code>，段偏移量为 <code>0x0110</code>。则这个地址对应的真实物理地址是 0xff00&lt;&lt;4 + 0x0110 = 0xff110。</p><p>由上面的介绍可见，实模式的 “实” 更多地体现在其地址是真实的物理地址。</p><h2 id="保护模式工作原理"><a href="#保护模式工作原理" class="headerlink" title="保护模式工作原理"></a>保护模式工作原理</h2><p>随着 CPU 的发展，CPU 的地址线的个数也从原来的 20 根变为现在的 32 根，所以可以访问的内存空间也从 1MB 变为现在 4GB，寄存器的位数也变为 32 位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大空间的，更灵活也<strong>更安全</strong>的内存访问。</p><p>在保护模式下，CPU 的 32 条地址线全部有效，可寻址高达 4G 字节的物理地址空间; </p><p>但是我们的内存寻址方式还是得兼容老办法 (这也是没办法的，有时候是为了方便，有时候是一种无奈)，即(段基址：段偏移量) 的表示方式。</p><p>当然此时 CPU 中的通用寄存器都要换成 32 位寄存器 (除了段寄存器，原因后面再说) 来保证寄存器能访问所有的 4GB 空间。</p><p>我们的偏移值和实模式下是一样的，就是变成了 32 位而已，而段值仍旧是存放在原来 16 位的段寄存器中，<strong>但是这些段寄存器存放的却不再是段基址了</strong>，毕竟之前说过实模式下寻址方式不安全，我们在保护模式下需要加一些限制，而这些限制可不是一个寄存器能够容纳的，于是我们把这些关于内存段的限制信息放在一个叫做<strong>全局描述符表 (GDT)</strong> 的结构里。全局描述符表中含有一个个表项，每一个表项称为<strong>段描述符。</strong>而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项。段描述符存放了段基址、段界限、内存段类型属性 (比如是数据段还是代码段, 注意<strong>一个段描述符只能用来定义一个内存段</strong>) 等许多属性, 具体信息见下图：</p><p><img src="https://pic4.zhimg.com/v2-1a08d48367745c2870e8818b7881b373_r.jpg"></p><p>其中，段界限表示段边界的扩张最值，即最大扩展多少或最小扩展多少，用 20 位来表示，它的单位可以是字节，也可以是 4KB，这是由 G 位决定的 (G 为 1 时表示单位为 4KB)。</p><p>$$<br>实际段界限边界值 =(描述符中的段界限 + 1)*（段界限的单位大小 (即字节或 4KB))-1<br>$$<br>如果偏移地址超过了段界限，CPU 会抛出异常。</p><p>全局描述符表位于内存中，需要用专门的寄存器指向它后， CPU 才知道它在哪里。这个专门的寄存器便是 <strong>GDTR</strong>(一个 48 位的寄存器), 专门用来存储 GDT 的内存地址及大小。</p><p>最后我们再介绍一下一个新的概念：段的选择子。段寄存器 CS、 DS、 ES、 FS、 GS、 SS，在实模式下时，段中存储的是段基地址，即内存段的起始地址。 而在保护模式下时，由于段基址已经存入了段描述符中，所以段寄存器中再存放段基址是没有意义的，在段寄存器中存入的是一个叫作选择子的东西。选择子 “基本上” 是个索引值，虽然它还有其他内容，不过作为初学者暂时忽略也没太大关系。由于段寄存器是 16 位，所以选择子也是 16 位，在其低 2 位即第 0～1 位， 用来存储 RPL，即请求特权级(有兴趣的可以了解一下，不想了解的忽略即可，跟用户态和内核态相关的)，可以表示 0、 1、 2、 3 四种特权级。在选择子的第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。 TI 为 0 表示在 GDT 中索引描述符， TI 为 1 表示在 LDT 中索引描述符。选择子的高 13 位，即第 3～15 位是 描述符的索引值，用此值在 GDT 中索引描述符。前面说过 GDT 相当于一个描述符数组，所以此选择子中的索引值就是 GDT 中的下标。选择子结构如下：</p><p><img src="https://pic1.zhimg.com/v2-c07398ad98ff6800f43637f83400f284_b.jpg"></p><p>此外， 扩充的存储器分段管理机制和可选的存储器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持; 支持多任务，能够快速地进行任务切换 (switch) 和保护任务环境(context); 4 个特权级和完善的特权检查机制，既能实现资源共享又能保证代码和数据的安全和保密及任务的隔离; 支持虚拟 8086 方式，便于执行 8086 程序。</p>]]></content>
      
      
      <categories>
          
          <category> 好文转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从char(unsigned char)数组拷贝至string的方法</title>
      <link href="/posts/d8f56567/"/>
      <url>/posts/d8f56567/</url>
      
        <content type="html"><![CDATA[<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>C++标准 <a href="https://en.cppreference.com/w/cpp/string/basic_string/basic_string">https://en.cppreference.com/w/cpp/string/basic_string/basic_string</a> 中第4条，构造时传入<code>char *</code>指针和待传入的数据长度 </p><p><code>basic_string( const CharT* s, size_type count, const Allocator&amp; alloc = Allocator() );</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-type">uint8_t</span> a[] = {<span class="hljs-number">0x30</span>,<span class="hljs-number">0x31</span>,<span class="hljs-number">0x33</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x31</span>,<span class="hljs-number">0x33</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x31</span>,<span class="hljs-number">0x33</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x31</span>,<span class="hljs-number">0x33</span>,<span class="hljs-number">0x35</span>,<span class="hljs-number">0x0</span>,};<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">s</span><span class="hljs-params">(reinterpret_cast&lt;<span class="hljs-type">char</span> *&gt;(a), <span class="hljs-keyword">sizeof</span>(a))</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"size:"</span>&lt;&lt;s.size()&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ g++ main.cpp -std=c++11 -g<br>$ ./a.out<br>size:20<br></code></pre></td></tr></tbody></table></figure><p>在c++11中，可以通过string的构造函数 <code>basic_string( const CharT* s, size_type count, const Allocator&amp; alloc = Allocator() );</code></p><p>完成<code>char *</code>到string的转化，<strong>不用管char 数组中是否含有0</strong>，可通过 <code>.size()</code> 查看大小，或者直接 使用 <code>gdb</code> 查看内存中的数据；但需注意，直接使用<code>std::cout</code>输出可能会丢失数据（遇<code>\0</code>结束），建议使用迭代器对每个元素遍历。</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/image-20220308085045195.png"></p><p>如上图中终端输出的 使用<code>x</code> 命令访问 内存，格式如 <code>x/&lt;n/f/u&gt; &lt;addr&gt;</code>,</p><ul><li><p>n 正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容</p></li><li><p>f 表示addr 指向内存内容的输出格式，s对应输出字符串，其它整形格式如下：</p><ul><li>x 按十六进制格式显示变量</li><li>d 按十进制格式显示变量</li><li>u 按十进制格式显示无符号整型</li><li>o 按八进制格式显示变量 </li><li>t 按二进制格式显示变量</li><li>a 按十六进制格式显示变量</li><li>c  按字符格式显示变量</li><li>f  按浮点数格式显示变量</li></ul></li><li><p>u 指以多少个字节作为一个内存单元-unit,默认为4。u还可以用被一些字符表示:如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> string </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL库中copy的使用</title>
      <link href="/posts/8299be4a/"/>
      <url>/posts/8299be4a/</url>
      
        <content type="html"><![CDATA[<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p><a href="https://en.cppreference.com/w/cpp/algorithm/copy">https://en.cppreference.com/w/cpp/algorithm/copy</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 打印 std::vector 类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T &amp;vecs)</span> </span>{<br>    std::cout &lt;&lt; <span class="hljs-string">"vecs-&gt;size:"</span>&lt;&lt;vecs.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">"\t data:"</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : vecs) <br>        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">" "</span>;<br>    std::cout &lt;&lt; std::endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{<br>    std::vector&lt;<span class="hljs-type">char</span>&gt; vecs{<span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'F'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'H'</span>,<span class="hljs-string">'I'</span>};<br>    std::vector&lt;<span class="hljs-type">char</span>&gt; tmp;<br>    <br>    tmp.<span class="hljs-built_in">resize</span>(vecs.<span class="hljs-built_in">size</span>() * <span class="hljs-number">10</span>); <br>    print&lt;std::vector&lt;<span class="hljs-type">char</span>&gt;&gt;(vecs);<br>    std::<span class="hljs-built_in">copy</span>(vecs.<span class="hljs-built_in">begin</span>(),vecs.<span class="hljs-built_in">end</span>(),tmp.<span class="hljs-built_in">begin</span>());<br>    std::<span class="hljs-built_in">copy</span>(vecs.<span class="hljs-built_in">begin</span>(),vecs.<span class="hljs-built_in">end</span>(),tmp.<span class="hljs-built_in">begin</span>() + vecs.<span class="hljs-built_in">size</span>());<br>    std::<span class="hljs-built_in">copy</span>(vecs.<span class="hljs-built_in">begin</span>(),vecs.<span class="hljs-built_in">end</span>(),tmp.<span class="hljs-built_in">begin</span>() + vecs.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    print&lt;std::vector&lt;<span class="hljs-type">char</span>&gt;&gt;(tmp);<br><br>    <span class="hljs-type">int64_t</span> valA = <span class="hljs-number">0x123456789</span>;<br>    std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; tmpA;<br>    tmpA.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">sizeof</span>(valA));<br>    std::<span class="hljs-built_in">copy</span>((<span class="hljs-type">uint8_t</span> *)&amp;valA, (<span class="hljs-type">uint8_t</span> *)&amp;valA + <span class="hljs-built_in">sizeof</span>(valA), tmpA.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-built_in">print</span>(tmpA);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v: tmpA)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x "</span>,v);<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>} <br></code></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将上述代码保存为test.cpp ，使用以下命令编译、执行</span><br>g++  test.cpp -std=c++11<br>./a.out<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">得到结果，与预期一致</span><br>u@ubuntu:~$ ./a.out <br><span class="hljs-meta prompt_">vecs-&gt;</span><span class="language-bash">size:9     data:A B C D E F G H I</span> <br><span class="hljs-meta prompt_">vecs-&gt;</span><span class="language-bash">size:90    data:A B C D E F G H I A A B C D E F G H I</span>                                                                        <br><span class="hljs-meta prompt_">vecs-&gt;</span><span class="language-bash">size:8     data:� g E <span class="hljs-comment">#</span></span>     <br>89 67 45 23 1 0 0 0 <br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用过程中 copy 有三个参数，分别是待拷贝的数据开始迭代器、待拷贝的数据的结束迭代器、目的迭代器</p><p>其中如果要拷贝非STL中数据，根据目的迭代器的存储类型，<strong>将源数据 转成对应的指针形式访问内存</strong>，比如上述代码中的</p><p><code>std::copy((uint8_t *)&amp;valA, (uint8_t *)&amp;valA + sizeof(valA), tmpA.begin());</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个简单的测试Linux进程栈空间大小的方法</title>
      <link href="/posts/f2b20ab4/"/>
      <url>/posts/f2b20ab4/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的测试linux进程栈空间大小的方法"><a href="#一个简单的测试linux进程栈空间大小的方法" class="headerlink" title="一个简单的测试linux进程栈空间大小的方法"></a>一个简单的测试linux进程栈空间大小的方法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在ubuntu中，可以通过命令<code>ulimit -a </code>查看所有的限制信息（<code>ulimit -s</code> 直接显示stack size）</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220310100235.png"></p><p>但在某些嵌入式开发板中，通过此命令查看到的<code>stack size</code>显示<code>ulimited</code> （无限制，假），但实际中是有限制的，不知道<code>stack size</code> 不利于大型项目的开发（栈空间使用过多后程序会直接挂 segmentation fault）。所以，得到一个真实的<code>stack size</code>尤为重要。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>A函数每次创建 1024bytes 数据；使用全局变量存储A函数调用次数，每次调用A函数+1；</p><p>主函数中递归调用A函数，由于主函数中栈空间相对于子线程会大一些，所以在子线程中递归调用。最终栈溢出后通过屏幕打印的计数即可得到大概的stack size。忽略掉函数调用栈空间占用。</p><p>另一种思路：通过汇编得到esp指针获得起始位置，结束位置通过递归调用栈溢出后gdb打印esp指针获得结束位置。详见<a href="https://blog.csdn.net/yangkuanqaz85988/article/details/52403726">https://blog.csdn.net/yangkuanqaz85988/article/details/52403726</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">pthread_t</span> thread_id;<br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> temp[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>        count ++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %d num = %d!\r\n"</span>, __FUNCTION__, __LINE__, count);<br>    test();<br>}<br><span class="hljs-type">void</span>* <span class="hljs-title function_">thrd_func</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>{<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %d!\r\n"</span>, __FUNCTION__, __LINE__);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"New process:  PID: %d,TID: %u.\r\n"</span>, getpid(), pthread_self());<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"New process:  PID: %d,TID: %u.\r\n"</span>, getpid(), thread_id);<br>    test();<br>    pthread_exit(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//退出线程</span><br>}<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;thread_id, <span class="hljs-literal">NULL</span>, thrd_func, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>    {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Create thread error!\r\n"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    }<br>    sleep(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将以上文件保存为 main.cpp，使用如下命令编译得到 a.out，./a.out 运行</span><br>gcc main.cpp -pthread -std=c++11<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220310100420.png"></p><p>大概是7937 * 1024 bytes = 7937kbytes ≈ 8 Mbytes 。</p>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multiboot规范</title>
      <link href="/posts/4e0f05fa/"/>
      <url>/posts/4e0f05fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原英文 <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></p></blockquote><blockquote><p>原文地址 <a href="https://blog.csdn.net/uframer/article/details/373900">blog.csdn.net</a></p></blockquote><p>[TOC]</p><h1 id="Multiboot-规范"><a href="#Multiboot-规范" class="headerlink" title="Multiboot 规范"></a>Multiboot 规范</h1><h2 id="Multiboot-规范-1"><a href="#Multiboot-规范-1" class="headerlink" title="Multiboot 规范"></a>Multiboot 规范</h2><p>本文定义了 Multiboot 规范——提议中的引导过程标准。本文是此规范的 0.6.96 版。</p><ul><li>概览</li><li>术语</li><li>规范</li><li>示例</li><li>历史</li><li>调用 mbchk：如何使用多重引导检查器</li><li>索引</li></ul><h2 id="Multiboot-规范简介"><a href="#Multiboot-规范简介" class="headerlink" title="Multiboot 规范简介"></a>Multiboot 规范简介</h2><p>本章描述了一些关于 Multiboot 规范的粗略的信息。注意，这不是规范本身的一部分。</p><ul><li><p>动机</p></li><li><p>架构</p></li><li><p>操作系统</p></li><li><p>引导源</p></li><li><p>引导时配置</p></li><li><p>为操作系统带来的便利</p></li><li><p>引导模块</p></li></ul><h3 id="Multiboot-规范诞生的背景"><a href="#Multiboot-规范诞生的背景" class="headerlink" title="Multiboot 规范诞生的背景"></a>Multiboot 规范诞生的背景</h3><p>几乎每种现有的操作系统都拥有自己的引导程序。在机器上安装一个新的操作系统时通常意味着要引入一套全新的引导机制，每种的安装和运行界面都不相同。使多种操作系统相安无事地共存于一个机器上通常要借助于链式机制，这可是个恶梦。基本上你不能选择某个操作系统的引导程序——如果操作系统自带的引导程序不是你想要的，或者不能在你的机器上工作，你的麻烦可就大了。</p><p>尽管不太可能解决现有的商业操作系统所存在的问题，但是对于自由操作系统社区的人们来说，将他们的领袖集合在一起并为流行的自由操作系统解决这个问题并不是很难。这也正是这份规范的目的所在。基本上，它指出了引导程序和操作系统之间的接口，这样符合规范的引导程序就可以引导任何符合规范的操作系统。这份规范并不关心引导程序应该如何工作——只关心它们引导操作系统时的接口。</p><h3 id="目标架构"><a href="#目标架构" class="headerlink" title="目标架构"></a>目标架构</h3><p>这份规范主要面向 PC，因为它们使用最广并且有最多的操作系统和引导程序。尽管如此，对于那些需要一份引导规范并且目前缺少一份的架构来说，剥去 x86 架构的相关细节得到版本也应该可以满足需要。</p><h3 id="目标操作系统"><a href="#目标操作系统" class="headerlink" title="目标操作系统"></a>目标操作系统</h3><p>这份规范的目标是自由的 32 位操作系统，因为应该可以比较容易获得修改这些操作系统以支持本规范的权力而不需要听满是官腔的喋喋不休。这份规范主要是面向 Linux、FreeBSD、NetBSD、Mach 和 VSTa 这些自由操作系统设计的。我们希望后来的自由操作系统能够从一开始就采用本规范，这样就可以立即使用现有的引导程序了。如果商业操作系统能够最终采用本规范当然很好，但是这很可能只是白日做梦。</p><h3 id="引导源"><a href="#引导源" class="headerlink" title="引导源"></a>引导源</h3><p>实现一个可以从各种位置（软盘、硬盘或网络）载入 OS 映像的引导程序是现实可行的。</p><p>基于磁盘的引导程序可以使用各种技术查找位于磁盘上的 OS 映像和引导模块，例如解释某种文件系统（如 BSD/Mach 引导程序），使用预先计算好的 block 列表（如 LILO），从特殊的引导分区载入（如 OS/2），或者甚至从另一个操作系统载入（如 VSTa 引导代码，从 DOS 载入）。与此相似，基于网络的引导程序也可以使用各种网络硬件和协议。</p><p>我们希望引导程序可以支持多种载入机制，这样可以提供更好的可移植性、健壮性和易用性。</p><h3 id="在引导时配置操作系统"><a href="#在引导时配置操作系统" class="headerlink" title="在引导时配置操作系统"></a>在引导时配置操作系统</h3><p>总有这样或者那样的原因使得用户需要在启动时动态配置操作系统。尽管本规范不应该对引导程序如何获得这些配置信息指手划脚，我们还是应该为如何将这些信息传递给操作系统提供一种标准的方法。</p><h3 id="如何使操作系统开发更容易"><a href="#如何使操作系统开发更容易" class="headerlink" title="如何使操作系统开发更容易"></a>如何使操作系统开发更容易</h3><p>应尽量降低生成 OS 映象的难度。在理想情况下，OS 映象应该是该操作系统通常使用的普通 32 位可执行文件格式。应该能够像对待普通可执行文件格式一样用<code>nm</code>或者反汇编 OS 映象，而不应该用到特殊的工具来生成使用_特殊_文件格式的 OS 映象。如果这意味着将一部分的操作系统功能转移到引导程序中来的话，这很合适，因为任何引导程序用到的内存都应该可由它所创建的真正的系统自由使用，这样 OS 映象中的每一个比特都应该永远留在内存中。操作系统应该不必考虑如何进入 32 位地址模式，因为模式切换应该位于引导程序中，而这些程序通常需要将操作系统数据装入到 1MB 以上的内存，如果操作系统需要考虑这些问题的话创建 OS 映象的工作将变得更加困难。</p><p>不幸的是，仅在 PC 平台上的自由 UNIX 类系统中也有多得惊人的可执行文件格式——通常各种操作系统的格式都不相同。大多数的自由操作系统使用的是 a.out 格式的变种，但有一些已经改用了 ELF 格式。最好是引导程序不必为了载入 OS 映象而需要理解所有的可执行文件格式——否则的话引导程序又变成了某个操作系统专用的了。</p><p>这份规范采用了一种折衷的方案。符合 Multiboot 规范的 OS 映象总是包含一个 magic Multiboot 头（参见 OS 映像格式），这样引导程序就不必理解种类繁多的 a.out 变体或者其他什么可执行格式。magic 头不必位于可执行文件的最前面，这样 OS 映象就可以在保持同 a.out 格式兼容的同时做到符合 Multiboot 规范。</p><h3 id="引导模块"><a href="#引导模块" class="headerlink" title="引导模块"></a>引导模块</h3><p>许多现代操作系统的内核，如 VSTa 和 Mach，本身并不包括系统所有的功能：它们需要在引导时载入额外的软件模块以访问设备、挂载文件系统等。尽管这些额外的软件模块可以同内核一同嵌入到主 OS 映像中，并且在操作系统接管控制权时可以将映像分割为不同的部分，但如果引导程序能在一开始就分别的载入这些模块的话，对操作系统和用户来说就更灵活、更有空间效率并且很方便。</p><p>因此，本规范应该为引导程序提供一个标准的方法指示操作系统应该载入哪些辅助模块，以及应该将它们放在哪里。引导程序不一定非得支持多引导模块，但是我们强烈推荐它们这样，因为一些操作系统如果不这样就无法引导。</p><h2 id="本-Multiboot-规范中所用术语的定义"><a href="#本-Multiboot-规范中所用术语的定义" class="headerlink" title="本 Multiboot 规范中所用术语的定义"></a>本 Multiboot 规范中所用术语的定义</h2><p>必须</p><p>​术语 “必须 ” 表示引导程序或 OS 映像需要服从某一规则，否则的话，引导程序或者 OS 映像就不能称为符合 Multiboot 规范的。</p><p>应该</p><p>​术语 “ 应该 ” 表示引导程序或 OS 映像最好服从某一规则，但如果没有服从也是可以的。</p><p>可以</p><p>​术语 “ 可以” 表示引导程序或 OS 映像服从某一规则是允许的。</p><p>引导程序</p><p>​引导程序是负责载入最终的操作系统映像的一个或一组程序。引导程序本身可以由几个阶段组成，但是这属于实现细节而同本规范无关。只有引导程序最后的阶段——最终将控制权转交给操作系统的阶段——必须遵守本文中规定的规则，否则引导程序就不能称为符合 Multiboot 规范；在这之前的阶段可以怎么方便怎么设计。</p><p>OS 映像</p><p>​OS 映像是引导程序载入到内存的初始二进制映像，随后引导程序会将控制权转移给它，这样就启动了操作系统。典型的 OS 映像是包含了操作系统内核的可执行文件。  </p><p>引导模块</p><p>​引导模块是由引导程序同 OS 映像一同载入的其他起辅助作用的文件。引导程序并不理解这些文件，只会将它们的位置告知操作系统。  </p><p>符合 Multiboot 规范</p><p>​服从所有被标记为 “必须” 的引导程序或者 OS 映像被称为符合 Multiboot 规范。对于规范中那些被标记为 “应该” 或者 “可以” 的规则，符合 Multiboot 规范的引导程序或 OS 映像可以不必遵守。</p><p>u8</p><p>​无符号 8 位数据。</p><p>u16</p><p>​无符号 16 位数据。因为目标架构是高位优先（little-endian）的，所以 u16 按照高位优先编码。</p><p>u32</p><p>​无符号 32 位数据。因为目标架构是高位优先（little-endian）的，所以 u32 按照高位优先编码。  </p><p>u64</p><p>​无符号 64 位数据。因为目标架构是高位优先（little-endian）的，所以 u64 按照高位优先编码。</p><h2 id="Multiboot-规范的精确定义"><a href="#Multiboot-规范的精确定义" class="headerlink" title="Multiboot 规范的精确定义"></a>Multiboot 规范的精确定义</h2><p>引导程序 / OS 映像接口主要包括三个：</p><ol><li>引导程序看到的 OS 映像的格式</li><li>引导程序启动操作系统时机器的状态</li><li>引导程序传递给操作系统的信息的格式</li></ol><ul><li><p><strong>OS 映像格式</strong></p></li><li><p><strong>机器状态</strong></p></li><li><p><strong>引导信息格式</strong></p></li></ul><h3 id="OS-映像格式"><a href="#OS-映像格式" class="headerlink" title="OS 映像格式"></a>OS 映像格式</h3><p>一个 OS 映像可以是一个普通的某种操作系统使用的标准格式的 32 位可执行文件，不同之处是它可能被连接到一个非默认的载入地址以避开 PC 的 I/O 区域或者其它的保留区域，当然它也不能使用共享库或其它这样可爱的东西。</p><p>除了 OS 映像所使用的格式需要的头之外，<strong>OS 映像还必须额外包括一个 Multiboot 头</strong>。<strong>Multiboot 头必须完整的包含在 OS 映像的前 8192 字节内</strong>，并且<strong>必须是 longword（32 位）对齐</strong>的。通常来说，它的位置<strong>越靠前越好</strong>，并且可以嵌入在 text 段的起始处，位于真正的可执行文件头之前。</p><ul><li><p>头分布: Multiboot Header 分布</p></li><li><p>头的幻数域: Multiboot Header magic 域</p></li><li><p>头的地址域: Multiboot Header address域</p></li><li><p>头的图形域: Multiboot Header graphics域</p></li></ul><h4 id="Multiboot-的-Header-分布"><a href="#Multiboot-的-Header-分布" class="headerlink" title="Multiboot 的 Header 分布"></a>Multiboot 的 Header 分布</h4><p>Multiboot 头的分布必须如下表所示：</p><table><thead><tr><th>偏移量</th><th>类型</th><th>域名</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>u32</td><td>magic</td><td>必需</td></tr><tr><td>4</td><td>u32</td><td>flags</td><td>必需</td></tr><tr><td>8</td><td>u32</td><td>checksum</td><td>必需</td></tr><tr><td>12</td><td>u32</td><td>header_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>16</td><td>u32</td><td>load_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>20</td><td>u32</td><td>load_end_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>24</td><td>u32</td><td>bss_end_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>28</td><td>u32</td><td>entry_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>32</td><td>u32</td><td>mode_type</td><td>如果 flags[2] 被置位</td></tr><tr><td>36</td><td>u32</td><td>width</td><td>如果 flags[2] 被置位</td></tr><tr><td>40</td><td>u32</td><td>height</td><td>如果 flags[2] 被置位</td></tr><tr><td>44</td><td>u32</td><td>depth</td><td>如果 flags[2] 被置位</td></tr></tbody></table><p><code>magic</code>、<code>flags</code> 和 <code>checksum</code> 域在Header magic 域中定义，</p><p><code>header_addr</code>、<code>load_addr</code>、<code>load_end_addr</code>、<code>bss_end_addr</code> 和 <code>entry_addr</code> 域在Header address域中定义，</p><p><code>mode_type</code>、<code>width</code>、<code>height</code>和<code>depth</code>域则在Header graphics 域中定义。</p><h4 id="Multiboot-Header-magic-域"><a href="#Multiboot-Header-magic-域" class="headerlink" title="Multiboot Header magic 域"></a>Multiboot Header magic 域</h4><p><code>magic</code></p><p>​magic 域是标志头的魔数，它必须等于十六进制值 0x1BADB002。  </p><p><code>flags</code></p><p>​flags 域指出 OS 映像需要引导程序提供或支持的特性。0-15 位指出需求：如果引导程序发现某些值被设置但出于某种原因不理解或不能不能满足相应的需求，它必须告知用户并宣告引导失败。16-31 位指出可选的特性：如果引导程序不能支持某些位，它可以简单的忽略它们并正常引导。自然，所有 flags 字中尚未定义的位必须被置为 0。这样，flags 域既可以用于版本控制也可以用于简单的特性选择。</p><p>如果设置了 flags 字中的 0 位，所有的引导模块将按页（4KB）边界对齐。有些操作系统能够在启动时将包含引导模块的页直接映射到一个分页的地址空间，因此需要引导模块是页对齐的。</p><p>如果设置了 flags 字中的 1 位，则必须通过 Multiboot 信息结构（参见引导信息格式）的 mem_* 域包括可用内存的信息。如果引导程序能够传递内存分布（mmap_* 域）并且它确实存在，则也包括它。</p><p>如果设置了 flags 字中的 2 位，有关视频模式表（参见引导信息格式）的信息必须对内核有效。</p><p>如果设置了 flags 字中的 16 位，则 Multiboot 头中偏移量 8-24 的域有效，引导程序应该使用它们而不是实际可执行头中的域来计算将 OS 映象载入到那里。如果内核映象为 ELF 格式则不必提供这样的信息，但是如果映象是 a.out 格式或者其他什么格式的话就_必须_提供这些信息。兼容的引导程序必须既能够载入 ELF 格式的映象也能载入将载入地址信息嵌入 Multiboot 头中的映象；它们也可以直接支持其他的可执行格式，例如一个 a.out 的特殊变体，但这不是必须的。  </p><p><code>checksum</code></p><p>​域 checksum 是一个 32 位的无符号值，当与其他的 magic 域（也就是 magic 和 flags）相加时，结果必须是 32 位的无符号值 0（即 magic + flags + checksum = 0）。</p><h4 id="Multiboot-Header-address-域"><a href="#Multiboot-Header-address-域" class="headerlink" title="Multiboot Header address 域"></a>Multiboot Header address 域</h4><p>所有由 flags 的第 16 位开启的地址域都是物理地址。它们的意义如下：</p><p><code>header_addr</code></p><p>包含对应于 Multiboot 头的开始处的地址——这也是 magic 值的物理地址。这个域用来 同步 OS 映象偏移量和物理内存之间的映射。  </p><p><code>load_addr</code></p><p>包含 text 段开始处的物理地址。从 OS 映象文件中的多大偏移开始载入由头位置的偏移量定义，相减（header_addr - load_addr）。load_addr 必须小于等于 header_addr。  </p><p><code>load_end_addr</code></p><p>包含 data 段结束处的物理地址。（load_end_addr - load_addr）指出了引导程序要载入多少数据。这暗示了 text 和 data 段必须在 OS 映象中连续；现有的 a.out 可执行格式满足这个条件。如果这个域为 0，引导程序假定 text 和 data 段占据整个 OS 映象文件。  </p><p><code>bss_end_addr</code></p><p>包含 bss 段结束处的物理地址。引导程序将这个区域初始化为 0，并保留这个区域以免将引导模块和其他的于查系统相关的数据放到这里。如果这个域为 0，引导程序假定没有 bss 段。  </p><p><code>entry_addr</code></p><p>操作系统的入口点，引导程序最后将跳转到那里。</p><h4 id="Multiboot-头的图形域"><a href="#Multiboot-头的图形域" class="headerlink" title="Multiboot 头的图形域"></a>Multiboot 头的图形域</h4><p>所有的图形域都通过 flags 的第 2 位开启。它们指出了推荐的图形模式。注意，这只是 OS 映象推荐的模式。如果该模式存在，引导程序将设定它，如果用户不明确指出另一个模式的话。否则，如果可能的话，引导程序将转入一个相似的模式。</p><p>他们的意义如下：</p><p><code>mode_type</code></p><p>如果为 0 就代表线性图形模式，如果为 1 代表标准 EGA 文本模式。所有其他值保留以备将来扩展。注意即使这个域为 0，引导程序也可能设置一个文本模式。  </p><p><code>width</code></p><p>包含列数。在图形模式下它是象素数，在文本模式下它是字符数。0 代表 OS 映象对此没有要求。  </p><p><code>height</code></p><p>包含行数。在图形模式下它是象素数，在文本模式下它是字符数。0 代表 OS 映象对此没有要求。  </p><p><code>depth</code></p><p>在图形模式下，包含每个象素的位数，在文本模式下为 0。0 代表 OS 映象对此没有要求。</p><h3 id="机器状态"><a href="#机器状态" class="headerlink" title="机器状态"></a>机器状态</h3><p>当引导程序调用 32 位操作系统时，机器状态必须如下：</p><p><code>EAX</code></p><p>必须包含魔数 0x2BADB002；这个值指出操作系统是被一个符合 Multiboot 规范的引导程序载入的（这样就算是另一种引导程序也可以引导这个操作系统）。  </p><p><code>EBX</code></p><p>必须包含由引导程序提供的 Multiboot 信息结构的物理地址（参见 引导信息格式）。  </p><p><code>CS</code></p><p>必须是一个偏移量位于 0 到 0xFFFFFFFF 之间的 32 位可读 / 可执行代码段。这里的精确值未定义。  </p><p><code>DS</code></p><p><code>ES</code></p><p><code>FS</code></p><p><code>GS</code></p><p><code>SS</code></p><p>必须是一个偏移量位于 0 到 0xFFFFFFFF 之间的 32 位可读 / 可执行代码段。这里的精确值未定义。  </p><p><code>A20 gate</code></p><p>必须已经开启。  </p><p><code>CR0</code></p><p>第 31 位（PG）必须为 0。第 0 位（PE）必须为 1。其他位未定义。  </p><p><code>EFLAGS</code></p><p>第 17 位（VM）必须为 0。第 9 位（IF）必须为 1 。其他位未定义。</p><p>所有其他的处理器寄存器和标志位未定义。这包括：</p><p><code>ESP</code></p><p>当需要使用堆栈时，OS 映象必须自己创建一个。  </p><p><code>GDTR</code></p><p>尽管段寄存器像上面那样定义了，GDTR 也可能是无效的，所以 OS 映象决不能载入任何段寄存器（即使是载入相同的值也不行！）直到它设定了自己的 GDT。  </p><p><code>IDTR</code></p><p>OS 映象必须在设置完它的 IDT 之后才能开中断。</p><p>尽管如此，其他的机器状态应该被引导程序留做正常的工作顺序，也就是同 BIOS（或者 DOS，如果引导程序是从那里启动的话）初始化的状态一样。换句话说，操作系统应该能够在载入后进行 BIOS 调用，直到它自己重写 BIOS 数据结构之前。还有，引导程序必须将 PIC 设定为正常的 BIOS/DOS 状态，尽管它们有可能在进入 32 位模式时改变它们。</p><h3 id="引导信息格式"><a href="#引导信息格式" class="headerlink" title="引导信息格式"></a>引导信息格式</h3><p>FIXME：将这章像 “OS 映像格式” 那样分解。</p><p>在进入操作系统时，EBX 寄存器包含 Multiboot 信息数据结构的物理地址，引导程序通过它将重要的引导信息传递给操作系统。操作系统可以按自己的需要使用或者忽略任何部分；所有的引导程序传递的信息只是建议性的。</p><p>Multiboot 信息结构和它的相关的子结构可以由引导程序放在任何位置（当然，除了保留给内核和引导模块的区域）。如何在利用之前保护它是操作系统的责任。</p><p>Multiboot 信息结构（就目前为止定义的）的格式如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html">        +-------------------+<br>0       | flags             |    (必需)<br>        +-------------------+<br>4       | mem_lower         |    (如果flags[0]被置位则出现)<br>8       | mem_upper         |    (如果flags[0]被置位则出现)<br>        +-------------------+<br>12      | boot_device       |    (如果flags[1]被置位则出现)<br>        +-------------------+<br>16      | cmdline           |    (如果flags[2]被置位则出现)<br>        +-------------------+<br>20      | mods_count        |    (如果flags[3]被置位则出现)<br>24      | mods_addr         |    (如果flags[3]被置位则出现)<br>        +-------------------+<br>28 - 40 | syms              |    (如果flags[4]或<br>        |                   |        flags[5]被置位则出现)            <br>        +-------------------+<br>44      | mmap_length       |    (如果flags[6]被置位则出现)<br>48      | mmap_addr         |    (如果flags[6]被置位则出现)<br>        +-------------------+<br>52      | drives_length     |    (如果flags[7]被置位则出现)<br>56      | drives_addr       |    (如果flags[7]被置位则出现)<br>        +-------------------+<br>60      | config_table      |    (如果flags[8]被置位则出现)<br>        +-------------------+<br>64      | boot_loader_name  |    (如果flags[9]被置位则出现)<br>        +-------------------+<br>68      | apm_table         |    (如果flags[10]被置位则出现)<br>        +-------------------+<br>72      | vbe_control_info  |    (如果flags[11]被置位则出现)<br>76      | vbe_mode_info     |<br>80      | vbe_mode          |<br>82      | vbe_interface_seg |<br>84      | vbe_interface_off |<br>86      | vbe_interface_len |<br>        +-------------------+<br></code></pre></td></tr></tbody></table></figure><p>第一个 longword 指出 Multiboot 信息结构中的其它域是否有效。所有目前未定义的位必须被引导程序设为 0。操作系统应该忽略任何它不理解的位。因此，flags 域也可以视作一个版本标志符，这样可以无破坏的扩展 Multiboot 信息结构。</p><p>如果设置了 flags 中的第 0 位，则 mem_* 域有效。mem_lower 和 mem_upper 分别指出了低端和高端内存的大小，单位是 K。低端内存的首地址是 0，高端内存的首地址是 1M。低端内存的最大可能值是 640K。返回的高端内存的最大可能值是最大值减去 1M。但并不保证是这个值。</p><p>如果设置了 flags 中的第 1 位，则 boot_device 域有效，并指出引导程序从哪个 BIOS 磁盘设备载入的 OS 映像。如果 OS 映像不是从一个 BIOS 磁盘载入的，这个域就决不能出现（第 3 位必须是 0）。操作系统可以使用这个域来帮助确定它的 root 设备，但并不一定要这样做。boot_device 域由四个单字节的子域组成：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">+-------+-------+-------+-------+<br>| part3 | part2 | part1 | drive |<br>+-------+-------+-------+-------+<br>最低有效字节最高有效字节<br></code></pre></td></tr></tbody></table></figure><p>最高有效字节字节包含了 BIOS 驱动器号，它的格式与 BIOS 的 INT0x13 低级磁盘接口相同：例如，0x00 代表第一个软盘驱动器，0x80 代表第一个硬盘驱动器。</p><p>剩下的三个字节指出了引导分区。part1 指出顶级分区号，part2 指出一个顶级分区中的一个子分区，等等。分区号总是从 0 开始。不使用的分区字节必须被设为 0xFF。例如，如果磁盘被简单的分为单一的一层 DOS 分区，则 part1 包含这个 DOS 分区号，part2 和 part3 都是 0xFF。另一个例子是，如果一个磁盘先被分为 DOS 分区，并且其中的一个 DOS 分区又被分为几个使用 BSD 磁盘标签策略的 BSD 分区，则 part1 包含 DOS 分区号，part2 包含 DOS 分区内的 BSD 子分区，part3 是 0xFF。</p><p>DOS 扩展分区的分区号从 4 开始，而不是像嵌套子分区一样，尽管扩展分区的底层分布就是分层嵌套的。例如，如果引导程序从传统的 DOS 风格磁盘的第二个分区启动，则 part1 是 5，part2 和 part3 都是 0xFF。</p><p>如果设置了 flags longword 的第 2 位，则 cmdline 域有效，并包含要传送给内核的命令行参数的物理地址。命令行参数是一个正常 C 风格的以 0 终止的字符串。</p><p>如果设置了 flags 的第 3 位，则 mods 域指出了同内核一同载入的有哪些引导模块，以及在哪里能找到它们。mods_count 包含了载入的模块的个数；mods_addr 包含了第一个模块结构的物理地址。mods_count 可以是 0，这表示没有载入任何模块，即使设置了 flags 的第 1 位时也有可能是这样。每个模块结构的格式如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">        +-------------------+<br>0       | mod_start         |<br>4       | mod_end           |<br>        +-------------------+<br>8       | string            |<br>        +-------------------+<br>12      | reserved (0)      |<br>        +-------------------+<br></code></pre></td></tr></tbody></table></figure><p>前两个域包含了引导模块的开始和结束地址。string 域提供了一个自定义的与引导模块相关的字符串；它是以 0 中止的 ASCII 字符串，同内核命令行参数一样。如果没有什么与模块有关的字符串，string 域可以是 0。典型情况下，这个字符串也许是命令行参数（例如，如果操作系统将引导模块视作可执行程序的话），或者一个路径名（例如，如果操作系统将引导模块视作文件系统中的文件的话），它的意义取决于操作系统。reserved 域必须由引导程序设为 0 并被操作系统忽略。</p><p><strong>注意：</strong>第 4 位和第 5 位是互斥的。</p><p>如果设置了 flags 的第 4 位，则下面从 Multiboot 信息结构的第 28 位开始的域是有效的：</p><figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">        +-------------------+<br>28      |<span class="hljs-string"> tabsize           </span>|<br>32      |<span class="hljs-string"> strsize           </span>|<br>36      |<span class="hljs-string"> addr              </span>|<br>40      |<span class="hljs-string"> reserved (0)      </span>|<br>        +-------------------+<br></code></pre></td></tr></tbody></table></figure><p>这指出在哪里可以找到 a.out 格式内核映像的符号表。addr 是 a.out 格式的 nlist 结构数组的大小（4 字节无符号长整数）的物理地址，紧接着是数组本身，然后是一系列以 0 中止的 ASCII 字符串的大小（4 字节无符号长整数，加上 sizeof(unsigned long)），然后是字符串本身。tabsize 等于符号表的大小参数（位于符号 section 的头部），strsize 等于符号表指向的字符串表的大小参数（位于 string section 的头部）。注意 tabsize 可以是 0，这意味着没有符号，尽管已经设置了 flags 的第 4 位。</p><p>如果设置了 flags 的第 5 位，则下面从 Multiboot 信息结构的第 28 位开始的域是有效的：</p><figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">        +-------------------+<br>28      |<span class="hljs-string"> num               </span>|<br>32      |<span class="hljs-string"> size              </span>|<br>36      |<span class="hljs-string"> addr              </span>|<br>40      |<span class="hljs-string"> shndx             </span>|<br>        +-------------------+<br></code></pre></td></tr></tbody></table></figure><p>这指出在哪里可以找到 ELF 格式内核映像的 section 头表、每项的大小、一共有几项以及作为名字索引的字符串表。它们对应于可执行可连接格式（ELF）的 program 头中的<code>shdr_*</code> 项（shdr_num 等）。所有的 section 都会被载入，ELF section 头的物理地址域指向所有的 section 在内存中的位置（参见 i386 ELF 文档以得到如何读取 section 头的更多的细节）。注意，shdr_num 可以是 0，标志着没有符号，尽管已经设置了 flags 的第 5 位。</p><p>如果设置了 flags 的第 6 位，则 mmap_* 域是有效的，指出保存由 BIOS 提供的内存分布的缓冲区的地址和长度。mmap_addr 是缓冲区的地址，mmap_length 是缓冲区的总大小。缓冲区由一个或者多个下面的大小 / 结构对（size 实际上是用来跳过下一个对的）组成的：</p><figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">        +-------------------+<br>-4      |<span class="hljs-string"> size              </span>|<br>        +-------------------+<br>0       |<span class="hljs-string"> base_addr_low     </span>|<br>4       |<span class="hljs-string"> base_addr_high    </span>|<br>8       |<span class="hljs-string"> length_low        </span>|<br>12      |<span class="hljs-string"> length_high       </span>|<br>16      |<span class="hljs-string"> type              </span>|<br>        +-------------------+<br></code></pre></td></tr></tbody></table></figure><p>size 是相关结构的大小，单位是字节，它可能大于最小值 20。base_addr_low 是启动地址的低 32 位，base_addr_high 是高 32 位，启动地址总共有 64 位。length_low 是内存区域大小的低 32 位，length_high 是内存区域大小的高 32 位，总共是 64 位。type 是相应地址区间的类型，1 代表可用 RAM，所有其它的值代表保留区域。</p><p>可以保证所提供的内存分布列出了所有可供正常使用的标准内存。</p><p>如果设置了 flags 的第 7 位，则 drives_* 域是有效的，指出第一个驱动器结构的物理地址和这个结构的大小。drives_addr 是地址，drives_length 是驱动器结构的总大小。注意，drives_length 可以是 0。每个驱动器结构的格式如下：  　</p><figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">        +-------------------+<br>0       |<span class="hljs-string"> size              </span>|<br>        +-------------------+<br>4       |<span class="hljs-string"> drive_number      </span>|<br>        +-------------------+<br>5       |<span class="hljs-string"> drive_mode        </span>|<br>        +-------------------+<br>6       |<span class="hljs-string"> drive_cylinders   </span>|<br>8       |<span class="hljs-string"> drive_heads       </span>|<br>9       |<span class="hljs-string"> drive_sectors     </span>|<br>        +-------------------+<br>10 - xx |<span class="hljs-string"> drive_ports       </span>|<br>        +-------------------+<br></code></pre></td></tr></tbody></table></figure><p>size 域指出了结构的大小。依据端口的数量不同，这个大小可能变化。注意，这个大小可能不等于（10 + 2 * 端口数），这是由于对齐的原因。</p><p>drive_number 域包含 BIOS 驱动器号。drive_mode 域代表了引导程序使用的访问模式。目前，模式定义如下：</p><p><code>0</code></p><p>​CHS 模式（传统的 “柱面 / 磁头 / 扇区” 寻址模式）。  　</p><p><code>1</code></p><p>​LBA 模式（逻辑块寻址模式）。</p><p>这三个域，drive_cylinders、drive_heads 和 drive_sectors，指出了 BIOS 检测到的驱动器的参数。drive_cylinders 包含柱面数，drive_heads 包含磁头数，drive_sectors 包含每磁道的扇区数。</p><p>drive_ports 域包含了 BIOS 代码使用的 I/O 端口的数组。这个数组包含 0 个或者多个无符号两字节整数，并且以 0 中止。注意，数组中可能包含任何实际上与驱动器不相关的 I/O 端口（例如 DMA 控制器的端口）。</p><p>如果设置了 flags 的第 8 位，则 config_table 域有效，指出由 GET CONFIGURATION BIOS 调用返回的 ROM 配置表的物理地址。如果这个 BIOS 调用失败了，则这个表的大小必须是 0。</p><p>如果设置了 flags 的第 9 位，则 boot_loader_name 域有效，包含了引导程序名字在物理内存中的地址。引导程序名字是正常的 C 风格的以 0 中止的字符串。</p><p>如果设置了 flags 的第 10 位，则 apm_table 域有效，包含了如下 APM 表的物理地址：</p><figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">        +----------------------+<br>0       |<span class="hljs-string"> version              </span>|<br>2       |<span class="hljs-string"> cseg                 </span>|<br>4       |<span class="hljs-string"> offset               </span>|<br>8       |<span class="hljs-string"> cseg_16              </span>|<br>10      |<span class="hljs-string"> dseg                 </span>|<br>12      |<span class="hljs-string"> flags                </span>|<br>14      |<span class="hljs-string"> cseg_len             </span>|<br>16      |<span class="hljs-string"> cseg_16_len          </span>|<br>18      |<span class="hljs-string"> dseg_len             </span>|<br>        +----------------------+<br></code></pre></td></tr></tbody></table></figure><p>域 version、cseg、offset、cseg_16、dseg、flags、cseg_len、cseg_16_len、dseg_len 分别指出了版本号、保护模式 32 位代码段、入口点的偏移量、保护模式 16 位代码段、保护模式 16 位数据段、标志位、保护模式 32 位代码段的长度、保护模式 16 位代码段的长度和保护模式 16 位数据段的长度。只有 offset 域是 4 字节，其余的域都是 2 字节。参见<a href="http://www.microsoft.com/hwdev/busbios/amp_12.htm">高级电源管理（APM）BIOS 接口规范</a>。</p><p>如果设置了 flags 的第 11 位，则 graphics table 有效。前提是内核已经在 Multiboot 头中指定了一种图形模式。</p><p>域 vbe_control_info 和 vbe_mode_info 分别包含由 VBE 函数 00h 返回的 VBE 控制信息的物理地址和由 VBE 函数 01h 返回的 VBE 模式信息。</p><p>域 vbe_mode 指出了当前的显示模式，其中的信息符合 VBE 3.0 标准。</p><p>其余的域 vbe_interface_seg、vbe_interface_off 和 vbe_interface_len 包含了 VBE 2.0 + 中定义的保护模式接口。如果没有这些信息，这些域都是 0 。注意 VBE 3.0 定义了另一个保护模式接口，它与以前的版本是兼容的。如果你想要使用这些新的保护模式接口，你必须自己找到这个表。</p><p>graphics table 中的域是按照 VBE 设计的，但是 Multiboot 引导程序可以在非 VBE 模式下模拟 VBE 模式。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>注意:</strong> 下面的内容不是规范文档的一部分，它们是给操作系统和引导程序编写者提供的示例。</p><ul><li><p>PC 机注记</p></li><li><p>BIOS 设备映射技术</p></li><li><p>OS 代码示例</p></li><li><p>引导程序代码示例</p></li></ul><h3 id="PC-机注记"><a href="#PC-机注记" class="headerlink" title="PC 机注记"></a>PC 机注记</h3><p>在使用 Multiboot 信息结构中 flags 参数的第 0 位时，如果使用的引导程序使用较老的 BIOS 接口，或者还不被支持的最新的接口（参见有关第 6 位的描述），则返回的内存大小可能是 15 或者 63M。因此强烈推荐引导程序进行彻底的内存检查。&nbsp;</p><p>在使用 Multiboot 信息结构中 flags 参数的第 1 位时，我们发现在最好的情况下，将哪个 BIOS 驱动器映射到哪个操作系统的设备驱动程序的决定也不容易做出。针对各种各样的操作系统提出了许多的笨拙的办法但都没有解决问题，大多数在很多情况下都会失败。为了鼓励使用通用的方法解决这个问题，我们提供了 2 种 BIOS 设备映射技术（参见 BIOS 设备映射技术）。</p><p>在使用 Multiboot 信息结构中 flags 参数的第 6 位时，一定要注意这里用到的数据结构（自 BaseAddrLow 开始）时由 INT 15h, AX=E820h——查询系统地址地图调用返回的数据。参见<a href="http://www.gnu.org/software/grub/manual/multiboot/grub.info.html#Query%20System%20Address%20Map">查询系统地址映射</a>。这里的接口用来使一个引导程序可以不用修改的同进行过合理扩展的 BIOS 接口共同工作，如果这些扩展只是给予操作系统更多的信息的话。</p><h3 id="BIOS-设备映射技术"><a href="#BIOS-设备映射技术" class="headerlink" title="BIOS 设备映射技术"></a>BIOS 设备映射技术</h3><p>这两个技术应该可以用于任何的 PC 操作系统，并且也不需要驱动程序本身提供任何的特殊支持。本节将大量的讨论细节问题，尤其是 I/O 限制技术。</p><p>通用的规则是数据比较技术，它是快速但丑陋的解决方案。它在大多数情况下工作正常，但是并不总是这样，不过它相对简单。</p><p>I/O 限制技术要复杂得多，但它更有可能在所有情况下解决问题，另外还允许在并非所有的 BIOS 设备拥有操作系统的驱动程序时访问有驱动程序的 BIOS 设备。</p><ul><li><p>数据比较技术</p></li><li><p>I/O 限制技术</p></li></ul><h3 id="数据比较技术"><a href="#数据比较技术" class="headerlink" title="数据比较技术"></a>数据比较技术</h3><p>在激活 _任何_设备驱动程序之前，要从每个磁盘上的相似扇区中收集足够的数据，这样就可以区分每个扇区。</p><p>在激活了设备驱动程序之后，使用操作系统驱动比较不同驱动器的数据。这样就可以为映射提供足够的信息。</p><p>问题：</p><ol><li>一些 BIOS 设备上的数据可能是相同的（所以从 BIOS 读取设备信息的方法有可能失败）。</li><li>可能有一些 BIOS 不可访问的设备同 BIOS 用到的设备相同（所以这时这种方法也可能会宣告失败）。</li></ol><h3 id="I-x2F-O-限制技术"><a href="#I-x2F-O-限制技术" class="headerlink" title="I/O 限制技术"></a>I/O 限制技术</h3><p>第一步并不是必要的，但首先为设备驱动程序创建 copy-on-write 映射。随后创建 洁净 BIOS 虚拟机的原始拷贝。</p><p>对于每个设备驱动程序，决定哪个 BIOS 设备不可访问，方法是：</p><ol><li>创建一个洁净的 BIOS 虚拟机。</li><li>将设备驱动程序要求的 I/O 区域在 I/O 允许位图中设置为无权限（既不能读也不能写）。</li><li>访问每个设备。</li><li>记录哪些设备访问成功，以及哪些试图访问受限 I/O 区域（这将可能是一个 xor 情景）。</li></ol><p>对于每个设备驱动程序，假设已知其中有多少个 BIOS 设备（这个表中应该没有缝隙），应该很容易的确定哪些设备受这些控制器控制。</p><p>通常，每个拥有 BIOS 号的控制器上你至多有两个磁盘，它们总是从控制器逻辑号最低的设备数起。</p><h3 id="OS-代码示例"><a href="#OS-代码示例" class="headerlink" title="OS 代码示例"></a>OS 代码示例</h3><p>在这个发行版中，包括了示例 Multiboot 内核 kernel。这个内核只在屏幕上输出 Multiboot 信息结构，所以你可以利用这个内核检测一个 Multiboot 兼容的引导程序，或者作为如何实现一个 Multiboot 内核的参考。源文件可以在 GRUB 发行版的 docs 目录中找到。</p><p>内核 kernel 仅由三个文件组成：boot.S、kernel.c 和 multiboot.h。汇编源代码 boot.S 使用 GAS 汇编格式，包含符合本规范的 Multiboot 信息结构。当一个 Multiboot 兼容的引导程序载入并执行它时，它初始化堆栈指针和 EFLAGS，然后调用 kernel.c 中定义的函数 cmain。如果 cmain 返回，则它显示一条消息通知用户进入停机状态并停止知道你按下 reset 键。文件 kernel.c 包含函数 cmain，它检查引导程序传递来的魔数是否有效等等，以及一些向屏幕输出消息的函数。文件 multiboot.h 定义了一些宏，如 Multiboot 头的魔数，Multiboot 头结构和 Multiboot 信息结构等。&nbsp;</p><ul><li><p>multiboot.h</p></li><li><p>boot.S</p></li><li><p>kernel.c</p></li><li><p>其他 Multiboot 内核</p></li></ul><h4 id="multiboot-h"><a href="#multiboot-h" class="headerlink" title="multiboot.h"></a>multiboot.h</h4><p>这是 <code>multiboot.h</code> 文件中的源代码：  　</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* multiboot.h - Multiboot 的 header */</span><br><span class="hljs-comment">/* Copyright (C) 1999, 2001  Free Software Foundation, Inc.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This program is free software; you can redistribute it and/or modify</span><br><span class="hljs-comment">   it under the terms of the GNU General Public License as published by</span><br><span class="hljs-comment">   the Free Software Foundation; either version 2 of the License, or</span><br><span class="hljs-comment">   (at your option) any later version.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This program is distributed in the hope that it will be useful,</span><br><span class="hljs-comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="hljs-comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><br><span class="hljs-comment">   GNU General Public License for more details.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   You should have received a copy of the GNU General Public License</span><br><span class="hljs-comment">   along with this program; if not, write to the Free Software</span><br><span class="hljs-comment">   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */</span><br><br><span class="hljs-comment">/* 宏定义。 */</span><br><br><span class="hljs-comment">/* Multiboot header 的魔数。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MULTIBOOT_HEADER_MAGIC          0x1BADB002</span><br><br><span class="hljs-comment">/* Multiboot header 的标志。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ELF__</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MULTIBOOT_HEADER_FLAGS         0x00000003</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MULTIBOOT_HEADER_FLAGS         0x00010003</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* Multiboot 兼容的引导程序传递来的魔数。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MULTIBOOT_BOOTLOADER_MAGIC      0x2BADB002</span><br><br><span class="hljs-comment">/* 堆栈大小 (16KB)。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE                      0x4000</span><br><br><span class="hljs-comment">/* C 符号格式。HAVE_ASM_USCORE 由 configure 定义。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_ASM_USCORE</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EXT_C(sym)                     _ ## sym</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EXT_C(sym)                     sym</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ASM</span><br><span class="hljs-comment">/* 不要在 boot.S 中 include 这里。 */</span><br><br><span class="hljs-comment">/* 类型定义。 */</span><br><br><span class="hljs-comment">/* Multiboot header。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiboot_header</span></span><br><span class="hljs-class">{</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> magic;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> checksum;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> header_addr;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> load_addr;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> load_end_addr;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bss_end_addr;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> entry_addr;<br>} <span class="hljs-type">multiboot_header_t</span>;<br><br><span class="hljs-comment">/* a.out 符号表。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aout_symbol_table</span></span><br><span class="hljs-class">{</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tabsize;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> strsize;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> reserved;<br>} <span class="hljs-type">aout_symbol_table_t</span>;<br><br><span class="hljs-comment">/* ELF 的 section header table。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf_section_header_table</span></span><br><span class="hljs-class">{</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> shndx;<br>} <span class="hljs-type">elf_section_header_table_t</span>;<br><br><span class="hljs-comment">/* Multiboot 信息。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiboot_info</span></span><br><span class="hljs-class">{</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mem_lower;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mem_upper;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> boot_device;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cmdline;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mods_count;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mods_addr;<br>  <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">  {</span><br>    <span class="hljs-type">aout_symbol_table_t</span> aout_sym;<br>    <span class="hljs-type">elf_section_header_table_t</span> elf_sec;<br>  } u;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_length;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_addr;<br>} <span class="hljs-type">multiboot_info_t</span>;<br><br><span class="hljs-comment">/* 模块结构。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span></span><br><span class="hljs-class">{</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mod_start;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mod_end;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-built_in">string</span>;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> reserved;<br>} <span class="hljs-type">module_t</span>;<br><br><span class="hljs-comment">/* 内存分布。小心，偏移量 0 是 base_addr_low 而不是 size 。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memory_map</span></span><br><span class="hljs-class">{</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> base_addr_low;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> base_addr_high;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length_low;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length_high;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> type;<br>} <span class="hljs-type">memory_map_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* ! ASM */</span></span><br></code></pre></td></tr></tbody></table></figure><h4 id="boot-S"><a href="#boot-S" class="headerlink" title="boot.S"></a>boot.S</h4><p>文件 <code>boot.S</code> 的内容是：  　</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* boot.S - 引导内核 */<br>/* Copyright (C) 1999, 2001  Free Software Foundation, Inc.<br><br>   This program is free software; you can redistribute it and/or modify<br>   it under the terms of the GNU General Public License as published by<br>   the Free Software Foundation; either version 2 of the License, or<br>   (at your option) any later version.<br><br>   This program is distributed in the hope that it will be useful,<br>   but WITHOUT ANY WARRANTY; without even the implied warranty of<br>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>   GNU General Public License for more details.<br><br>   You should have received a copy of the GNU General Public License<br>   along with this program; if not, write to the Free Software<br>   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */<br><br>#define ASM     1<br>#include &lt;multiboot.h&gt;<br><br>        .text<br><br>        .globl  start, _start<br>start:<br>_start:<br>        jmp     multiboot_entry<br><br>        /* 32 位对齐。 */<br>        .align  4<br><br>        /* Multiboot header。 */<br>multiboot_header:<br>        /* magic */<br>        .long   MULTIBOOT_HEADER_MAGIC<br>        /* flags */<br>        .long   MULTIBOOT_HEADER_FLAGS<br>        /* checksum */<br>        .long   -(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)<br>#ifndef __ELF__<br>        /* header_addr */<br>        .long   multiboot_header<br>        /* load_addr */<br>        .long   _start<br>        /* load_end_addr */<br>        .long   _edata<br>        /* bss_end_addr */<br>        .long   _end<br>        /* entry_addr */<br>        .long   multiboot_entry<br>#endif /* ! __ELF__ */<br><br>multiboot_entry:<br>        /* 初始化堆栈指针。 */<br>        movl    $(stack + STACK_SIZE), %esp<br><br>        /* 重置 EFLAGS。 */<br>        pushl   $0<br>        popf<br><br>        /* 将指向 Multiboot 信息结构的指针入栈。 */<br>        pushl   %ebx<br>        /* 将魔数入栈。 */<br>        pushl   %eax<br><br>        /* 现在进入 C main 函数... */<br>        call    EXT_C(cmain)<br><br>        /* 停机。 */<br>        pushl   $halt_message<br>        call    EXT_C(printf)<br><br>loop:   hlt<br>        jmp     loop<br><br>halt_message:<br>        .asciz  "Halted."<br><br>        /* 我们的堆栈区。 */<br>        .comm   stack, STACK_SIZE<br></code></pre></td></tr></tbody></table></figure><h4 id="kernel-c"><a href="#kernel-c" class="headerlink" title="kernel.c"></a>kernel.c</h4><p>文件 <code>kernel.c</code> 中的内容：  　</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* kernel.c - 内核的 C 语言部分 */</span><br><span class="hljs-comment">/* Copyright (C) 1999  Free Software Foundation, Inc.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This program is free software; you can redistribute it and/or modify</span><br><span class="hljs-comment">   it under the terms of the GNU General Public License as published by</span><br><span class="hljs-comment">   the Free Software Foundation; either version 2 of the License, or</span><br><span class="hljs-comment">   (at your option) any later version.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   This program is distributed in the hope that it will be useful,</span><br><span class="hljs-comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="hljs-comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><br><span class="hljs-comment">   GNU General Public License for more details.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   You should have received a copy of the GNU General Public License</span><br><span class="hljs-comment">   along with this program; if not, write to the Free Software</span><br><span class="hljs-comment">   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;multiboot.h&gt;</span></span><br><br><span class="hljs-comment">/* 宏定义。 */</span><br><br><span class="hljs-comment">/* 检测 FLAGS 中的位 BIT 是否被置位。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHECK_FLAG(flags,bit)   ((flags) &amp; (1 &lt;&lt; (bit)))</span><br><br><span class="hljs-comment">/* 与显示相关的设置。 */</span><br><span class="hljs-comment">/* 列数。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COLUMNS                 80</span><br><span class="hljs-comment">/* 行数。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LINES                   24</span><br><span class="hljs-comment">/* 字符属性。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATTRIBUTE               7</span><br><span class="hljs-comment">/* 显存地址。 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VIDEO                   0xB8000</span><br><br><span class="hljs-comment">/* 变量。 */</span><br><span class="hljs-comment">/* X 坐标。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> xpos;<br><span class="hljs-comment">/* Y 坐标。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> ypos;<br><span class="hljs-comment">/* 指向显存。 */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *video;<br><br><span class="hljs-comment">/* 前导声明。 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cmain</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> magic, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">cls</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">itoa</span> <span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> base, <span class="hljs-type">int</span> d)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">putchar</span> <span class="hljs-params">(<span class="hljs-type">int</span> c)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">printf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-comment">/* 检查 MAGIC 是否有效并打印 ADDR 指向的 Multiboot 信息结构。 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">cmain</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> magic, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>{<br>  <span class="hljs-type">multiboot_info_t</span> *mbi;<br><br>  <span class="hljs-comment">/* 清屏。 */</span><br>  cls ();<br><br>  <span class="hljs-comment">/* 引导装载器是否符合 Multiboot 规范？ */</span><br>  <span class="hljs-keyword">if</span> (magic != MULTIBOOT_BOOTLOADER_MAGIC)<br>    {<br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"Invalid magic number: 0x%x/n"</span>, (<span class="hljs-type">unsigned</span>) magic);<br>      <span class="hljs-keyword">return</span>;<br>    }<br><br>  <span class="hljs-comment">/* 将 MBI 指向 Multiboot 信息结构。 */</span><br>  mbi = (<span class="hljs-type">multiboot_info_t</span> *) addr;<br><br>  <span class="hljs-comment">/* 输出标志。 */</span><br>  <span class="hljs-built_in">printf</span> (<span class="hljs-string">"flags = 0x%x/n"</span>, (<span class="hljs-type">unsigned</span>) mbi-&gt;flags);<br><br>  <span class="hljs-comment">/* mem_* 是否有效？ */</span><br>  <span class="hljs-keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">0</span>))<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"mem_lower = %uKB, mem_upper = %uKB/n"</span>,<br>            (<span class="hljs-type">unsigned</span>) mbi-&gt;mem_lower, (<span class="hljs-type">unsigned</span>) mbi-&gt;mem_upper);<br><br>  <span class="hljs-comment">/* boot_device 是否有效？ */</span><br>  <span class="hljs-keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">1</span>))<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"boot_device = 0x%x/n"</span>, (<span class="hljs-type">unsigned</span>) mbi-&gt;boot_device);<br><br>  <span class="hljs-comment">/* 是否有命令行参数？ */</span><br>  <span class="hljs-keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">2</span>))<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">"cmdline = %s/n"</span>, (<span class="hljs-type">char</span> *) mbi-&gt;cmdline);<br><br>  <span class="hljs-comment">/* mods_* 是否有效？ */</span><br>  <span class="hljs-keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">3</span>))<br>    {<br>      <span class="hljs-type">module_t</span> *mod;<br>      <span class="hljs-type">int</span> i;<br><br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"mods_count = %d, mods_addr = 0x%x/n"</span>,<br>              (<span class="hljs-type">int</span>) mbi-&gt;mods_count, (<span class="hljs-type">int</span>) mbi-&gt;mods_addr);<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, mod = (<span class="hljs-type">module_t</span> *) mbi-&gt;mods_addr;<br>           i &lt; mbi-&gt;mods_count;<br>           i++, mod += <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">module_t</span>))<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">" mod_start = 0x%x, mod_end = 0x%x, string = %s/n"</span>,<br>                (<span class="hljs-type">unsigned</span>) mod-&gt;mod_start,<br>                (<span class="hljs-type">unsigned</span>) mod-&gt;mod_end,<br>                (<span class="hljs-type">char</span> *) mod-&gt;<span class="hljs-built_in">string</span>);<br>    }<br><br>  <span class="hljs-comment">/* 第 4 位和第 5 位是互斥的！ */</span><br>  <span class="hljs-keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">4</span>) &amp;&amp; CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">5</span>))<br>    {<br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"Both bits 4 and 5 are set./n"</span>);<br>      <span class="hljs-keyword">return</span>;<br>    }<br><br>  <span class="hljs-comment">/* 是否有 a.out 符号表？ */</span><br>  <span class="hljs-keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">4</span>))<br>    {<br>      <span class="hljs-type">aout_symbol_table_t</span> *aout_sym = &amp;(mbi-&gt;u.aout_sym);<br><br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"aout_symbol_table: tabsize = 0x%0x, "</span><br>              <span class="hljs-string">"strsize = 0x%x, addr = 0x%x/n"</span>,<br>              (<span class="hljs-type">unsigned</span>) aout_sym-&gt;tabsize,<br>              (<span class="hljs-type">unsigned</span>) aout_sym-&gt;strsize,<br>              (<span class="hljs-type">unsigned</span>) aout_sym-&gt;addr);<br>    }<br><br>  <span class="hljs-comment">/* 是否有 ELF section header table？ */</span><br>  <span class="hljs-keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">5</span>))<br>    {<br>      <span class="hljs-type">elf_section_header_table_t</span> *elf_sec = &amp;(mbi-&gt;u.elf_sec);<br><br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"elf_sec: num = %u, size = 0x%x,"</span><br>              <span class="hljs-string">" addr = 0x%x, shndx = 0x%x/n"</span>,<br>              (<span class="hljs-type">unsigned</span>) elf_sec-&gt;num, (<span class="hljs-type">unsigned</span>) elf_sec-&gt;size,<br>              (<span class="hljs-type">unsigned</span>) elf_sec-&gt;addr, (<span class="hljs-type">unsigned</span>) elf_sec-&gt;shndx);<br>    }<br><br>  <span class="hljs-comment">/* mmap_* 是否有效？ */</span><br>  <span class="hljs-keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="hljs-number">6</span>))<br>    {<br>      <span class="hljs-type">memory_map_t</span> *mmap;<br><br>      <span class="hljs-built_in">printf</span> (<span class="hljs-string">"mmap_addr = 0x%x, mmap_length = 0x%x/n"</span>,<br>              (<span class="hljs-type">unsigned</span>) mbi-&gt;mmap_addr, (<span class="hljs-type">unsigned</span>) mbi-&gt;mmap_length);<br>      <span class="hljs-keyword">for</span> (mmap = (<span class="hljs-type">memory_map_t</span> *) mbi-&gt;mmap_addr;<br>           (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) mmap &lt; mbi-&gt;mmap_addr + mbi-&gt;mmap_length;<br>           mmap = (<span class="hljs-type">memory_map_t</span> *) ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) mmap<br>                                    + mmap-&gt;size + <span class="hljs-keyword">sizeof</span> (mmap-&gt;size)))<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">" size = 0x%x, base_addr = 0x%x%x,"</span><br>                <span class="hljs-string">" length = 0x%x%x, type = 0x%x/n"</span>,<br>                (<span class="hljs-type">unsigned</span>) mmap-&gt;size,<br>                (<span class="hljs-type">unsigned</span>) mmap-&gt;base_addr_high,<br>                (<span class="hljs-type">unsigned</span>) mmap-&gt;base_addr_low,<br>                (<span class="hljs-type">unsigned</span>) mmap-&gt;length_high,<br>                (<span class="hljs-type">unsigned</span>) mmap-&gt;length_low,<br>                (<span class="hljs-type">unsigned</span>) mmap-&gt;type);<br>    }<br>}<br><br><span class="hljs-comment">/* 清屏并初始化 VIDEO，XPOS 和 YPOS。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">cls</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>  <span class="hljs-type">int</span> i;<br><br>  video = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) VIDEO;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; COLUMNS * LINES * <span class="hljs-number">2</span>; i++)<br>    *(video + i) = <span class="hljs-number">0</span>;<br><br>  xpos = <span class="hljs-number">0</span>;<br>  ypos = <span class="hljs-number">0</span>;<br>}<br><br><span class="hljs-comment">/* 将整数 D 转换为字符串并保存在 BUF 中。如果 BASE 为 'd'，则 D 为十进制，如果 BASE 为 'x'，则 D 为十六进制。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">itoa</span> <span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> base, <span class="hljs-type">int</span> d)</span><br>{<br>  <span class="hljs-type">char</span> *p = buf;<br>  <span class="hljs-type">char</span> *p1, *p2;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ud = d;<br>  <span class="hljs-type">int</span> divisor = <span class="hljs-number">10</span>;<br><br>  <span class="hljs-comment">/* 如果指定了 %d 并且 D 是负数，在开始添上负号。 */</span><br>  <span class="hljs-keyword">if</span> (base == <span class="hljs-string">'d'</span> &amp;&amp; d &lt; <span class="hljs-number">0</span>)<br>    {<br>      *p++ = <span class="hljs-string">'-'</span>;<br>      buf++;<br>      ud = -d;<br>    }<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base == <span class="hljs-string">'x'</span>)<br>    divisor = <span class="hljs-number">16</span>;<br><br>  <span class="hljs-comment">/* 用 DIVISOR 去除 UD 直到 UD == 0。 */</span><br>  <span class="hljs-keyword">do</span><br>    {<br>      <span class="hljs-type">int</span> remainder = ud % divisor;<br><br>      *p++ = (remainder &lt; <span class="hljs-number">10</span>) ? remainder + <span class="hljs-string">'0'</span> : remainder + <span class="hljs-string">'a'</span> - <span class="hljs-number">10</span>;<br>    }<br>  <span class="hljs-keyword">while</span> (ud /= divisor);<br><br>  <span class="hljs-comment">/* 在字符串尾添上终结符。 */</span><br>  *p = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/* 反转 BUF。 */</span><br>  p1 = buf;<br>  p2 = p - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (p1 &lt; p2)<br>    {<br>      <span class="hljs-type">char</span> tmp = *p1;<br>      *p1 = *p2;<br>      *p2 = tmp;<br>      p1++;<br>      p2--;<br>    }<br>}<br><br><span class="hljs-comment">/* 在屏幕上输出字符 C 。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">putchar</span> <span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>{<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'/n'</span> || c == <span class="hljs-string">'/r'</span>)<br>    {<br>    newline:<br>      xpos = <span class="hljs-number">0</span>;<br>      ypos++;<br>      <span class="hljs-keyword">if</span> (ypos &gt;= LINES)<br>        ypos = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span>;<br>    }<br><br>  *(video + (xpos + ypos * COLUMNS) * <span class="hljs-number">2</span>) = c &amp; <span class="hljs-number">0xFF</span>;<br>  *(video + (xpos + ypos * COLUMNS) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) = ATTRIBUTE;<br><br>  xpos++;<br>  <span class="hljs-keyword">if</span> (xpos &gt;= COLUMNS)<br>    <span class="hljs-keyword">goto</span> newline;<br>}<br><br><span class="hljs-comment">/* 格式化字符串并在屏幕上输出，就像 libc 函数 printf 一样。 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">printf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span><br>{<br>  <span class="hljs-type">char</span> **arg = (<span class="hljs-type">char</span> **) &amp;format;<br>  <span class="hljs-type">int</span> c;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">20</span>];<br><br>  arg++;<br><br>  <span class="hljs-keyword">while</span> ((c = *format++) != <span class="hljs-number">0</span>)<br>    {<br>      <span class="hljs-keyword">if</span> (c != <span class="hljs-string">'%'</span>)<br>        <span class="hljs-built_in">putchar</span> (c);<br>      <span class="hljs-keyword">else</span><br>        {<br>          <span class="hljs-type">char</span> *p;<br><br>          c = *format++;<br>          <span class="hljs-keyword">switch</span> (c)<br>            {<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'d'</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'u'</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'x'</span>:<br>              itoa (buf, c, *((<span class="hljs-type">int</span> *) arg++));<br>              p = buf;<br>              <span class="hljs-keyword">goto</span> <span class="hljs-built_in">string</span>;<br>              <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">'s'</span>:<br>              p = *arg++;<br>              <span class="hljs-keyword">if</span> (! p)<br>                p = <span class="hljs-string">"(null)"</span>;<br><br>            <span class="hljs-built_in">string</span>:<br>              <span class="hljs-keyword">while</span> (*p)<br>                <span class="hljs-built_in">putchar</span> (*p++);<br>              <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">default</span>:<br>              <span class="hljs-built_in">putchar</span> (*((<span class="hljs-type">int</span> *) arg++));<br>              <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="其他-Multiboot-内核"><a href="#其他-Multiboot-内核" class="headerlink" title="其他 Multiboot 内核"></a>其他 Multiboot 内核</h3><p>可以从 Multiboot 内核那里得到其它有用的信息，如 GNU Mach 和 Fiasco &lt;<a href="http://os.inf.tu-dresden.de/fiasco/">http://os.inf.tu-dresden.de/fiasco/</a>&gt;。最后，很有必要介绍一下 OSKit &lt;<a href="http://www.cs.utah.edu/projects/flux/oskit/">http://www.cs.utah.edu/projects/flux/oskit/</a>&gt;，它提供了一个支持本规范的库。</p><h3 id="引导程序代码示例"><a href="#引导程序代码示例" class="headerlink" title="引导程序代码示例"></a>引导程序代码示例</h3><p>GNU GRUB 项目是一个完全支持的 Multiboot 的引导程序，支持本规范中所有必需的和可选的特性。目前并没有公开的发行版，但是可以从这里得到：</p><p>&lt;<a href="ftp://alpha.gnu.org/gnu/grub">ftp://alpha.gnu.org/gnu/grub</a>&gt;</p><p>参见网页 &lt;<a href="http://www.gnu.org/software/grub/grub.html">http://www.gnu.org/software/grub/grub.html</a>&gt;，以得到更多信息。</p><h2 id="本规范的修改日志"><a href="#本规范的修改日志" class="headerlink" title="本规范的修改日志"></a>本规范的修改日志</h2><p>0.7</p><ul><li>Multiboot 标准更名为 Multiboot 规范。</li><li>在 Multiboot 头加入了图形域。</li><li>在 Multiboot 信息中加入了 BIOS 驱动信息、BIOS 配置表、引导程序名、APM 信息及图形信息。</li><li>使用 Texinfo 格式重写了规范。</li><li>重写了规范，用于更严谨。</li><li>维护者由 Bryan Ford 和 Erich Stefan Boleyn 变更为 GNU GRUB 维护团队 <a href="mailto:bug-grub@gnu.org">bug-grub@gnu.org</a>。</li></ul><p>0.6</p><ul><li>修改了一些词汇。</li><li>头校验和。</li><li>对传递给操作系统的机器状态进行了分类。</li></ul><p>0.5</p><ul><li>名称变更。</li></ul><p>0.4</p><ul><li>添加了版本。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>Multiboot 规范</li><li>Multiboot 规范简介<ul><li>Multiboot 规范诞生的背景</li><li>目标架构</li><li>目标操作系统</li><li>引导源</li><li>在引导时配置操作系统</li><li>如何使操作系统开发更容易</li><li>引导模块</li></ul></li><li>本 Multiboot 规范中所用术语的定义</li><li>Multiboot 规范的精确定义<ul><li>OS 映像格式<ul><li>Multiboot 头的分布</li><li>Multiboot 头的 magic 域</li><li>Multiboot 头的地址域</li><li>Multiboot 头的图形域</li></ul></li><li>机器状态</li><li>引导信息格式</li></ul></li><li>示例<ul><li>PC 机注记</li><li>BIOS 设备映射技术<ul><li>数据比较技术</li><li>I/O 限制技术</li></ul></li><li>OS 代码示例<ul><li>multiboot.h</li><li>boot.S</li><li>kernel.c</li><li>其他 Multiboot 内核</li></ul></li><li>引导程序代码示例</li></ul></li><li>本规范的修改日志</li><li>索引</li></ul>]]></content>
      
      
      <categories>
          
          <category> 好文转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>va_list系列的使用及问题</title>
      <link href="/posts/608e8634/"/>
      <url>/posts/608e8634/</url>
      
        <content type="html"><![CDATA[<h2 id="va-list"><a href="#va-list" class="headerlink" title="va_list"></a>va_list</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>引自 <a href="https://www.runoob.com/cprogramming/c-standard-library-stdarg-h.html">https://www.runoob.com/cprogramming/c-standard-library-stdarg-h.html</a></p></blockquote><p><strong>stdarg.h</strong> 头文件定义了一个变量类型 <strong>va_list</strong> 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。</p><p>可变参数的函数通在参数列表的末尾是使用省略号(,…)定义的。</p><h4 id="库变量"><a href="#库变量" class="headerlink" title="库变量"></a>库变量</h4><p>下面是头文件 stdarg.h 中定义的变量类型：</p><table><thead><tr><th align="left">序号</th><th align="left">变量 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>va_list</strong> 这是一个适用于 <strong>va_start()、va_arg()</strong> 和 <strong>va_end()</strong> 这三个宏存储信息的类型。</td></tr></tbody></table><h4 id="库宏"><a href="#库宏" class="headerlink" title="库宏"></a>库宏</h4><p>下面是头文件 stdarg.h 中定义的宏：</p><table><thead><tr><th align="left">序号</th><th align="left">宏 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_start.html">void va_start(va_list ap, last_arg)</a> 这个宏初始化 <strong>ap</strong> 变量，它与 <strong>va_arg</strong> 和 <strong>va_end</strong> 宏是一起使用的。<strong>last_arg</strong> 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_arg.html">type va_arg(va_list ap, type)</a> 这个宏检索函数参数列表中类型为 <strong>type</strong> 的下一个参数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_end.html">void va_end(va_list ap)</a> 这个宏允许使用了 <strong>va_start</strong> 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 <strong>va_end</strong>，则结果为未定义。</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>首先包含<code>stdarg.h</code>头文件</li><li>使用<code>va_list</code>初始化 指针</li><li>使用<code>va_start</code> 将 第2步中创建的指针添加、还有第一个参数</li><li>通过<code>va_arg</code> 将 第2步中创建的指针添加、以及要取的数据的类型</li><li>…</li><li>不使用<code>va_list</code>后，释放<code>va_start</code>的指针</li></ol><p>示例如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, ...)</span>{<br>    va_list ap;<br>    <span class="hljs-type">int</span> a = p1;<br>    va_start(ap, p1);<br>    <span class="hljs-type">double</span> b = va_arg(ap,<span class="hljs-type">double</span>);<br>    <span class="hljs-type">char</span> c  = va_arg(ap,<span class="hljs-type">int</span>);<br>    <span class="hljs-type">char</span> *d = va_arg(ap,<span class="hljs-type">char</span> *);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:%d\r\nb:%lf\r\nc:%d\r\nd:%s\r\n"</span>,a,b,c,d);<br>    va_end(ap);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">double</span> b = <span class="hljs-number">2.2</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-number">0x33</span>;<br>    <span class="hljs-type">char</span> *d = <span class="hljs-string">"abcderf"</span>;<br>    test(a,b,c,d);<br>}<br></code></pre></td></tr></tbody></table></figure><p>将上述代码保存为test.c，使用命令 <code>gcc test.c </code>然后 <code>./a.out</code>执行</p><p>正常输出</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">a:1<br>b:2.200000<br>c:51<br>d:abcderf<br></code></pre></td></tr></tbody></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>第一次写的代码为以下，编译时爆出几个警告，刚开始没注意，后面运行时发现<code>core dumped.</code> 遂回头查产生改现象的原因。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, ...)</span>{<br>    va_list ap;<br>    <span class="hljs-type">int</span> a = p1;<br>    va_start(ap, p1);<br>    <span class="hljs-type">float</span> b = va_arg(ap,<span class="hljs-type">float</span>);<br>    <span class="hljs-type">char</span> c  = va_arg(ap,<span class="hljs-type">char</span>);<br>    <span class="hljs-type">char</span> *d = va_arg(ap,<span class="hljs-type">char</span> *);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:%d\r\nb:%lf\r\nc:%d\r\nd:%s\r\n"</span>,a,b,c,d);<br>    va_end(ap);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">float</span> b = <span class="hljs-number">2.2</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-number">0x33</span>;<br>    <span class="hljs-type">char</span> *d = <span class="hljs-string">"abcderf"</span>;<br>    test(a,b,c,d);<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们注意到有两个warning，翻译一下：当通过<code>...</code>时，<code>float</code>被提升为<code>double</code>，另一个也是类似，<code>char</code> 被提升为<code>int</code>，<strong>所以使用<code>va_arg</code>访问时，传入参数类型为<code>char</code>，需要用<code>va_arg(ap,int)</code>；传入参数为<code>float</code>时，需使用<code>va_arg(arg,double)</code></strong> 。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[gonglja@archlinux hurlex-doc]$ gcc -g0 test.c <br>In file included from test.c:2:<br>test.c: In function ‘test’:<br>test.c:8:25: warning: ‘float’ is promoted to ‘double’ when passed through ‘...’<br>    8 |     float b = va_arg(ap,float);<br>      |                         ^<br>test.c:8:25: note: (so you should pass ‘double’ not ‘float’ to ‘va_arg’)<br>test.c:8:25: note: if this code is reached, the program will abort<br>test.c:9:25: warning: ‘char’ is promoted to ‘int’ when passed through ‘...’<br>    9 |     char c  = va_arg(ap,char);<br>      |                         ^<br>test.c:9:25: note: if this code is reached, the program will abort<br>[gonglja@archlinux hurlex-doc]$ ./a.out <br>Illegal instruction (core dumped)<br>[gonglja@archlinux hurlex-doc]$ <br><br></code></pre></td></tr></tbody></table></figure><p>修改后，程序正常运行。</p><p>为什么 当通过<code>...</code>时，<code>float</code>被提升为<code>double</code>？<code>char</code> 提升为<code>int</code>呢？<del>==猜测是由于字节对齐引起的==</del>。</p><p><del>为了验证我们的猜测，在这个地方，我们看一下汇编代码，</del></p><p><del>由于涉及到浮点数，为了简单，我们简化一下代码，去掉浮点数相关。</del></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> p1, ...)</span>{<br>    va_list ap;<br>    <span class="hljs-type">int</span> a = p1;<br>    va_start(ap, p1);<br>    <span class="hljs-type">char</span> c  = va_arg(ap,<span class="hljs-type">char</span>);<span class="hljs-comment">// 此处存在问题，应改为va_arg(ap,int)</span><br>    <span class="hljs-type">char</span> *d = va_arg(ap,<span class="hljs-type">char</span> *);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:%d\r\nc:%d\r\nd:%s\r\n"</span>,a,c,d);<br>    va_end(ap);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-number">51</span>;<br>    <span class="hljs-type">char</span> *d = <span class="hljs-string">"abcderf"</span>;<br>    test(a,c,d);<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过 <code>gcc -S test.c</code> 生成 <code>test.s</code>文件，汇编源码如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.file"test.c"<br>.text<br>.globltest<br>.typetest, @function<br>test:<br>.LFB0:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>subq$120, %rsp<br>movl%edi, -228(%rbp)<br>movq%rsi, -168(%rbp)<br>movq%rdx, -160(%rbp)<br>movq%rcx, -152(%rbp)<br>movq%r8, -144(%rbp)<br>movq%r9, -136(%rbp)<br>testb%al, %al<br>je.L2<br>movaps%xmm0, -128(%rbp)<br>movaps%xmm1, -112(%rbp)<br>movaps%xmm2, -96(%rbp)<br>movaps%xmm3, -80(%rbp)<br>movaps%xmm4, -64(%rbp)<br>movaps%xmm5, -48(%rbp)<br>movaps%xmm6, -32(%rbp)<br>movaps%xmm7, -16(%rbp)<br>.L2:<br>movq%fs:40, %rax<br>movq%rax, -184(%rbp)<br>xorl%eax, %eax<br>movl-228(%rbp), %eax<br>movl%eax, -212(%rbp)<br>movl$8, -208(%rbp)<br>movl$48, -204(%rbp)<br>leaq16(%rbp), %rax<br>movq%rax, -200(%rbp)<br>leaq-176(%rbp), %rax<br>movq%rax, -192(%rbp)<br>ud2<br>.cfi_endproc<br>.LFE0:<br>.sizetest, .-test<br>.section.rodata<br>.LC0:<br>.string"abcderf"<br>.text<br>.globlmain<br>.typemain, @function<br>main:<br>.LFB1:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>subq$16, %rsp<br>movl$1, -12(%rbp)<br>movb$51, -13(%rbp)<br>leaq.LC0(%rip), %rax<br>movq%rax, -8(%rbp)<br>movsbl-13(%rbp), %ecx<br>movq-8(%rbp), %rdx<br>movl-12(%rbp), %eax<br>movl%ecx, %esi<br>movl%eax, %edi<br>movl$0, %eax<br>calltest<br>movl$0, %eax<br>leave<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE1:<br>.sizemain, .-main<br>.ident"GCC: (GNU) 11.2.0"<br>.section.note.GNU-stack,"",@progbits<br><br></code></pre></td></tr></tbody></table></figure><p>只关注重点地方代码，test调用之前，test调用之后。</p><p>找到 call test ，在call test之前，</p><p>rdi中存着第一个参数，值为1</p><p>rsi中存着第二个参数，值为2</p><p>rdx中存着第三个参数，值为字符串 的地址</p><p><img src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/20220223165128.png"></p><p>接着调用<code>call test</code>，跳转至<code>test</code>中，首先保存<code>rbp</code>寄存器，更新<code>rbp</code>指针为<code>rsp</code>（栈顶指针），接着栈顶下移（分配空间），将<code>edi</code>、<code>rsi</code>、<code>rax</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>保存到栈区。为什么是<code>edi</code>呢？因为你的第一个参数为<code>int</code>，而非<code>int64_t</code>。</p><p>继续往下走，<code>test %al,%al</code> 其行为类似and（<code>TEST %SRC, %DEST</code> 目的寄存器与源寄存器进行<strong>逻辑与</strong>操作，其结果不更新目的寄存器），<code>je</code> 如果等于0，跳转。</p><p>继续往下走，<code>FS:0x28</code>在 Linux 上存储一个特殊的哨兵堆栈保护值，并且代码正在执行堆栈保护检查。</p><p>==FS:0x28 之下与 ud2 之前代码未分析。（留个坑）==</p><p>然后后面 执行ud2，UD2是一种让CPU产生invalid opcode exception的软件指令. 内核发现CPU出现这个异常, 会立即停止运行。此时就Core Dumped.</p><p>以上猜测错误。</p><p>**==其实是c99标准中的默认参数提升==**，具体标准如下。</p><p><a href="http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf">C99标准</a> 6.5.2.2  函数调用 6、7、8节</p><blockquote><p>6 If the expression that denotes the called function has a type that does not include a prototype, the integer promotions are performed on each argument, and arguments that have type float are promoted to double. These are called the default argument promotions. If the number of arguments does not equal the number of parameters, the behavior is undefined. If the function is defined with a type that includes a prototype, and either the prototype ends with an ellipsis (, …) or the types of the arguments after promotion are not compatible with the types of the parameters, the behavior is undefined. If the function is defined with a type that does not include a prototype, and the types of the arguments after promotion are not compatible with those of the parameters after promotion, the behavior is undefined, except for the following cases:</p><p>​— one promoted type is a signed integer type, the other promoted type is the corresponding unsigned integer type, and the value is representable in both types; </p><p>​— both types are pointers to qualified or unqualified versions of a character type or void. </p><p>7 If the expression that denotes the called function has a type that does include a prototype, the arguments are implicitly converted, as if by assignment, to the types of the corresponding parameters, taking the type of each parameter to be the unqualified version of its declared type. The ellipsis notation in a function prototype declarator causes argument type conversion to stop after the last declared parameter. The default argument promotions are performed on trailing arguments. </p><p>8 No other conversions are performed implicitly; in particular, the number and types of arguments are not compared with those of the parameters in a function definition that does not include a function prototype declarator</p></blockquote><blockquote><p>6如果表示被调用函数的表达式具有不包含原型的类型，则对每个参数执行整数提升，并将具有float类型的参数提升为double。这些被称为默认参数提升。如果参数的数量不等于参数的数量，则行为是未定义的。如果函数是用包含原型的类型定义的，并且原型以省略号（，…）结尾或者升级后的参数类型与参数类型不兼容，行为未定义。如果函数定义的类型不包括原型，且升级后参数的类型与升级后参数的类型不兼容，则行为未定义，但以下情况除外：</p><ul><li>一个升级类型是有符号整数类型，另一个升级类型是相应的无符号整数类型，值在两种类型中都可以表示；</li><li>这两种类型都是指向字符类型或void的限定或非限定版本的指针。</li></ul><p>7 如果表示被调用函数的表达式的类型确实包含原型，则参数会像赋值一样隐式转换为相应参数的类型，将每个参数的类型视为其声明类型的非限定版本。函数原型声明器中的省略号表示法会导致参数类型转换在最后一个声明的参数之后停止。默认参数升级是在后续参数上执行的。</p><p>8 没有隐式执行其他转换；特别是，参数的数量和类型不会与不包含函数原型声明器的函数定义中的参数进行比较</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/1255775/default-argument-promotions-in-c-function-calls">https://stackoverflow.com/questions/1255775/default-argument-promotions-in-c-function-calls</a></p><p><a href="https://blog.csdn.net/astrotycoon/article/details/8284501">https://blog.csdn.net/astrotycoon/article/details/8284501</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> coredumped </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Vmware上使用archlinux安装open-vm-tools</title>
      <link href="/posts/b9ab4680/"/>
      <url>/posts/b9ab4680/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在Archlinux安装open-vm-tools软件"><a href="#如何在Archlinux安装open-vm-tools软件" class="headerlink" title="如何在Archlinux安装open-vm-tools软件"></a>如何在Archlinux安装open-vm-tools软件</h1><h2 id="安装软件主体"><a href="#安装软件主体" class="headerlink" title="安装软件主体"></a>安装软件主体</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S open-vm-tools open-vm-tools-desktop<br></code></pre></td></tr></tbody></table></figure><p>然后安装软件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S base-devel net-tools linux-headers asp wget sudo vim vi<br></code></pre></td></tr></tbody></table></figure><h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><p>为虚拟机配置时间同步很重要，因为虚拟机比物理机更容易出现时间波动现象。主要原因就在于 CPU 是被共用的。</p><p>有两种方案可以实现实现同步：同步宿主机时间或者用NTP服务。</p><p>与宿主机同步时间<br>保证 vmtoolsd.service 服务处于运行状态<code>systemctl status vmtoolsd.service</code>，然后用如下的命令启用时间同步功能：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vmware-toolbox-cmd timesync enable<br></code></pre></td></tr></tbody></table></figure><p>宿主系统休眠后，用如下的命令来使客机间同步时间：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo hwclock --hctosys --localtime<br></code></pre></td></tr></tbody></table></figure><h2 id="窗口分辨率自动适配"><a href="#窗口分辨率自动适配" class="headerlink" title="窗口分辨率自动适配"></a>窗口分辨率自动适配</h2><p>当你拖动Vmware窗口后，Arch会随主窗口的大小来调整分辨率。</p><h2 id="开启3D加速"><a href="#开启3D加速" class="headerlink" title="开启3D加速"></a>开启3D加速</h2><p>VMware 软件：设置 - 显示器 - 选择合适的显存 - 开启加速3D图形</p><p>点击 查看 - 自动调整大小 - 自动适应客户机 打勾</p><h2 id="安装xf86-video-vmware"><a href="#安装xf86-video-vmware" class="headerlink" title="安装xf86-video-vmware"></a>安装xf86-video-vmware</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S xf86-video-vmware<br></code></pre></td></tr></tbody></table></figure><h2 id="安装gtkmm和gtk2"><a href="#安装gtkmm和gtk2" class="headerlink" title="安装gtkmm和gtk2"></a>安装gtkmm和gtk2</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S gtkmm gtk2<br></code></pre></td></tr></tbody></table></figure><h3 id="添加相关模块"><a href="#添加相关模块" class="headerlink" title="添加相关模块"></a>添加相关模块</h3><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/m</span>kinitcpio.conf<br>MODULES=(vsock vmw_vsock_vmci_transport vmw_balloon vmw_vmci vmwgfx)<br><span class="hljs-comment"># :wq 保存退出 </span><br></code></pre></td></tr></tbody></table></figure><p>然后执行</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkinitcpio -p linux<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果报错，重新安装一下linux，先运行下面的，在运行这一句</span><br>sudo pacman -S linux<br></code></pre></td></tr></tbody></table></figure><h2 id="启动vmtoolsd-service"><a href="#启动vmtoolsd-service" class="headerlink" title="启动vmtoolsd.service"></a>启动<code>vmtoolsd.service</code></h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start vmtoolsd.service<br>sudo systemctl enable vmtoolsd.service<br></code></pre></td></tr></tbody></table></figure><p>重启就可以了</p><h2 id="拖拽复制粘贴"><a href="#拖拽复制粘贴" class="headerlink" title="拖拽复制粘贴"></a>拖拽复制粘贴</h2><p>open-vm-tools缺少gtkmm，因此无法复制粘贴，手动安装即可。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S gtkmm<br></code></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://wiki.archlinux.org/title/VMware/Install_Arch_Linux_as_a_guest">VMware/Install Arch Linux as a guest</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> archlinux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
