<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从char(unsigned char)数组拷贝至string的方法</title>
      <link href="/posts/d8f56567"/>
      <url>/posts/d8f56567</url>
      
        <content type="html"><![CDATA[<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>C++标准 <a href="https://en.cppreference.com/w/cpp/string/basic_string/basic_string">https://en.cppreference.com/w/cpp/string/basic_string/basic_string</a> 中第4条，构造时传入<code>char *</code>指针和待传入的数据长度 </p><p><code>basic_string( const CharT* s, size_type count, const Allocator&amp; alloc = Allocator() );</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">uint8_t</span> a[] = {<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x33</span>,<span class="number">0x35</span>,<span class="number">0x0</span>,<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x33</span>,<span class="number">0x35</span>,<span class="number">0x0</span>,<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x33</span>,<span class="number">0x35</span>,<span class="number">0x0</span>,<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x33</span>,<span class="number">0x35</span>,<span class="number">0x0</span>,};</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(a), <span class="keyword">sizeof</span>(a))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size:"</span>&lt;&lt;s.size()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cpp -std=c++11 -g</span><br><span class="line">$ ./a.out</span><br><span class="line">size:20</span><br></pre></td></tr></tbody></table></figure><p>在c++11中，可以通过string的构造函数 <code>basic_string( const CharT* s, size_type count, const Allocator&amp; alloc = Allocator() );</code></p><p>完成<code>char *</code>到string的转化，<strong>不用管char 数组中是否含有0</strong>，可通过 <code>.size()</code> 查看大小，或者直接 使用 <code>gdb</code> 查看内存中的数据；但需注意，直接使用<code>std::cout</code>输出可能会丢失数据（遇<code>\0</code>结束），建议使用迭代器对每个元素遍历。</p><p><img src="https://gitee.com/glj0/imgur/raw/master/photo/image-20220308085045195.png"></p><p>如上图中终端输出的 使用<code>x</code> 命令访问 内存，格式如 <code>x/&lt;n/f/u&gt; &lt;addr&gt;</code>,</p><ul><li>n 正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容</li><li>f 表示addr 指向内存内容的输出格式，s对应输出字符串，其它整形格式如下：<ul><li> x 按十六进制格式显示变量</li><li>d 按十进制格式显示变量</li><li>u 按十进制格式显示无符号整型</li><li>o 按八进制格式显示变量 </li><li>t 按二进制格式显示变量</li><li>a 按十六进制格式显示变量</li><li>c  按字符格式显示变量</li><li>f  按浮点数格式显示变量</li></ul></li></ul><ul><li>u 指以多少个字节作为一个内存单元-unit,默认为4。u还可以用被一些字符表示:如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> string </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL库中copy的使用</title>
      <link href="/posts/8299be4a"/>
      <url>/posts/8299be4a</url>
      
        <content type="html"><![CDATA[<h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p><a href="https://en.cppreference.com/w/cpp/algorithm/copy">https://en.cppreference.com/w/cpp/algorithm/copy</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 std::vector 类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp;vecs)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"vecs-&gt;size:"</span>&lt;&lt;vecs.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\t data:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v : vecs) </span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="keyword">char</span>&gt; vecs{<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>};</span><br><span class="line">    std::vector&lt;<span class="keyword">char</span>&gt; tmp;</span><br><span class="line">    </span><br><span class="line">    tmp.<span class="built_in">resize</span>(vecs.<span class="built_in">size</span>() * <span class="number">10</span>); </span><br><span class="line">    print&lt;std::vector&lt;<span class="keyword">char</span>&gt;&gt;(vecs);</span><br><span class="line">    std::<span class="built_in">copy</span>(vecs.<span class="built_in">begin</span>(),vecs.<span class="built_in">end</span>(),tmp.<span class="built_in">begin</span>());</span><br><span class="line">    std::<span class="built_in">copy</span>(vecs.<span class="built_in">begin</span>(),vecs.<span class="built_in">end</span>(),tmp.<span class="built_in">begin</span>() + vecs.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="built_in">copy</span>(vecs.<span class="built_in">begin</span>(),vecs.<span class="built_in">end</span>(),tmp.<span class="built_in">begin</span>() + vecs.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    print&lt;std::vector&lt;<span class="keyword">char</span>&gt;&gt;(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> valA = <span class="number">0x123456789</span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">uint8_t</span>&gt; tmpA;</span><br><span class="line">    tmpA.<span class="built_in">resize</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(valA));</span><br><span class="line">    std::<span class="built_in">copy</span>((<span class="keyword">uint8_t</span> *)&amp;valA, (<span class="keyword">uint8_t</span> *)&amp;valA + <span class="built_in"><span class="keyword">sizeof</span></span>(valA), tmpA.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">print</span>(tmpA);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v: tmpA)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%x "</span>,v);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将上述代码保存为test.cpp ，使用以下命令编译、执行</span></span><br><span class="line">g++  test.cpp -std=c++11</span><br><span class="line">./a.out</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 得到结果，与预期一致</span></span><br><span class="line">u@ubuntu:~$ ./a.out </span><br><span class="line"><span class="meta">vecs-&gt;</span><span class="bash">size:9     data:A B C D E F G H I</span> </span><br><span class="line"><span class="meta">vecs-&gt;</span><span class="bash">size:90    data:A B C D E F G H I A A B C D E F G H I</span>                                                                        </span><br><span class="line"><span class="meta">vecs-&gt;</span><span class="bash">size:8     data:� g E <span class="comment">#</span></span>     </span><br><span class="line">89 67 45 23 1 0 0 0 </span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用过程中 copy 有三个参数，分别是待拷贝的数据开始迭代器、待拷贝的数据的结束迭代器、目的迭代器</p><p>其中如果要拷贝非STL中数据，根据目的迭代器的存储类型，<strong>将源数据 转成对应的指针形式访问内存</strong>，比如上述代码中的</p><p><code>std::copy((uint8_t *)&amp;valA, (uint8_t *)&amp;valA + sizeof(valA), tmpA.begin());</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个简单的测试Linux进程栈空间大小的方法</title>
      <link href="/posts/f2b20ab4"/>
      <url>/posts/f2b20ab4</url>
      
        <content type="html"><![CDATA[<p>一个简单的测试linux进程栈空间大小的方法</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在ubuntu中，可以通过命令<code>ulimit -a </code>查看所有的限制信息（<code>ulimit -s</code> 直接显示stack size）</p><p><img src="https://gitee.com/glj0/imgur/raw/master/photo/20220310100235.png"></p><p>但在某些嵌入式开发板中，通过此命令查看到的stack size显示ulimited （无限制，假），但实际中是有限制的，不知道stack size 不利于大型项目的开发（栈空间使用过多后程序会直接挂 segmentation fault）。所以，得到一个真实的stack size尤为重要。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>A函数每次创建 1024bytes 数据；使用全局变量存储A函数调用次数，每次调用A函数+1；</p><p>主函数中递归调用A函数，由于主函数中栈空间相对于子线程会大一些，所以在子线程中递归调用。最终栈溢出后通过屏幕打印的计数即可得到大概的stack size。忽略掉函数调用栈空间占用。</p><p>另一种思路：通过汇编得到esp指针获得起始位置，结束位置通过递归调用栈溢出后gdb打印esp指针获得结束位置。详见<a href="https://blog.csdn.net/yangkuanqaz85988/article/details/52403726">https://blog.csdn.net/yangkuanqaz85988/article/details/52403726</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> thread_id;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp[<span class="number">1024</span>] = {<span class="number">0</span>};</span><br><span class="line">        count ++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d num = %d!\r\n"</span>, __FUNCTION__, __LINE__, count);</span><br><span class="line">    test();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %d!\r\n"</span>, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"New process:  PID: %d,TID: %u.\r\n"</span>, getpid(), pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"New process:  PID: %d,TID: %u.\r\n"</span>, getpid(), thread_id);</span><br><span class="line">    test();</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">//退出线程</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thrd_func, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create thread error!\r\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将以上文件保存为 main.cpp，使用如下命令编译得到 a.out，./a.out 运行</span></span><br><span class="line">gcc main.cpp -pthread -std=c++11</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/glj0/imgur/raw/master/photo/20220310100420.png"></p><p>大概是7937 * 1024 bytes = 7937kbytes ≈ 8 Mbytes 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multiboot规范</title>
      <link href="/posts/4e0f05fa"/>
      <url>/posts/4e0f05fa</url>
      
        <content type="html"><![CDATA[<blockquote><p>原英文 <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></p></blockquote><blockquote><p>原文地址 <a href="https://blog.csdn.net/uframer/article/details/373900">blog.csdn.net</a></p></blockquote><p>[TOC]</p><h1 id="Multiboot-规范"><a href="#Multiboot-规范" class="headerlink" title="Multiboot 规范"></a>Multiboot 规范</h1><h2 id="Multiboot-规范-1"><a href="#Multiboot-规范-1" class="headerlink" title="Multiboot 规范"></a>Multiboot 规范</h2><p>本文定义了 Multiboot 规范——提议中的引导过程标准。本文是此规范的 0.6.96 版。</p><ul><li>  概览</li><li>  术语</li><li>  规范</li><li>  示例</li><li>  历史</li><li>  调用 mbchk：如何使用多重引导检查器</li><li>  索引</li></ul><h2 id="Multiboot-规范简介"><a href="#Multiboot-规范简介" class="headerlink" title="Multiboot 规范简介"></a>Multiboot 规范简介</h2><p>本章描述了一些关于 Multiboot 规范的粗略的信息。注意，这不是规范本身的一部分。</p><ul><li><p>动机</p></li><li><p>架构</p></li><li><p>操作系统</p></li><li><p>引导源</p></li><li><p>引导时配置</p></li><li><p>为操作系统带来的便利</p></li><li><p>引导模块</p></li></ul><h3 id="Multiboot-规范诞生的背景"><a href="#Multiboot-规范诞生的背景" class="headerlink" title="Multiboot 规范诞生的背景"></a>Multiboot 规范诞生的背景</h3><p>几乎每种现有的操作系统都拥有自己的引导程序。在机器上安装一个新的操作系统时通常意味着要引入一套全新的引导机制，每种的安装和运行界面都不相同。使多种操作系统相安无事地共存于一个机器上通常要借助于链式机制，这可是个恶梦。基本上你不能选择某个操作系统的引导程序——如果操作系统自带的引导程序不是你想要的，或者不能在你的机器上工作，你的麻烦可就大了。</p><p>尽管不太可能解决现有的商业操作系统所存在的问题，但是对于自由操作系统社区的人们来说，将他们的领袖集合在一起并为流行的自由操作系统解决这个问题并不是很难。这也正是这份规范的目的所在。基本上，它指出了引导程序和操作系统之间的接口，这样符合规范的引导程序就可以引导任何符合规范的操作系统。这份规范并不关心引导程序应该如何工作——只关心它们引导操作系统时的接口。</p><h3 id="目标架构"><a href="#目标架构" class="headerlink" title="目标架构"></a>目标架构</h3><p>这份规范主要面向 PC，因为它们使用最广并且有最多的操作系统和引导程序。尽管如此，对于那些需要一份引导规范并且目前缺少一份的架构来说，剥去 x86 架构的相关细节得到版本也应该可以满足需要。</p><h3 id="目标操作系统"><a href="#目标操作系统" class="headerlink" title="目标操作系统"></a>目标操作系统</h3><p>这份规范的目标是自由的 32 位操作系统，因为应该可以比较容易获得修改这些操作系统以支持本规范的权力而不需要听满是官腔的喋喋不休。这份规范主要是面向 Linux、FreeBSD、NetBSD、Mach 和 VSTa 这些自由操作系统设计的。我们希望后来的自由操作系统能够从一开始就采用本规范，这样就可以立即使用现有的引导程序了。如果商业操作系统能够最终采用本规范当然很好，但是这很可能只是白日做梦。</p><h3 id="引导源"><a href="#引导源" class="headerlink" title="引导源"></a>引导源</h3><p>实现一个可以从各种位置（软盘、硬盘或网络）载入 OS 映像的引导程序是现实可行的。</p><p>基于磁盘的引导程序可以使用各种技术查找位于磁盘上的 OS 映像和引导模块，例如解释某种文件系统（如 BSD/Mach 引导程序），使用预先计算好的 block 列表（如 LILO），从特殊的引导分区载入（如 OS/2），或者甚至从另一个操作系统载入（如 VSTa 引导代码，从 DOS 载入）。与此相似，基于网络的引导程序也可以使用各种网络硬件和协议。</p><p>我们希望引导程序可以支持多种载入机制，这样可以提供更好的可移植性、健壮性和易用性。</p><h3 id="在引导时配置操作系统"><a href="#在引导时配置操作系统" class="headerlink" title="在引导时配置操作系统"></a>在引导时配置操作系统</h3><p>总有这样或者那样的原因使得用户需要在启动时动态配置操作系统。尽管本规范不应该对引导程序如何获得这些配置信息指手划脚，我们还是应该为如何将这些信息传递给操作系统提供一种标准的方法。</p><h3 id="如何使操作系统开发更容易"><a href="#如何使操作系统开发更容易" class="headerlink" title="如何使操作系统开发更容易"></a>如何使操作系统开发更容易</h3><p>应尽量降低生成 OS 映象的难度。在理想情况下，OS 映象应该是该操作系统通常使用的普通 32 位可执行文件格式。应该能够像对待普通可执行文件格式一样用<code>nm</code>或者反汇编 OS 映象，而不应该用到特殊的工具来生成使用_特殊_文件格式的 OS 映象。如果这意味着将一部分的操作系统功能转移到引导程序中来的话，这很合适，因为任何引导程序用到的内存都应该可由它所创建的真正的系统自由使用，这样 OS 映象中的每一个比特都应该永远留在内存中。操作系统应该不必考虑如何进入 32 位地址模式，因为模式切换应该位于引导程序中，而这些程序通常需要将操作系统数据装入到 1MB 以上的内存，如果操作系统需要考虑这些问题的话创建 OS 映象的工作将变得更加困难。</p><p>不幸的是，仅在 PC 平台上的自由 UNIX 类系统中也有多得惊人的可执行文件格式——通常各种操作系统的格式都不相同。大多数的自由操作系统使用的是 a.out 格式的变种，但有一些已经改用了 ELF 格式。最好是引导程序不必为了载入 OS 映象而需要理解所有的可执行文件格式——否则的话引导程序又变成了某个操作系统专用的了。</p><p>这份规范采用了一种折衷的方案。符合 Multiboot 规范的 OS 映象总是包含一个 magic Multiboot 头（参见 OS 映像格式），这样引导程序就不必理解种类繁多的 a.out 变体或者其他什么可执行格式。magic 头不必位于可执行文件的最前面，这样 OS 映象就可以在保持同 a.out 格式兼容的同时做到符合 Multiboot 规范。</p><h3 id="引导模块"><a href="#引导模块" class="headerlink" title="引导模块"></a>引导模块</h3><p>许多现代操作系统的内核，如 VSTa 和 Mach，本身并不包括系统所有的功能：它们需要在引导时载入额外的软件模块以访问设备、挂载文件系统等。尽管这些额外的软件模块可以同内核一同嵌入到主 OS 映像中，并且在操作系统接管控制权时可以将映像分割为不同的部分，但如果引导程序能在一开始就分别的载入这些模块的话，对操作系统和用户来说就更灵活、更有空间效率并且很方便。</p><p>因此，本规范应该为引导程序提供一个标准的方法指示操作系统应该载入哪些辅助模块，以及应该将它们放在哪里。引导程序不一定非得支持多引导模块，但是我们强烈推荐它们这样，因为一些操作系统如果不这样就无法引导。</p><h2 id="本-Multiboot-规范中所用术语的定义"><a href="#本-Multiboot-规范中所用术语的定义" class="headerlink" title="本 Multiboot 规范中所用术语的定义"></a>本 Multiboot 规范中所用术语的定义</h2><p>必须</p><p>​        术语 “必须 ” 表示引导程序或 OS 映像需要服从某一规则，否则的话，引导程序或者 OS 映像就不能称为符合 Multiboot 规范的。</p><p>应该</p><p>​        术语 “ 应该 ” 表示引导程序或 OS 映像最好服从某一规则，但如果没有服从也是可以的。</p><p>可以</p><p>​        术语 “ 可以” 表示引导程序或 OS 映像服从某一规则是允许的。</p><p>引导程序</p><p>​        引导程序是负责载入最终的操作系统映像的一个或一组程序。引导程序本身可以由几个阶段组成，但是这属于实现细节而同本规范无关。只有引导程序最后的阶段——最终将控制权转交给操作系统的阶段——必须遵守本文中规定的规则，否则引导程序就不能称为符合 Multiboot 规范；在这之前的阶段可以怎么方便怎么设计。</p><p>OS 映像</p><p>​        OS 映像是引导程序载入到内存的初始二进制映像，随后引导程序会将控制权转移给它，这样就启动了操作系统。典型的 OS 映像是包含了操作系统内核的可执行文件。  </p><p>引导模块</p><p>​        引导模块是由引导程序同 OS 映像一同载入的其他起辅助作用的文件。引导程序并不理解这些文件，只会将它们的位置告知操作系统。  </p><p>符合 Multiboot 规范</p><p>​        服从所有被标记为 “必须” 的引导程序或者 OS 映像被称为符合 Multiboot 规范。对于规范中那些被标记为 “应该” 或者 “可以” 的规则，符合 Multiboot 规范的引导程序或 OS 映像可以不必遵守。</p><p>u8</p><p>​        无符号 8 位数据。</p><p>u16</p><p>​        无符号 16 位数据。因为目标架构是高位优先（little-endian）的，所以 u16 按照高位优先编码。</p><p>u32</p><p>​        无符号 32 位数据。因为目标架构是高位优先（little-endian）的，所以 u32 按照高位优先编码。  </p><p>u64</p><p>​        无符号 64 位数据。因为目标架构是高位优先（little-endian）的，所以 u64 按照高位优先编码。</p><h2 id="Multiboot-规范的精确定义"><a href="#Multiboot-规范的精确定义" class="headerlink" title="Multiboot 规范的精确定义"></a>Multiboot 规范的精确定义</h2><p>引导程序 / OS 映像接口主要包括三个：</p><ol><li> 引导程序看到的 OS 映像的格式</li><li> 引导程序启动操作系统时机器的状态</li><li> 引导程序传递给操作系统的信息的格式</li></ol><ul><li><p><strong>OS 映像格式</strong></p></li><li><p><strong>机器状态</strong></p></li><li><p><strong>引导信息格式</strong></p></li></ul><h3 id="OS-映像格式"><a href="#OS-映像格式" class="headerlink" title="OS 映像格式"></a>OS 映像格式</h3><p>一个 OS 映像可以是一个普通的某种操作系统使用的标准格式的 32 位可执行文件，不同之处是它可能被连接到一个非默认的载入地址以避开 PC 的 I/O 区域或者其它的保留区域，当然它也不能使用共享库或其它这样可爱的东西。</p><p>除了 OS 映像所使用的格式需要的头之外，<strong>OS 映像还必须额外包括一个 Multiboot 头</strong>。<strong>Multiboot 头必须完整的包含在 OS 映像的前 8192 字节内</strong>，并且<strong>必须是 longword（32 位）对齐</strong>的。通常来说，它的位置<strong>越靠前越好</strong>，并且可以嵌入在 text 段的起始处，位于真正的可执行文件头之前。</p><ul><li><p>头分布: Multiboot Header 分布</p></li><li><p>头的幻数域: Multiboot Header magic 域</p></li><li><p>头的地址域: Multiboot Header address域</p></li><li><p>头的图形域: Multiboot Header graphics域</p></li></ul><h4 id="Multiboot-的-Header-分布"><a href="#Multiboot-的-Header-分布" class="headerlink" title="Multiboot 的 Header 分布"></a>Multiboot 的 Header 分布</h4><p>Multiboot 头的分布必须如下表所示：</p><table><thead><tr><th>偏移量</th><th>类型</th><th>域名</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>u32</td><td>magic</td><td>必需</td></tr><tr><td>4</td><td>u32</td><td>flags</td><td>必需</td></tr><tr><td>8</td><td>u32</td><td>checksum</td><td>必需</td></tr><tr><td>12</td><td>u32</td><td>header_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>16</td><td>u32</td><td>load_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>20</td><td>u32</td><td>load_end_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>24</td><td>u32</td><td>bss_end_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>28</td><td>u32</td><td>entry_addr</td><td>如果 flags[16] 被置位</td></tr><tr><td>32</td><td>u32</td><td>mode_type</td><td>如果 flags[2] 被置位</td></tr><tr><td>36</td><td>u32</td><td>width</td><td>如果 flags[2] 被置位</td></tr><tr><td>40</td><td>u32</td><td>height</td><td>如果 flags[2] 被置位</td></tr><tr><td>44</td><td>u32</td><td>depth</td><td>如果 flags[2] 被置位</td></tr></tbody></table><p><code>magic</code>、<code>flags</code> 和 <code>checksum</code> 域在Header magic 域中定义，</p><p><code>header_addr</code>、<code>load_addr</code>、<code>load_end_addr</code>、<code>bss_end_addr</code> 和 <code>entry_addr</code> 域在Header address域中定义，</p><p><code>mode_type</code>、<code>width</code>、<code>height</code>和<code>depth</code>域则在Header graphics 域中定义。</p><h4 id="Multiboot-Header-magic-域"><a href="#Multiboot-Header-magic-域" class="headerlink" title="Multiboot Header magic 域"></a>Multiboot Header magic 域</h4><p><code>magic</code></p><p>​        magic 域是标志头的魔数，它必须等于十六进制值 0x1BADB002。  </p><p><code>flags</code></p><p>​        flags 域指出 OS 映像需要引导程序提供或支持的特性。0-15 位指出需求：如果引导程序发现某些值被设置但出于某种原因不理解或不能不能满足相应的需求，它必须告知用户并宣告引导失败。16-31 位指出可选的特性：如果引导程序不能支持某些位，它可以简单的忽略它们并正常引导。自然，所有 flags 字中尚未定义的位必须被置为 0。这样，flags 域既可以用于版本控制也可以用于简单的特性选择。</p><p>如果设置了 flags 字中的 0 位，所有的引导模块将按页（4KB）边界对齐。有些操作系统能够在启动时将包含引导模块的页直接映射到一个分页的地址空间，因此需要引导模块是页对齐的。</p><p>如果设置了 flags 字中的 1 位，则必须通过 Multiboot 信息结构（参见引导信息格式）的 mem_* 域包括可用内存的信息。如果引导程序能够传递内存分布（mmap_* 域）并且它确实存在，则也包括它。</p><p>如果设置了 flags 字中的 2 位，有关视频模式表（参见引导信息格式）的信息必须对内核有效。</p><p>如果设置了 flags 字中的 16 位，则 Multiboot 头中偏移量 8-24 的域有效，引导程序应该使用它们而不是实际可执行头中的域来计算将 OS 映象载入到那里。如果内核映象为 ELF 格式则不必提供这样的信息，但是如果映象是 a.out 格式或者其他什么格式的话就_必须_提供这些信息。兼容的引导程序必须既能够载入 ELF 格式的映象也能载入将载入地址信息嵌入 Multiboot 头中的映象；它们也可以直接支持其他的可执行格式，例如一个 a.out 的特殊变体，但这不是必须的。  </p><p><code>checksum</code></p><p>​        域 checksum 是一个 32 位的无符号值，当与其他的 magic 域（也就是 magic 和 flags）相加时，结果必须是 32 位的无符号值 0（即 magic + flags + checksum = 0）。</p><h4 id="Multiboot-Header-address-域"><a href="#Multiboot-Header-address-域" class="headerlink" title="Multiboot Header address 域"></a>Multiboot Header address 域</h4><p>所有由 flags 的第 16 位开启的地址域都是物理地址。它们的意义如下：</p><p><code>header_addr</code></p><p>包含对应于 Multiboot 头的开始处的地址——这也是 magic 值的物理地址。这个域用来 同步 OS 映象偏移量和物理内存之间的映射。  </p><p><code>load_addr</code></p><p>包含 text 段开始处的物理地址。从 OS 映象文件中的多大偏移开始载入由头位置的偏移量定义，相减（header_addr - load_addr）。load_addr 必须小于等于 header_addr。  </p><p><code>load_end_addr</code></p><p>包含 data 段结束处的物理地址。（load_end_addr - load_addr）指出了引导程序要载入多少数据。这暗示了 text 和 data 段必须在 OS 映象中连续；现有的 a.out 可执行格式满足这个条件。如果这个域为 0，引导程序假定 text 和 data 段占据整个 OS 映象文件。  </p><p><code>bss_end_addr</code></p><p>包含 bss 段结束处的物理地址。引导程序将这个区域初始化为 0，并保留这个区域以免将引导模块和其他的于查系统相关的数据放到这里。如果这个域为 0，引导程序假定没有 bss 段。  </p><p><code>entry_addr</code></p><p>操作系统的入口点，引导程序最后将跳转到那里。</p><h4 id="Multiboot-头的图形域"><a href="#Multiboot-头的图形域" class="headerlink" title="Multiboot 头的图形域"></a>Multiboot 头的图形域</h4><p>所有的图形域都通过 flags 的第 2 位开启。它们指出了推荐的图形模式。注意，这只是 OS 映象推荐的模式。如果该模式存在，引导程序将设定它，如果用户不明确指出另一个模式的话。否则，如果可能的话，引导程序将转入一个相似的模式。</p><p>他们的意义如下：</p><p><code>mode_type</code></p><p>如果为 0 就代表线性图形模式，如果为 1 代表标准 EGA 文本模式。所有其他值保留以备将来扩展。注意即使这个域为 0，引导程序也可能设置一个文本模式。  </p><p><code>width</code></p><p>包含列数。在图形模式下它是象素数，在文本模式下它是字符数。0 代表 OS 映象对此没有要求。  </p><p><code>height</code></p><p>包含行数。在图形模式下它是象素数，在文本模式下它是字符数。0 代表 OS 映象对此没有要求。  </p><p><code>depth</code></p><p>在图形模式下，包含每个象素的位数，在文本模式下为 0。0 代表 OS 映象对此没有要求。</p><h3 id="机器状态"><a href="#机器状态" class="headerlink" title="机器状态"></a>机器状态</h3><p>当引导程序调用 32 位操作系统时，机器状态必须如下：</p><p><code>EAX</code></p><p>必须包含魔数 0x2BADB002；这个值指出操作系统是被一个符合 Multiboot 规范的引导程序载入的（这样就算是另一种引导程序也可以引导这个操作系统）。  </p><p><code>EBX</code></p><p>必须包含由引导程序提供的 Multiboot 信息结构的物理地址（参见 引导信息格式）。  </p><p><code>CS</code></p><p>必须是一个偏移量位于 0 到 0xFFFFFFFF 之间的 32 位可读 / 可执行代码段。这里的精确值未定义。  </p><p><code>DS</code></p><p><code>ES</code></p><p><code>FS</code></p><p><code>GS</code></p><p><code>SS</code></p><p>必须是一个偏移量位于 0 到 0xFFFFFFFF 之间的 32 位可读 / 可执行代码段。这里的精确值未定义。  </p><p><code>A20 gate</code></p><p>必须已经开启。  </p><p><code>CR0</code></p><p>第 31 位（PG）必须为 0。第 0 位（PE）必须为 1。其他位未定义。  </p><p><code>EFLAGS</code></p><p>第 17 位（VM）必须为 0。第 9 位（IF）必须为 1 。其他位未定义。</p><p>所有其他的处理器寄存器和标志位未定义。这包括：</p><p><code>ESP</code></p><p>当需要使用堆栈时，OS 映象必须自己创建一个。  </p><p><code>GDTR</code></p><p>尽管段寄存器像上面那样定义了，GDTR 也可能是无效的，所以 OS 映象决不能载入任何段寄存器（即使是载入相同的值也不行！）直到它设定了自己的 GDT。  </p><p><code>IDTR</code></p><p>OS 映象必须在设置完它的 IDT 之后才能开中断。</p><p>尽管如此，其他的机器状态应该被引导程序留做正常的工作顺序，也就是同 BIOS（或者 DOS，如果引导程序是从那里启动的话）初始化的状态一样。换句话说，操作系统应该能够在载入后进行 BIOS 调用，直到它自己重写 BIOS 数据结构之前。还有，引导程序必须将 PIC 设定为正常的 BIOS/DOS 状态，尽管它们有可能在进入 32 位模式时改变它们。</p><h3 id="引导信息格式"><a href="#引导信息格式" class="headerlink" title="引导信息格式"></a>引导信息格式</h3><p>FIXME：将这章像 “OS 映像格式” 那样分解。</p><p>在进入操作系统时，EBX 寄存器包含 Multiboot 信息数据结构的物理地址，引导程序通过它将重要的引导信息传递给操作系统。操作系统可以按自己的需要使用或者忽略任何部分；所有的引导程序传递的信息只是建议性的。</p><p>Multiboot 信息结构和它的相关的子结构可以由引导程序放在任何位置（当然，除了保留给内核和引导模块的区域）。如何在利用之前保护它是操作系统的责任。</p><p>Multiboot 信息结构（就目前为止定义的）的格式如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">        +-------------------+</span><br><span class="line">0       | flags             |    (必需)</span><br><span class="line">        +-------------------+</span><br><span class="line">4       | mem_lower         |    (如果flags[0]被置位则出现)</span><br><span class="line">8       | mem_upper         |    (如果flags[0]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">12      | boot_device       |    (如果flags[1]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">16      | cmdline           |    (如果flags[2]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">20      | mods_count        |    (如果flags[3]被置位则出现)</span><br><span class="line">24      | mods_addr         |    (如果flags[3]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">28 - 40 | syms              |    (如果flags[4]或</span><br><span class="line">        |                   |        flags[5]被置位则出现)            </span><br><span class="line">        +-------------------+</span><br><span class="line">44      | mmap_length       |    (如果flags[6]被置位则出现)</span><br><span class="line">48      | mmap_addr         |    (如果flags[6]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">52      | drives_length     |    (如果flags[7]被置位则出现)</span><br><span class="line">56      | drives_addr       |    (如果flags[7]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">60      | config_table      |    (如果flags[8]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">64      | boot_loader_name  |    (如果flags[9]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">68      | apm_table         |    (如果flags[10]被置位则出现)</span><br><span class="line">        +-------------------+</span><br><span class="line">72      | vbe_control_info  |    (如果flags[11]被置位则出现)</span><br><span class="line">76      | vbe_mode_info     |</span><br><span class="line">80      | vbe_mode          |</span><br><span class="line">82      | vbe_interface_seg |</span><br><span class="line">84      | vbe_interface_off |</span><br><span class="line">86      | vbe_interface_len |</span><br><span class="line">        +-------------------+</span><br></pre></td></tr></tbody></table></figure><p>第一个 longword 指出 Multiboot 信息结构中的其它域是否有效。所有目前未定义的位必须被引导程序设为 0。操作系统应该忽略任何它不理解的位。因此，flags 域也可以视作一个版本标志符，这样可以无破坏的扩展 Multiboot 信息结构。</p><p>如果设置了 flags 中的第 0 位，则 mem_* 域有效。mem_lower 和 mem_upper 分别指出了低端和高端内存的大小，单位是 K。低端内存的首地址是 0，高端内存的首地址是 1M。低端内存的最大可能值是 640K。返回的高端内存的最大可能值是最大值减去 1M。但并不保证是这个值。</p><p>如果设置了 flags 中的第 1 位，则 boot_device 域有效，并指出引导程序从哪个 BIOS 磁盘设备载入的 OS 映像。如果 OS 映像不是从一个 BIOS 磁盘载入的，这个域就决不能出现（第 3 位必须是 0）。操作系统可以使用这个域来帮助确定它的 root 设备，但并不一定要这样做。boot_device 域由四个单字节的子域组成：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------+-------+-------+</span><br><span class="line">| part3 | part2 | part1 | drive |</span><br><span class="line">+-------+-------+-------+-------+</span><br><span class="line">最低有效字节最高有效字节</span><br></pre></td></tr></tbody></table></figure><p>最高有效字节字节包含了 BIOS 驱动器号，它的格式与 BIOS 的 INT0x13 低级磁盘接口相同：例如，0x00 代表第一个软盘驱动器，0x80 代表第一个硬盘驱动器。</p><p>剩下的三个字节指出了引导分区。part1 指出顶级分区号，part2 指出一个顶级分区中的一个子分区，等等。分区号总是从 0 开始。不使用的分区字节必须被设为 0xFF。例如，如果磁盘被简单的分为单一的一层 DOS 分区，则 part1 包含这个 DOS 分区号，part2 和 part3 都是 0xFF。另一个例子是，如果一个磁盘先被分为 DOS 分区，并且其中的一个 DOS 分区又被分为几个使用 BSD 磁盘标签策略的 BSD 分区，则 part1 包含 DOS 分区号，part2 包含 DOS 分区内的 BSD 子分区，part3 是 0xFF。</p><p>DOS 扩展分区的分区号从 4 开始，而不是像嵌套子分区一样，尽管扩展分区的底层分布就是分层嵌套的。例如，如果引导程序从传统的 DOS 风格磁盘的第二个分区启动，则 part1 是 5，part2 和 part3 都是 0xFF。</p><p>如果设置了 flags longword 的第 2 位，则 cmdline 域有效，并包含要传送给内核的命令行参数的物理地址。命令行参数是一个正常 C 风格的以 0 终止的字符串。</p><p>如果设置了 flags 的第 3 位，则 mods 域指出了同内核一同载入的有哪些引导模块，以及在哪里能找到它们。mods_count 包含了载入的模块的个数；mods_addr 包含了第一个模块结构的物理地址。mods_count 可以是 0，这表示没有载入任何模块，即使设置了 flags 的第 1 位时也有可能是这样。每个模块结构的格式如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        +-------------------+</span><br><span class="line">0       | mod_start         |</span><br><span class="line">4       | mod_end           |</span><br><span class="line">        +-------------------+</span><br><span class="line">8       | string            |</span><br><span class="line">        +-------------------+</span><br><span class="line">12      | reserved (0)      |</span><br><span class="line">        +-------------------+</span><br></pre></td></tr></tbody></table></figure><p>前两个域包含了引导模块的开始和结束地址。string 域提供了一个自定义的与引导模块相关的字符串；它是以 0 中止的 ASCII 字符串，同内核命令行参数一样。如果没有什么与模块有关的字符串，string 域可以是 0。典型情况下，这个字符串也许是命令行参数（例如，如果操作系统将引导模块视作可执行程序的话），或者一个路径名（例如，如果操作系统将引导模块视作文件系统中的文件的话），它的意义取决于操作系统。reserved 域必须由引导程序设为 0 并被操作系统忽略。</p><p><strong>注意：</strong>第 4 位和第 5 位是互斥的。</p><p>如果设置了 flags 的第 4 位，则下面从 Multiboot 信息结构的第 28 位开始的域是有效的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        +-------------------+</span><br><span class="line">28      | tabsize           |</span><br><span class="line">32      | strsize           |</span><br><span class="line">36      | addr              |</span><br><span class="line">40      | reserved (0)      |</span><br><span class="line">        +-------------------+</span><br></pre></td></tr></tbody></table></figure><p>这指出在哪里可以找到 a.out 格式内核映像的符号表。addr 是 a.out 格式的 nlist 结构数组的大小（4 字节无符号长整数）的物理地址，紧接着是数组本身，然后是一系列以 0 中止的 ASCII 字符串的大小（4 字节无符号长整数，加上 sizeof(unsigned long)），然后是字符串本身。tabsize 等于符号表的大小参数（位于符号 section 的头部），strsize 等于符号表指向的字符串表的大小参数（位于 string section 的头部）。注意 tabsize 可以是 0，这意味着没有符号，尽管已经设置了 flags 的第 4 位。</p><p>如果设置了 flags 的第 5 位，则下面从 Multiboot 信息结构的第 28 位开始的域是有效的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        +-------------------+</span><br><span class="line">28      | num               |</span><br><span class="line">32      | size              |</span><br><span class="line">36      | addr              |</span><br><span class="line">40      | shndx             |</span><br><span class="line">        +-------------------+</span><br></pre></td></tr></tbody></table></figure><p>这指出在哪里可以找到 ELF 格式内核映像的 section 头表、每项的大小、一共有几项以及作为名字索引的字符串表。它们对应于可执行可连接格式（ELF）的 program 头中的<code>shdr_*</code> 项（shdr_num 等）。所有的 section 都会被载入，ELF section 头的物理地址域指向所有的 section 在内存中的位置（参见 i386 ELF 文档以得到如何读取 section 头的更多的细节）。注意，shdr_num 可以是 0，标志着没有符号，尽管已经设置了 flags 的第 5 位。</p><p>如果设置了 flags 的第 6 位，则 mmap_* 域是有效的，指出保存由 BIOS 提供的内存分布的缓冲区的地址和长度。mmap_addr 是缓冲区的地址，mmap_length 是缓冲区的总大小。缓冲区由一个或者多个下面的大小 / 结构对（size 实际上是用来跳过下一个对的）组成的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        +-------------------+</span><br><span class="line">-4      | size              |</span><br><span class="line">        +-------------------+</span><br><span class="line">0       | base_addr_low     |</span><br><span class="line">4       | base_addr_high    |</span><br><span class="line">8       | length_low        |</span><br><span class="line">12      | length_high       |</span><br><span class="line">16      | type              |</span><br><span class="line">        +-------------------+</span><br></pre></td></tr></tbody></table></figure><p>size 是相关结构的大小，单位是字节，它可能大于最小值 20。base_addr_low 是启动地址的低 32 位，base_addr_high 是高 32 位，启动地址总共有 64 位。length_low 是内存区域大小的低 32 位，length_high 是内存区域大小的高 32 位，总共是 64 位。type 是相应地址区间的类型，1 代表可用 RAM，所有其它的值代表保留区域。</p><p>可以保证所提供的内存分布列出了所有可供正常使用的标准内存。</p><p>如果设置了 flags 的第 7 位，则 drives_* 域是有效的，指出第一个驱动器结构的物理地址和这个结构的大小。drives_addr 是地址，drives_length 是驱动器结构的总大小。注意，drives_length 可以是 0。每个驱动器结构的格式如下：  　</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        +-------------------+</span><br><span class="line">0       | size              |</span><br><span class="line">        +-------------------+</span><br><span class="line">4       | drive_number      |</span><br><span class="line">        +-------------------+</span><br><span class="line">5       | drive_mode        |</span><br><span class="line">        +-------------------+</span><br><span class="line">6       | drive_cylinders   |</span><br><span class="line">8       | drive_heads       |</span><br><span class="line">9       | drive_sectors     |</span><br><span class="line">        +-------------------+</span><br><span class="line">10 - xx | drive_ports       |</span><br><span class="line">        +-------------------+</span><br></pre></td></tr></tbody></table></figure><p>size 域指出了结构的大小。依据端口的数量不同，这个大小可能变化。注意，这个大小可能不等于（10 + 2 * 端口数），这是由于对齐的原因。</p><p>drive_number 域包含 BIOS 驱动器号。drive_mode 域代表了引导程序使用的访问模式。目前，模式定义如下：</p><p><code>0</code></p><p>​    CHS 模式（传统的 “柱面 / 磁头 / 扇区” 寻址模式）。  　</p><p><code>1</code></p><p>​    LBA 模式（逻辑块寻址模式）。</p><p>这三个域，drive_cylinders、drive_heads 和 drive_sectors，指出了 BIOS 检测到的驱动器的参数。drive_cylinders 包含柱面数，drive_heads 包含磁头数，drive_sectors 包含每磁道的扇区数。</p><p>drive_ports 域包含了 BIOS 代码使用的 I/O 端口的数组。这个数组包含 0 个或者多个无符号两字节整数，并且以 0 中止。注意，数组中可能包含任何实际上与驱动器不相关的 I/O 端口（例如 DMA 控制器的端口）。</p><p>如果设置了 flags 的第 8 位，则 config_table 域有效，指出由 GET CONFIGURATION BIOS 调用返回的 ROM 配置表的物理地址。如果这个 BIOS 调用失败了，则这个表的大小必须是 0。</p><p>如果设置了 flags 的第 9 位，则 boot_loader_name 域有效，包含了引导程序名字在物理内存中的地址。引导程序名字是正常的 C 风格的以 0 中止的字符串。</p><p>如果设置了 flags 的第 10 位，则 apm_table 域有效，包含了如下 APM 表的物理地址：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        +----------------------+</span><br><span class="line">0       | version              |</span><br><span class="line">2       | cseg                 |</span><br><span class="line">4       | offset               |</span><br><span class="line">8       | cseg_16              |</span><br><span class="line">10      | dseg                 |</span><br><span class="line">12      | flags                |</span><br><span class="line">14      | cseg_len             |</span><br><span class="line">16      | cseg_16_len          |</span><br><span class="line">18      | dseg_len             |</span><br><span class="line">        +----------------------+</span><br></pre></td></tr></tbody></table></figure><p>域 version、cseg、offset、cseg_16、dseg、flags、cseg_len、cseg_16_len、dseg_len 分别指出了版本号、保护模式 32 位代码段、入口点的偏移量、保护模式 16 位代码段、保护模式 16 位数据段、标志位、保护模式 32 位代码段的长度、保护模式 16 位代码段的长度和保护模式 16 位数据段的长度。只有 offset 域是 4 字节，其余的域都是 2 字节。参见<a href="http://www.microsoft.com/hwdev/busbios/amp_12.htm">高级电源管理（APM）BIOS 接口规范</a>。</p><p>如果设置了 flags 的第 11 位，则 graphics table 有效。前提是内核已经在 Multiboot 头中指定了一种图形模式。</p><p>域 vbe_control_info 和 vbe_mode_info 分别包含由 VBE 函数 00h 返回的 VBE 控制信息的物理地址和由 VBE 函数 01h 返回的 VBE 模式信息。</p><p>域 vbe_mode 指出了当前的显示模式，其中的信息符合 VBE 3.0 标准。</p><p>其余的域 vbe_interface_seg、vbe_interface_off 和 vbe_interface_len 包含了 VBE 2.0 + 中定义的保护模式接口。如果没有这些信息，这些域都是 0 。注意 VBE 3.0 定义了另一个保护模式接口，它与以前的版本是兼容的。如果你想要使用这些新的保护模式接口，你必须自己找到这个表。</p><p>graphics table 中的域是按照 VBE 设计的，但是 Multiboot 引导程序可以在非 VBE 模式下模拟 VBE 模式。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>注意:</strong> 下面的内容不是规范文档的一部分，它们是给操作系统和引导程序编写者提供的示例。</p><ul><li><p>PC 机注记</p></li><li><p>BIOS 设备映射技术</p></li><li><p>OS 代码示例</p></li><li><p>引导程序代码示例</p></li></ul><h3 id="PC-机注记"><a href="#PC-机注记" class="headerlink" title="PC 机注记"></a>PC 机注记</h3><p>在使用 Multiboot 信息结构中 flags 参数的第 0 位时，如果使用的引导程序使用较老的 BIOS 接口，或者还不被支持的最新的接口（参见有关第 6 位的描述），则返回的内存大小可能是 15 或者 63M。因此强烈推荐引导程序进行彻底的内存检查。&nbsp;</p><p>在使用 Multiboot 信息结构中 flags 参数的第 1 位时，我们发现在最好的情况下，将哪个 BIOS 驱动器映射到哪个操作系统的设备驱动程序的决定也不容易做出。针对各种各样的操作系统提出了许多的笨拙的办法但都没有解决问题，大多数在很多情况下都会失败。为了鼓励使用通用的方法解决这个问题，我们提供了 2 种 BIOS 设备映射技术（参见 BIOS 设备映射技术）。</p><p>在使用 Multiboot 信息结构中 flags 参数的第 6 位时，一定要注意这里用到的数据结构（自 BaseAddrLow 开始）时由 INT 15h, AX=E820h——查询系统地址地图调用返回的数据。参见<a href="http://www.gnu.org/software/grub/manual/multiboot/grub.info.html#Query%20System%20Address%20Map">查询系统地址映射</a>。这里的接口用来使一个引导程序可以不用修改的同进行过合理扩展的 BIOS 接口共同工作，如果这些扩展只是给予操作系统更多的信息的话。</p><h3 id="BIOS-设备映射技术"><a href="#BIOS-设备映射技术" class="headerlink" title="BIOS 设备映射技术"></a>BIOS 设备映射技术</h3><p>这两个技术应该可以用于任何的 PC 操作系统，并且也不需要驱动程序本身提供任何的特殊支持。本节将大量的讨论细节问题，尤其是 I/O 限制技术。</p><p>通用的规则是数据比较技术，它是快速但丑陋的解决方案。它在大多数情况下工作正常，但是并不总是这样，不过它相对简单。</p><p>I/O 限制技术要复杂得多，但它更有可能在所有情况下解决问题，另外还允许在并非所有的 BIOS 设备拥有操作系统的驱动程序时访问有驱动程序的 BIOS 设备。</p><ul><li><p>数据比较技术</p></li><li><p>I/O 限制技术</p></li></ul><h3 id="数据比较技术"><a href="#数据比较技术" class="headerlink" title="数据比较技术"></a>数据比较技术</h3><p>在激活 _任何_设备驱动程序之前，要从每个磁盘上的相似扇区中收集足够的数据，这样就可以区分每个扇区。</p><p>在激活了设备驱动程序之后，使用操作系统驱动比较不同驱动器的数据。这样就可以为映射提供足够的信息。</p><p>问题：</p><ol><li> 一些 BIOS 设备上的数据可能是相同的（所以从 BIOS 读取设备信息的方法有可能失败）。</li><li> 可能有一些 BIOS 不可访问的设备同 BIOS 用到的设备相同（所以这时这种方法也可能会宣告失败）。</li></ol><h3 id="I-O-限制技术"><a href="#I-O-限制技术" class="headerlink" title="I/O 限制技术"></a>I/O 限制技术</h3><p>第一步并不是必要的，但首先为设备驱动程序创建 copy-on-write 映射。随后创建 洁净 BIOS 虚拟机的原始拷贝。</p><p>对于每个设备驱动程序，决定哪个 BIOS 设备不可访问，方法是：</p><ol><li> 创建一个洁净的 BIOS 虚拟机。</li><li> 将设备驱动程序要求的 I/O 区域在 I/O 允许位图中设置为无权限（既不能读也不能写）。</li><li> 访问每个设备。</li><li> 记录哪些设备访问成功，以及哪些试图访问受限 I/O 区域（这将可能是一个 xor 情景）。</li></ol><p>对于每个设备驱动程序，假设已知其中有多少个 BIOS 设备（这个表中应该没有缝隙），应该很容易的确定哪些设备受这些控制器控制。</p><p>通常，每个拥有 BIOS 号的控制器上你至多有两个磁盘，它们总是从控制器逻辑号最低的设备数起。</p><h3 id="OS-代码示例"><a href="#OS-代码示例" class="headerlink" title="OS 代码示例"></a>OS 代码示例</h3><p>在这个发行版中，包括了示例 Multiboot 内核 kernel。这个内核只在屏幕上输出 Multiboot 信息结构，所以你可以利用这个内核检测一个 Multiboot 兼容的引导程序，或者作为如何实现一个 Multiboot 内核的参考。源文件可以在 GRUB 发行版的 docs 目录中找到。</p><p>内核 kernel 仅由三个文件组成：boot.S、kernel.c 和 multiboot.h。汇编源代码 boot.S 使用 GAS 汇编格式，包含符合本规范的 Multiboot 信息结构。当一个 Multiboot 兼容的引导程序载入并执行它时，它初始化堆栈指针和 EFLAGS，然后调用 kernel.c 中定义的函数 cmain。如果 cmain 返回，则它显示一条消息通知用户进入停机状态并停止知道你按下 reset 键。文件 kernel.c 包含函数 cmain，它检查引导程序传递来的魔数是否有效等等，以及一些向屏幕输出消息的函数。文件 multiboot.h 定义了一些宏，如 Multiboot 头的魔数，Multiboot 头结构和 Multiboot 信息结构等。&nbsp;</p><ul><li><p>multiboot.h</p></li><li><p>boot.S</p></li><li><p>kernel.c</p></li><li><p>其他 Multiboot 内核</p></li></ul><h4 id="multiboot-h"><a href="#multiboot-h" class="headerlink" title="multiboot.h"></a>multiboot.h</h4><p>这是 <code>multiboot.h</code> 文件中的源代码：  　</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* multiboot.h - Multiboot 的 header */</span></span><br><span class="line"><span class="comment">/* Copyright (C) 1999, 2001  Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">   it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment">   the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment">   (at your option) any later version.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">   GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment">   along with this program; if not, write to the Free Software</span></span><br><span class="line"><span class="comment">   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiboot header 的魔数。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTIBOOT_HEADER_MAGIC          0x1BADB002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiboot header 的标志。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ELF__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MULTIBOOT_HEADER_FLAGS         0x00000003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MULTIBOOT_HEADER_FLAGS         0x00010003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiboot 兼容的引导程序传递来的魔数。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTIBOOT_BOOTLOADER_MAGIC      0x2BADB002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆栈大小 (16KB)。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE                      0x4000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* C 符号格式。HAVE_ASM_USCORE 由 configure 定义。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_ASM_USCORE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXT_C(sym)                     _ ## sym</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXT_C(sym)                     sym</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ASM</span></span><br><span class="line"><span class="comment">/* 不要在 boot.S 中 include 这里。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类型定义。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiboot header。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiboot_header</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> magic;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> header_addr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> load_addr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> load_end_addr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> bss_end_addr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> entry_addr;</span><br><span class="line">} <span class="keyword">multiboot_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* a.out 符号表。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aout_symbol_table</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> tabsize;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> strsize;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> reserved;</span><br><span class="line">} <span class="keyword">aout_symbol_table_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ELF 的 section header table。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf_section_header_table</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> num;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> shndx;</span><br><span class="line">} <span class="keyword">elf_section_header_table_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multiboot 信息。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiboot_info</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mem_lower;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mem_upper;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> boot_device;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cmdline;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mods_count;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mods_addr;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  {</span></span><br><span class="line">    <span class="keyword">aout_symbol_table_t</span> aout_sym;</span><br><span class="line">    <span class="keyword">elf_section_header_table_t</span> elf_sec;</span><br><span class="line">  } u;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_addr;</span><br><span class="line">} <span class="keyword">multiboot_info_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块结构。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mod_start;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mod_end;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> reserved;</span><br><span class="line">} <span class="keyword">module_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存分布。小心，偏移量 0 是 base_addr_low 而不是 size 。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">memory_map</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> base_addr_low;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> base_addr_high;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> length_low;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> length_high;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> type;</span><br><span class="line">} <span class="keyword">memory_map_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ! ASM */</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="boot-S"><a href="#boot-S" class="headerlink" title="boot.S"></a>boot.S</h4><p>文件 <code>boot.S</code> 的内容是：  　</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/* boot.S - 引导内核 */</span><br><span class="line">/* Copyright (C) 1999, 2001  Free Software Foundation, Inc.</span><br><span class="line"></span><br><span class="line">   This program is free software; you can redistribute it and/or modify</span><br><span class="line">   it under the terms of the GNU General Public License as published by</span><br><span class="line">   the Free Software Foundation; either version 2 of the License, or</span><br><span class="line">   (at your option) any later version.</span><br><span class="line"></span><br><span class="line">   This program is distributed in the hope that it will be useful,</span><br><span class="line">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="line">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><br><span class="line">   GNU General Public License for more details.</span><br><span class="line"></span><br><span class="line">   You should have received a copy of the GNU General Public License</span><br><span class="line">   along with this program; if not, write to the Free Software</span><br><span class="line">   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */</span><br><span class="line"></span><br><span class="line">#define ASM     1</span><br><span class="line">#include &lt;multiboot.h&gt;</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line"></span><br><span class="line">        .globl  start, _start</span><br><span class="line">start:</span><br><span class="line">_start:</span><br><span class="line">        jmp     multiboot_entry</span><br><span class="line"></span><br><span class="line">        /* 32 位对齐。 */</span><br><span class="line">        .align  4</span><br><span class="line"></span><br><span class="line">        /* Multiboot header。 */</span><br><span class="line">multiboot_header:</span><br><span class="line">        /* magic */</span><br><span class="line">        .long   MULTIBOOT_HEADER_MAGIC</span><br><span class="line">        /* flags */</span><br><span class="line">        .long   MULTIBOOT_HEADER_FLAGS</span><br><span class="line">        /* checksum */</span><br><span class="line">        .long   -(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)</span><br><span class="line">#ifndef __ELF__</span><br><span class="line">        /* header_addr */</span><br><span class="line">        .long   multiboot_header</span><br><span class="line">        /* load_addr */</span><br><span class="line">        .long   _start</span><br><span class="line">        /* load_end_addr */</span><br><span class="line">        .long   _edata</span><br><span class="line">        /* bss_end_addr */</span><br><span class="line">        .long   _end</span><br><span class="line">        /* entry_addr */</span><br><span class="line">        .long   multiboot_entry</span><br><span class="line">#endif /* ! __ELF__ */</span><br><span class="line"></span><br><span class="line">multiboot_entry:</span><br><span class="line">        /* 初始化堆栈指针。 */</span><br><span class="line">        movl    $(stack + STACK_SIZE), %esp</span><br><span class="line"></span><br><span class="line">        /* 重置 EFLAGS。 */</span><br><span class="line">        pushl   $0</span><br><span class="line">        popf</span><br><span class="line"></span><br><span class="line">        /* 将指向 Multiboot 信息结构的指针入栈。 */</span><br><span class="line">        pushl   %ebx</span><br><span class="line">        /* 将魔数入栈。 */</span><br><span class="line">        pushl   %eax</span><br><span class="line"></span><br><span class="line">        /* 现在进入 C main 函数... */</span><br><span class="line">        call    EXT_C(cmain)</span><br><span class="line"></span><br><span class="line">        /* 停机。 */</span><br><span class="line">        pushl   $halt_message</span><br><span class="line">        call    EXT_C(printf)</span><br><span class="line"></span><br><span class="line">loop:   hlt</span><br><span class="line">        jmp     loop</span><br><span class="line"></span><br><span class="line">halt_message:</span><br><span class="line">        .asciz  "Halted."</span><br><span class="line"></span><br><span class="line">        /* 我们的堆栈区。 */</span><br><span class="line">        .comm   stack, STACK_SIZE</span><br></pre></td></tr></tbody></table></figure><h4 id="kernel-c"><a href="#kernel-c" class="headerlink" title="kernel.c"></a>kernel.c</h4><p>文件 <code>kernel.c</code> 中的内容：  　</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel.c - 内核的 C 语言部分 */</span></span><br><span class="line"><span class="comment">/* Copyright (C) 1999  Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">   it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment">   the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment">   (at your option) any later version.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">   GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment">   along with this program; if not, write to the Free Software</span></span><br><span class="line"><span class="comment">   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;multiboot.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测 FLAGS 中的位 BIT 是否被置位。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_FLAG(flags,bit)   ((flags) &amp; (1 &lt;&lt; (bit)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 与显示相关的设置。 */</span></span><br><span class="line"><span class="comment">/* 列数。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLUMNS                 80</span></span><br><span class="line"><span class="comment">/* 行数。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINES                   24</span></span><br><span class="line"><span class="comment">/* 字符属性。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATTRIBUTE               7</span></span><br><span class="line"><span class="comment">/* 显存地址。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO                   0xB8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变量。 */</span></span><br><span class="line"><span class="comment">/* X 坐标。 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> xpos;</span><br><span class="line"><span class="comment">/* Y 坐标。 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ypos;</span><br><span class="line"><span class="comment">/* 指向显存。 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *video;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前导声明。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmain</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> magic, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cls</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">itoa</span> <span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> base, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putchar</span> <span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查 MAGIC 是否有效并打印 ADDR 指向的 Multiboot 信息结构。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cmain</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> magic, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">multiboot_info_t</span> *mbi;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清屏。 */</span></span><br><span class="line">  cls ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 引导装载器是否符合 Multiboot 规范？ */</span></span><br><span class="line">  <span class="keyword">if</span> (magic != MULTIBOOT_BOOTLOADER_MAGIC)</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">"Invalid magic number: 0x%x/n"</span>, (<span class="keyword">unsigned</span>) magic);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 MBI 指向 Multiboot 信息结构。 */</span></span><br><span class="line">  mbi = (<span class="keyword">multiboot_info_t</span> *) addr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 输出标志。 */</span></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"flags = 0x%x/n"</span>, (<span class="keyword">unsigned</span>) mbi-&gt;flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* mem_* 是否有效？ */</span></span><br><span class="line">  <span class="keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"mem_lower = %uKB, mem_upper = %uKB/n"</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span>) mbi-&gt;mem_lower, (<span class="keyword">unsigned</span>) mbi-&gt;mem_upper);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* boot_device 是否有效？ */</span></span><br><span class="line">  <span class="keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"boot_device = 0x%x/n"</span>, (<span class="keyword">unsigned</span>) mbi-&gt;boot_device);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 是否有命令行参数？ */</span></span><br><span class="line">  <span class="keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"cmdline = %s/n"</span>, (<span class="keyword">char</span> *) mbi-&gt;cmdline);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* mods_* 是否有效？ */</span></span><br><span class="line">  <span class="keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="number">3</span>))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">module_t</span> *mod;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">"mods_count = %d, mods_addr = 0x%x/n"</span>,</span><br><span class="line">              (<span class="keyword">int</span>) mbi-&gt;mods_count, (<span class="keyword">int</span>) mbi-&gt;mods_addr);</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, mod = (<span class="keyword">module_t</span> *) mbi-&gt;mods_addr;</span><br><span class="line">           i &lt; mbi-&gt;mods_count;</span><br><span class="line">           i++, mod += <span class="keyword">sizeof</span> (<span class="keyword">module_t</span>))</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">" mod_start = 0x%x, mod_end = 0x%x, string = %s/n"</span>,</span><br><span class="line">                (<span class="keyword">unsigned</span>) mod-&gt;mod_start,</span><br><span class="line">                (<span class="keyword">unsigned</span>) mod-&gt;mod_end,</span><br><span class="line">                (<span class="keyword">char</span> *) mod-&gt;<span class="built_in">string</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第 4 位和第 5 位是互斥的！ */</span></span><br><span class="line">  <span class="keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="number">4</span>) &amp;&amp; CHECK_FLAG (mbi-&gt;flags, <span class="number">5</span>))</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">"Both bits 4 and 5 are set./n"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 是否有 a.out 符号表？ */</span></span><br><span class="line">  <span class="keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="number">4</span>))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">aout_symbol_table_t</span> *aout_sym = &amp;(mbi-&gt;u.aout_sym);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">"aout_symbol_table: tabsize = 0x%0x, "</span></span><br><span class="line">              <span class="string">"strsize = 0x%x, addr = 0x%x/n"</span>,</span><br><span class="line">              (<span class="keyword">unsigned</span>) aout_sym-&gt;tabsize,</span><br><span class="line">              (<span class="keyword">unsigned</span>) aout_sym-&gt;strsize,</span><br><span class="line">              (<span class="keyword">unsigned</span>) aout_sym-&gt;addr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 是否有 ELF section header table？ */</span></span><br><span class="line">  <span class="keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="number">5</span>))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">elf_section_header_table_t</span> *elf_sec = &amp;(mbi-&gt;u.elf_sec);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">"elf_sec: num = %u, size = 0x%x,"</span></span><br><span class="line">              <span class="string">" addr = 0x%x, shndx = 0x%x/n"</span>,</span><br><span class="line">              (<span class="keyword">unsigned</span>) elf_sec-&gt;num, (<span class="keyword">unsigned</span>) elf_sec-&gt;size,</span><br><span class="line">              (<span class="keyword">unsigned</span>) elf_sec-&gt;addr, (<span class="keyword">unsigned</span>) elf_sec-&gt;shndx);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* mmap_* 是否有效？ */</span></span><br><span class="line">  <span class="keyword">if</span> (CHECK_FLAG (mbi-&gt;flags, <span class="number">6</span>))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">memory_map_t</span> *mmap;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">"mmap_addr = 0x%x, mmap_length = 0x%x/n"</span>,</span><br><span class="line">              (<span class="keyword">unsigned</span>) mbi-&gt;mmap_addr, (<span class="keyword">unsigned</span>) mbi-&gt;mmap_length);</span><br><span class="line">      <span class="keyword">for</span> (mmap = (<span class="keyword">memory_map_t</span> *) mbi-&gt;mmap_addr;</span><br><span class="line">           (<span class="keyword">unsigned</span> <span class="keyword">long</span>) mmap &lt; mbi-&gt;mmap_addr + mbi-&gt;mmap_length;</span><br><span class="line">           mmap = (<span class="keyword">memory_map_t</span> *) ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) mmap</span><br><span class="line">                                    + mmap-&gt;size + <span class="keyword">sizeof</span> (mmap-&gt;size)))</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">" size = 0x%x, base_addr = 0x%x%x,"</span></span><br><span class="line">                <span class="string">" length = 0x%x%x, type = 0x%x/n"</span>,</span><br><span class="line">                (<span class="keyword">unsigned</span>) mmap-&gt;size,</span><br><span class="line">                (<span class="keyword">unsigned</span>) mmap-&gt;base_addr_high,</span><br><span class="line">                (<span class="keyword">unsigned</span>) mmap-&gt;base_addr_low,</span><br><span class="line">                (<span class="keyword">unsigned</span>) mmap-&gt;length_high,</span><br><span class="line">                (<span class="keyword">unsigned</span>) mmap-&gt;length_low,</span><br><span class="line">                (<span class="keyword">unsigned</span>) mmap-&gt;type);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清屏并初始化 VIDEO，XPOS 和 YPOS。 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cls</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  video = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) VIDEO;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; COLUMNS * LINES * <span class="number">2</span>; i++)</span><br><span class="line">    *(video + i) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  xpos = <span class="number">0</span>;</span><br><span class="line">  ypos = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将整数 D 转换为字符串并保存在 BUF 中。如果 BASE 为 'd'，则 D 为十进制，如果 BASE 为 'x'，则 D 为十六进制。 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">itoa</span> <span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> base, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">char</span> *p = buf;</span><br><span class="line">  <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ud = d;</span><br><span class="line">  <span class="keyword">int</span> divisor = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果指定了 %d 并且 D 是负数，在开始添上负号。 */</span></span><br><span class="line">  <span class="keyword">if</span> (base == <span class="string">'d'</span> &amp;&amp; d &lt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      *p++ = <span class="string">'-'</span>;</span><br><span class="line">      buf++;</span><br><span class="line">      ud = -d;</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="string">'x'</span>)</span><br><span class="line">    divisor = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用 DIVISOR 去除 UD 直到 UD == 0。 */</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">int</span> remainder = ud % divisor;</span><br><span class="line"></span><br><span class="line">      *p++ = (remainder &lt; <span class="number">10</span>) ? remainder + <span class="string">'0'</span> : remainder + <span class="string">'a'</span> - <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">while</span> (ud /= divisor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在字符串尾添上终结符。 */</span></span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 反转 BUF。 */</span></span><br><span class="line">  p1 = buf;</span><br><span class="line">  p2 = p - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt; p2)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">char</span> tmp = *p1;</span><br><span class="line">      *p1 = *p2;</span><br><span class="line">      *p2 = tmp;</span><br><span class="line">      p1++;</span><br><span class="line">      p2--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在屏幕上输出字符 C 。 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">putchar</span> <span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">'/n'</span> || c == <span class="string">'/r'</span>)</span><br><span class="line">    {</span><br><span class="line">    newline:</span><br><span class="line">      xpos = <span class="number">0</span>;</span><br><span class="line">      ypos++;</span><br><span class="line">      <span class="keyword">if</span> (ypos &gt;= LINES)</span><br><span class="line">        ypos = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  *(video + (xpos + ypos * COLUMNS) * <span class="number">2</span>) = c &amp; <span class="number">0xFF</span>;</span><br><span class="line">  *(video + (xpos + ypos * COLUMNS) * <span class="number">2</span> + <span class="number">1</span>) = ATTRIBUTE;</span><br><span class="line"></span><br><span class="line">  xpos++;</span><br><span class="line">  <span class="keyword">if</span> (xpos &gt;= COLUMNS)</span><br><span class="line">    <span class="keyword">goto</span> newline;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 格式化字符串并在屏幕上输出，就像 libc 函数 printf 一样。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">printf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">char</span> **arg = (<span class="keyword">char</span> **) &amp;format;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  arg++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((c = *format++) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> (c != <span class="string">'%'</span>)</span><br><span class="line">        <span class="built_in">putchar</span> (c);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">          c = *format++;</span><br><span class="line">          <span class="keyword">switch</span> (c)</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'x'</span>:</span><br><span class="line">              itoa (buf, c, *((<span class="keyword">int</span> *) arg++));</span><br><span class="line">              p = buf;</span><br><span class="line">              <span class="keyword">goto</span> <span class="built_in">string</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">              p = *arg++;</span><br><span class="line">              <span class="keyword">if</span> (! p)</span><br><span class="line">                p = <span class="string">"(null)"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span>:</span><br><span class="line">              <span class="keyword">while</span> (*p)</span><br><span class="line">                <span class="built_in">putchar</span> (*p++);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="built_in">putchar</span> (*((<span class="keyword">int</span> *) arg++));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他-Multiboot-内核"><a href="#其他-Multiboot-内核" class="headerlink" title="其他 Multiboot 内核"></a>其他 Multiboot 内核</h3><p>可以从 Multiboot 内核那里得到其它有用的信息，如 GNU Mach 和 Fiasco &lt;<a href="http://os.inf.tu-dresden.de/fiasco/">http://os.inf.tu-dresden.de/fiasco/</a>&gt;。最后，很有必要介绍一下 OSKit &lt;<a href="http://www.cs.utah.edu/projects/flux/oskit/">http://www.cs.utah.edu/projects/flux/oskit/</a>&gt;，它提供了一个支持本规范的库。</p><h3 id="引导程序代码示例"><a href="#引导程序代码示例" class="headerlink" title="引导程序代码示例"></a>引导程序代码示例</h3><p>GNU GRUB 项目是一个完全支持的 Multiboot 的引导程序，支持本规范中所有必需的和可选的特性。目前并没有公开的发行版，但是可以从这里得到：</p><p>&lt;<a href="ftp://alpha.gnu.org/gnu/grub">ftp://alpha.gnu.org/gnu/grub</a>&gt;</p><p>参见网页 &lt;<a href="http://www.gnu.org/software/grub/grub.html">http://www.gnu.org/software/grub/grub.html</a>&gt;，以得到更多信息。</p><h2 id="本规范的修改日志"><a href="#本规范的修改日志" class="headerlink" title="本规范的修改日志"></a>本规范的修改日志</h2><p>0.7</p><ul><li>  Multiboot 标准更名为 Multiboot 规范。</li><li>  在 Multiboot 头加入了图形域。</li><li>  在 Multiboot 信息中加入了 BIOS 驱动信息、BIOS 配置表、引导程序名、APM 信息及图形信息。</li><li>  使用 Texinfo 格式重写了规范。</li><li>  重写了规范，用于更严谨。</li><li>维护者由 Bryan Ford 和 Erich Stefan Boleyn 变更为 GNU GRUB 维护团队 <a href="mailto:bug-grub@gnu.org">bug-grub@gnu.org</a>。</li></ul><p>0.6</p><ul><li>  修改了一些词汇。</li><li>  头校验和。</li><li>对传递给操作系统的机器状态进行了分类。</li></ul><p>0.5</p><ul><li>名称变更。</li></ul><p>0.4</p><ul><li>添加了版本。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>  Multiboot 规范</li><li>Multiboot 规范简介<ul><li>  Multiboot 规范诞生的背景</li><li>  目标架构</li><li>  目标操作系统</li><li>  引导源</li><li>  在引导时配置操作系统</li><li>  如何使操作系统开发更容易</li><li>  引导模块</li></ul></li><li>  本 Multiboot 规范中所用术语的定义</li><li>Multiboot 规范的精确定义<ul><li>OS 映像格式<ul><li>  Multiboot 头的分布</li><li>  Multiboot 头的 magic 域</li><li>  Multiboot 头的地址域</li><li>  Multiboot 头的图形域</li></ul></li><li>  机器状态</li><li>  引导信息格式</li></ul></li><li>示例<ul><li>  PC 机注记</li><li>BIOS 设备映射技术<ul><li>  数据比较技术</li><li>  I/O 限制技术</li></ul></li><li>OS 代码示例<ul><li>  multiboot.h</li><li>  boot.S</li><li>  kernel.c</li><li>  其他 Multiboot 内核</li></ul></li><li>  引导程序代码示例</li></ul></li><li>  本规范的修改日志</li><li>  索引</li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>va_list系列的使用及问题</title>
      <link href="/posts/608e8634"/>
      <url>/posts/608e8634</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%"> <h2 id="va-list"><a href="#va-list" class="headerlink" title="va_list"></a>va_list</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>引自 <a href="https://www.runoob.com/cprogramming/c-standard-library-stdarg-h.html">https://www.runoob.com/cprogramming/c-standard-library-stdarg-h.html</a></p></blockquote><p><strong>stdarg.h</strong> 头文件定义了一个变量类型 <strong>va_list</strong> 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。</p><p>可变参数的函数通在参数列表的末尾是使用省略号(,…)定义的。</p><h4 id="库变量"><a href="#库变量" class="headerlink" title="库变量"></a>库变量</h4><p>下面是头文件 stdarg.h 中定义的变量类型：</p><table><thead><tr><th align="left">序号</th><th align="left">变量 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>va_list</strong> 这是一个适用于 <strong>va_start()、va_arg()</strong> 和 <strong>va_end()</strong> 这三个宏存储信息的类型。</td></tr></tbody></table><h4 id="库宏"><a href="#库宏" class="headerlink" title="库宏"></a>库宏</h4><p>下面是头文件 stdarg.h 中定义的宏：</p><table><thead><tr><th align="left">序号</th><th align="left">宏 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_start.html">void va_start(va_list ap, last_arg)</a> 这个宏初始化 <strong>ap</strong> 变量，它与 <strong>va_arg</strong> 和 <strong>va_end</strong> 宏是一起使用的。<strong>last_arg</strong> 是最后一个传递给函数的已知的固定参数，即省略号之前的参数。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_arg.html">type va_arg(va_list ap, type)</a> 这个宏检索函数参数列表中类型为 <strong>type</strong> 的下一个参数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/cprogramming/c-macro-va_end.html">void va_end(va_list ap)</a> 这个宏允许使用了 <strong>va_start</strong> 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 <strong>va_end</strong>，则结果为未定义。</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>首先包含<code>stdarg.h</code>头文件</li><li>使用<code>va_list</code>初始化 指针</li><li>使用<code>va_start</code> 将 第2步中创建的指针添加、还有第一个参数</li><li>通过<code>va_arg</code> 将 第2步中创建的指针添加、以及要取的数据的类型</li><li>…</li><li>不使用<code>va_list</code>后，释放<code>va_start</code>的指针</li></ol><p>示例如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> p1, ...)</span></span>{</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> a = p1;</span><br><span class="line">    va_start(ap, p1);</span><br><span class="line">    <span class="keyword">double</span> b = va_arg(ap,<span class="keyword">double</span>);</span><br><span class="line">    <span class="keyword">char</span> c  = va_arg(ap,<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">char</span> *d = va_arg(ap,<span class="keyword">char</span> *);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\r\nb:%lf\r\nc:%d\r\nd:%s\r\n"</span>,a,b,c,d);</span><br><span class="line">    va_end(ap);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">2.2</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0x33</span>;</span><br><span class="line">    <span class="keyword">char</span> *d = <span class="string">"abcderf"</span>;</span><br><span class="line">    test(a,b,c,d);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将上述代码保存为test.c，使用命令 <code>gcc test.c </code>然后 <code>./a.out</code>执行</p><p>正常输出</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:1</span><br><span class="line">b:2.200000</span><br><span class="line">c:51</span><br><span class="line">d:abcderf</span><br></pre></td></tr></tbody></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>第一次写的代码为以下，编译时爆出几个警告，刚开始没注意，后面运行时发现<code>core dumped.</code> 遂回头查产生改现象的原因。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> p1, ...)</span></span>{</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> a = p1;</span><br><span class="line">    va_start(ap, p1);</span><br><span class="line">    <span class="keyword">float</span> b = va_arg(ap,<span class="keyword">float</span>);</span><br><span class="line">    <span class="keyword">char</span> c  = va_arg(ap,<span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">char</span> *d = va_arg(ap,<span class="keyword">char</span> *);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\r\nb:%lf\r\nc:%d\r\nd:%s\r\n"</span>,a,b,c,d);</span><br><span class="line">    va_end(ap);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">2.2</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0x33</span>;</span><br><span class="line">    <span class="keyword">char</span> *d = <span class="string">"abcderf"</span>;</span><br><span class="line">    test(a,b,c,d);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们注意到有两个warning，翻译一下：当通过<code>...</code>时，<code>float</code>被提升为<code>double</code>，另一个也是类似，<code>char</code> 被提升为<code>int</code>，<strong>所以使用<code>va_arg</code>访问时，传入参数类型为<code>char</code>，需要用<code>va_arg(ap,int)</code>；传入参数为<code>float</code>时，需使用<code>va_arg(arg,double)</code></strong> 。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[gonglja@archlinux hurlex-doc]$ gcc -g0 test.c </span><br><span class="line">In file included from test.c:2:</span><br><span class="line">test.c: In function ‘test’:</span><br><span class="line">test.c:8:25: warning: ‘float’ is promoted to ‘double’ when passed through ‘...’</span><br><span class="line">    8 |     float b = va_arg(ap,float);</span><br><span class="line">      |                         ^</span><br><span class="line">test.c:8:25: note: (so you should pass ‘double’ not ‘float’ to ‘va_arg’)</span><br><span class="line">test.c:8:25: note: if this code is reached, the program will abort</span><br><span class="line">test.c:9:25: warning: ‘char’ is promoted to ‘int’ when passed through ‘...’</span><br><span class="line">    9 |     char c  = va_arg(ap,char);</span><br><span class="line">      |                         ^</span><br><span class="line">test.c:9:25: note: if this code is reached, the program will abort</span><br><span class="line">[gonglja@archlinux hurlex-doc]$ ./a.out </span><br><span class="line">Illegal instruction (core dumped)</span><br><span class="line">[gonglja@archlinux hurlex-doc]$ </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>修改后，程序正常运行。</p><p>为什么 当通过<code>...</code>时，<code>float</code>被提升为<code>double</code>？<code>char</code> 提升为<code>int</code>呢？<del>==猜测是由于字节对齐引起的==</del>。</p><p><del>为了验证我们的猜测，在这个地方，我们看一下汇编代码，</del></p><p><del>由于涉及到浮点数，为了简单，我们简化一下代码，去掉浮点数相关。</del></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> p1, ...)</span></span>{</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> a = p1;</span><br><span class="line">    va_start(ap, p1);</span><br><span class="line">    <span class="keyword">char</span> c  = va_arg(ap,<span class="keyword">char</span>);<span class="comment">// 此处存在问题，应改为va_arg(ap,int)</span></span><br><span class="line">    <span class="keyword">char</span> *d = va_arg(ap,<span class="keyword">char</span> *);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d\r\nc:%d\r\nd:%s\r\n"</span>,a,c,d);</span><br><span class="line">    va_end(ap);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">51</span>;</span><br><span class="line">    <span class="keyword">char</span> *d = <span class="string">"abcderf"</span>;</span><br><span class="line">    test(a,c,d);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过 <code>gcc -S test.c</code> 生成 <code>test.s</code>文件，汇编源码如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">.file"test.c"</span><br><span class="line">.text</span><br><span class="line">.globltest</span><br><span class="line">.typetest, @function</span><br><span class="line">test:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq$120, %rsp</span><br><span class="line">movl%edi, -228(%rbp)</span><br><span class="line">movq%rsi, -168(%rbp)</span><br><span class="line">movq%rdx, -160(%rbp)</span><br><span class="line">movq%rcx, -152(%rbp)</span><br><span class="line">movq%r8, -144(%rbp)</span><br><span class="line">movq%r9, -136(%rbp)</span><br><span class="line">testb%al, %al</span><br><span class="line">je.L2</span><br><span class="line">movaps%xmm0, -128(%rbp)</span><br><span class="line">movaps%xmm1, -112(%rbp)</span><br><span class="line">movaps%xmm2, -96(%rbp)</span><br><span class="line">movaps%xmm3, -80(%rbp)</span><br><span class="line">movaps%xmm4, -64(%rbp)</span><br><span class="line">movaps%xmm5, -48(%rbp)</span><br><span class="line">movaps%xmm6, -32(%rbp)</span><br><span class="line">movaps%xmm7, -16(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">movq%fs:40, %rax</span><br><span class="line">movq%rax, -184(%rbp)</span><br><span class="line">xorl%eax, %eax</span><br><span class="line">movl-228(%rbp), %eax</span><br><span class="line">movl%eax, -212(%rbp)</span><br><span class="line">movl$8, -208(%rbp)</span><br><span class="line">movl$48, -204(%rbp)</span><br><span class="line">leaq16(%rbp), %rax</span><br><span class="line">movq%rax, -200(%rbp)</span><br><span class="line">leaq-176(%rbp), %rax</span><br><span class="line">movq%rax, -192(%rbp)</span><br><span class="line">ud2</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizetest, .-test</span><br><span class="line">.section.rodata</span><br><span class="line">.LC0:</span><br><span class="line">.string"abcderf"</span><br><span class="line">.text</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq$16, %rsp</span><br><span class="line">movl$1, -12(%rbp)</span><br><span class="line">movb$51, -13(%rbp)</span><br><span class="line">leaq.LC0(%rip), %rax</span><br><span class="line">movq%rax, -8(%rbp)</span><br><span class="line">movsbl-13(%rbp), %ecx</span><br><span class="line">movq-8(%rbp), %rdx</span><br><span class="line">movl-12(%rbp), %eax</span><br><span class="line">movl%ecx, %esi</span><br><span class="line">movl%eax, %edi</span><br><span class="line">movl$0, %eax</span><br><span class="line">calltest</span><br><span class="line">movl$0, %eax</span><br><span class="line">leave</span><br><span class="line">.cfi_def_cfa 7, 8</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.ident"GCC: (GNU) 11.2.0"</span><br><span class="line">.section.note.GNU-stack,"",@progbits</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>只关注重点地方代码，test调用之前，test调用之后。</p><p>找到 call test ，在call test之前，</p><p>rdi中存着第一个参数，值为1</p><p>rsi中存着第二个参数，值为2</p><p>rdx中存着第三个参数，值为字符串 的地址</p><p><img src="https://gitee.com/glj0/imgur/raw/master/photo/20220223165128.png"></p><p>接着调用<code>call test</code>，跳转至<code>test</code>中，首先保存<code>rbp</code>寄存器，更新<code>rbp</code>指针为<code>rsp</code>（栈顶指针），接着栈顶下移（分配空间），将<code>edi</code>、<code>rsi</code>、<code>rax</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>保存到栈区。为什么是<code>edi</code>呢？因为你的第一个参数为<code>int</code>，而非<code>int64_t</code>。</p><p>继续往下走，<code>test %al,%al</code> 其行为类似and（<code>TEST %SRC, %DEST</code> 目的寄存器与源寄存器进行<strong>逻辑与</strong>操作，其结果不更新目的寄存器），<code>je</code> 如果等于0，跳转。</p><p>继续往下走，<code>FS:0x28</code>在 Linux 上存储一个特殊的哨兵堆栈保护值，并且代码正在执行堆栈保护检查。</p><p>==FS:0x28 之下与 ud2 之前代码未分析。（留个坑）==</p><p>然后后面 执行ud2，UD2是一种让CPU产生invalid opcode exception的软件指令. 内核发现CPU出现这个异常, 会立即停止运行。此时就Core Dumped.</p><p>以上猜测错误。</p><p>**==其实是c99标准中的默认参数提升==**，具体标准如下。</p><p><a href="http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf">C99标准</a> 6.5.2.2  函数调用 6、7、8节</p><blockquote><p>6 If the expression that denotes the called function has a type that does not include a prototype, the integer promotions are performed on each argument, and arguments that have type float are promoted to double. These are called the default argument promotions. If the number of arguments does not equal the number of parameters, the behavior is undefined. If the function is defined with a type that includes a prototype, and either the prototype ends with an ellipsis (, …) or the types of the arguments after promotion are not compatible with the types of the parameters, the behavior is undefined. If the function is defined with a type that does not include a prototype, and the types of the arguments after promotion are not compatible with those of the parameters after promotion, the behavior is undefined, except for the following cases:</p><p>​    — one promoted type is a signed integer type, the other promoted type is the corresponding unsigned integer type, and the value is representable in both types; </p><p>​    — both types are pointers to qualified or unqualified versions of a character type or void. </p><p>7 If the expression that denotes the called function has a type that does include a prototype, the arguments are implicitly converted, as if by assignment, to the types of the corresponding parameters, taking the type of each parameter to be the unqualified version of its declared type. The ellipsis notation in a function prototype declarator causes argument type conversion to stop after the last declared parameter. The default argument promotions are performed on trailing arguments. </p><p>8 No other conversions are performed implicitly; in particular, the number and types of arguments are not compared with those of the parameters in a function definition that does not include a function prototype declarator</p></blockquote><blockquote><p>6如果表示被调用函数的表达式具有不包含原型的类型，则对每个参数执行整数提升，并将具有float类型的参数提升为double。这些被称为默认参数提升。如果参数的数量不等于参数的数量，则行为是未定义的。如果函数是用包含原型的类型定义的，并且原型以省略号（，…）结尾或者升级后的参数类型与参数类型不兼容，行为未定义。如果函数定义的类型不包括原型，且升级后参数的类型与升级后参数的类型不兼容，则行为未定义，但以下情况除外：</p><ul><li>一个升级类型是有符号整数类型，另一个升级类型是相应的无符号整数类型，值在两种类型中都可以表示；</li><li>这两种类型都是指向字符类型或void的限定或非限定版本的指针。</li></ul><p>7 如果表示被调用函数的表达式的类型确实包含原型，则参数会像赋值一样隐式转换为相应参数的类型，将每个参数的类型视为其声明类型的非限定版本。函数原型声明器中的省略号表示法会导致参数类型转换在最后一个声明的参数之后停止。默认参数升级是在后续参数上执行的。</p><p>8 没有隐式执行其他转换；特别是，参数的数量和类型不会与不包含函数原型声明器的函数定义中的参数进行比较</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/1255775/default-argument-promotions-in-c-function-calls">https://stackoverflow.com/questions/1255775/default-argument-promotions-in-c-function-calls</a></p><p><a href="https://blog.csdn.net/astrotycoon/article/details/8284501">https://blog.csdn.net/astrotycoon/article/details/8284501</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> coredumped </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Vmware上使用archlinux安装open-vm-tools</title>
      <link href="/posts/b9ab4680"/>
      <url>/posts/b9ab4680</url>
      
        <content type="html"><![CDATA[<h2 id="如何在Archlinux安装open-vm-tools软件"><a href="#如何在Archlinux安装open-vm-tools软件" class="headerlink" title="如何在Archlinux安装open-vm-tools软件"></a>如何在Archlinux安装open-vm-tools软件</h2><h3 id="安装软件主体"><a href="#安装软件主体" class="headerlink" title="安装软件主体"></a>安装软件主体</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S open-vm-tools</span><br></pre></td></tr></tbody></table></figure><p>然后安装软件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S base-devel net-tools linux-headers asp wget sudo</span><br></pre></td></tr></tbody></table></figure><h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><p>为虚拟机配置时间同步很重要，因为虚拟机比物理机更容易出现时间波动现象。主要原因就在于 CPU 是被共用的。</p><p>有两种方案可以实现实现同步：同步宿主机时间或者用NTP服务。</p><p>与宿主机同步时间<br>保证 vmtoolsd.service 服务处于运行状态<code>systemctl status vmtoolsd.service</code>，然后用如下的命令启用时间同步功能：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vmware-toolbox-cmd timesync enable</span><br></pre></td></tr></tbody></table></figure><p>宿主系统休眠后，用如下的命令来使客机间同步时间：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --hctosys --localtime</span><br></pre></td></tr></tbody></table></figure><h3 id="窗口分辨率自动适配"><a href="#窗口分辨率自动适配" class="headerlink" title="窗口分辨率自动适配"></a>窗口分辨率自动适配</h3><p>当你拖动Vmware窗口后，Arch会随主窗口的大小来调整分辨率。</p><h4 id="开启3D加速"><a href="#开启3D加速" class="headerlink" title="开启3D加速"></a>开启3D加速</h4><p>VMware 软件：设置 - 显示器 - 选择合适的显存 - 开启加速3D图形</p><h4 id="确认VMware的查看-自动调整大小-自动适应客户机-选择上"><a href="#确认VMware的查看-自动调整大小-自动适应客户机-选择上" class="headerlink" title="确认VMware的查看 - 自动调整大小 - 自动适应客户机 选择上"></a>确认VMware的查看 - 自动调整大小 - 自动适应客户机 选择上</h4><h4 id="安装xf86-video-vmware"><a href="#安装xf86-video-vmware" class="headerlink" title="安装xf86-video-vmware"></a>安装xf86-video-vmware</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xf86-video-vmware</span><br></pre></td></tr></tbody></table></figure><h4 id="安装gtkmm和gtk2"><a href="#安装gtkmm和gtk2" class="headerlink" title="安装gtkmm和gtk2"></a>安装gtkmm和gtk2</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S gtkmm gtk2</span><br></pre></td></tr></tbody></table></figure><h4 id="添加相关模块"><a href="#添加相关模块" class="headerlink" title="添加相关模块"></a>添加相关模块</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mkinitcpio.conf</span><br><span class="line">MODULES=(vsock vmw_vsock_vmci_transport vmw_balloon vmw_vmci vmwgfx)</span><br><span class="line"># :wq 保存退出 </span><br></pre></td></tr></tbody></table></figure><p>然后执行</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkinitcpio -p linux</span><br></pre></td></tr></tbody></table></figure><h4 id="启动vmtoolsd-service"><a href="#启动vmtoolsd-service" class="headerlink" title="启动vmtoolsd.service"></a>启动<code>vmtoolsd.service</code></h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start vmtoolsd.service</span><br><span class="line">sudo systemctl enable vmtoolsd.service</span><br></pre></td></tr></tbody></table></figure><p>重启就可以了</p><h3 id="拖拽复制粘贴"><a href="#拖拽复制粘贴" class="headerlink" title="拖拽复制粘贴"></a>拖拽复制粘贴</h3><p>open-vm-tools缺少gtkmm，因此无法复制粘贴，手动安装即可。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S gtkmm</span><br></pre></td></tr></tbody></table></figure><p>参考：<br><a href="https://www.wnark.com/go/aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1ZNd2FyZS9JbnN0YWxsX0FyY2hfTGludXhfYXNfYV9ndWVzdA==">VMware/Install Arch Linux as a guest</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156"/>
      <url>/posts/4a17b156</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
