<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在Vmware上使用archlinux安装open-vm-tools</title>
      <link href="/posts/2/"/>
      <url>/posts/2/</url>
      
        <content type="html"><![CDATA[<h2 id="如何在Archlinux安装open-vm-tools软件"><a href="#如何在Archlinux安装open-vm-tools软件" class="headerlink" title="如何在Archlinux安装open-vm-tools软件"></a>如何在Archlinux安装open-vm-tools软件</h2><h3 id="安装软件主体"><a href="#安装软件主体" class="headerlink" title="安装软件主体"></a>安装软件主体</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S open-vm-tools</span><br></pre></td></tr></tbody></table></figure><p>然后安装软件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S base-devel net-tools linux-headers asp wget sudo</span><br></pre></td></tr></tbody></table></figure><h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><p>为虚拟机配置时间同步很重要，因为虚拟机比物理机更容易出现时间波动现象。主要原因就在于 CPU 是被共用的。</p><p>有两种方案可以实现实现同步：同步宿主机时间或者用NTP服务。</p><p>与宿主机同步时间<br>保证 vmtoolsd.service 服务处于运行状态<code>systemctl status vmtoolsd.service</code>，然后用如下的命令启用时间同步功能：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vmware-toolbox-cmd timesync enable</span><br></pre></td></tr></tbody></table></figure><p>宿主系统休眠后，用如下的命令来使客机间同步时间：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --hctosys --localtime</span><br></pre></td></tr></tbody></table></figure><h3 id="窗口分辨率自动适配"><a href="#窗口分辨率自动适配" class="headerlink" title="窗口分辨率自动适配"></a>窗口分辨率自动适配</h3><p>我主要是为了这个功能，所以才折腾的。<br>自动适配的意思是，当你在宿主机里缩放 VMware 窗口之后，Arch 作为客户机系统，应该自动根据主系统窗口的新尺寸来调整分辨率。</p><h4 id="1-开启3D加速"><a href="#1-开启3D加速" class="headerlink" title="1.开启3D加速"></a>1.开启3D加速</h4><p>VMware Worksation 的这一设置位于：设置 - 显示器 - 选择合适的显存 - 开启加速3D图形</p><p>不要开启缩放</p><h4 id="2-确认VMware的查看-自动调整大小-自动适应客户机-选择上"><a href="#2-确认VMware的查看-自动调整大小-自动适应客户机-选择上" class="headerlink" title="2.确认VMware的查看 - 自动调整大小 - 自动适应客户机 选择上"></a>2.确认VMware的查看 - 自动调整大小 - 自动适应客户机 选择上</h4><h4 id="3-安装xf86-video-vmware"><a href="#3-安装xf86-video-vmware" class="headerlink" title="3.安装xf86-video-vmware"></a>3.安装xf86-video-vmware</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xf86-video-vmware</span><br></pre></td></tr></tbody></table></figure><h4 id="4-安装gtkmm和gtk2"><a href="#4-安装gtkmm和gtk2" class="headerlink" title="4.安装gtkmm和gtk2"></a>4.安装gtkmm和gtk2</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S gtkmm gtk2</span><br></pre></td></tr></tbody></table></figure><h4 id="5-添加相关模块"><a href="#5-添加相关模块" class="headerlink" title="5.添加相关模块"></a>5.添加相关模块</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mkinitcpio.conf</span><br><span class="line">MODULES=(vsock vmw_vsock_vmci_transport vmw_balloon vmw_vmci vmwgfx)</span><br></pre></td></tr></tbody></table></figure><p>然后执行</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkinitcpio -p linux</span><br></pre></td></tr></tbody></table></figure><h4 id="6-启动vmtoolsd-service"><a href="#6-启动vmtoolsd-service" class="headerlink" title="6.启动vmtoolsd.service"></a>6.启动<code>vmtoolsd.service</code></h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start vmtoolsd.service</span><br><span class="line">sudo systemctl enable vmtoolsd.service</span><br></pre></td></tr></tbody></table></figure><p>重启，完事<br>官方文档还需要安装一些其他的东西，但我就安装这个就可以了</p><h3 id="拖拽复制粘贴"><a href="#拖拽复制粘贴" class="headerlink" title="拖拽复制粘贴"></a>拖拽复制粘贴</h3><p>open-vm-tools缺少gtkmm，因此无法复制粘贴，手动安装即可。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S gtkmm</span><br></pre></td></tr></tbody></table></figure><hr><p>在GitHub上有自动化安装的项目，但已经很久没更新了，因此我就不写在这里面了。</p><hr><p>参考：<br><a href="https://www.wnark.com/go/aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1ZNd2FyZS9JbnN0YWxsX0FyY2hfTGludXhfYXNfYV9ndWVzdA==">VMware/Install Arch Linux as a guest</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vmware </tag>
            
            <tag> archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makeos (未完待续)</title>
      <link href="/posts/2/"/>
      <url>/posts/2/</url>
      
        <content type="html"><![CDATA[<h1 id="如何制作一个OS"><a href="#如何制作一个OS" class="headerlink" title="如何制作一个OS"></a>如何制作一个OS</h1><p><strong>我主张的学习方法就是先学习一个新事物的基础框架和基本的模式结构，而旁枝末节的细节问题完全可以交给实践去慢慢掌握。暂时用不到的东西就不要告诉读者，完全可以用到了再慢慢补充。同时以任务和实践的方式驱动学习过程，既提升了理论学习的速度，又充满了实践的乐趣和成就感。</strong></p><p><a href="http://wiki.0xffffff.org/posts/hurlex-kernel.html">0.x86架构的内核Demo实现</a></p><p><a href="http://wiki.0xffffff.org/posts/hurlex-1.html">1.项目概述和开发环境配置</a></p><p><a href="http://wiki.0xffffff.org/posts/hurlex-2.html">2.计算机启动过程、GURB以及multiboot标准</a></p><p><a href="http://wiki.0xffffff.org/posts/hurlex-3.html">３.裸机上运行的Hello OS Kernel</a></p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><img src="https://gitee.com/glj0/imgur/raw/master/photo/%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%8C%BA%E5%88%AB.png"></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我使用<strong>archlinux 无gui</strong>版本</p><p>需要安装 qemu、qemu-arch-extra、nasm、cgdb、gcc、vim等</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S qemu qemu-arch-extra</span><br><span class="line">sudo pacman -S nasm cgdb gcc </span><br><span class="line">sudo pacman -S vim </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装qemu结束后创建软链</span></span><br><span class="line">sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</span><br></pre></td></tr></tbody></table></figure><p>配置以上就够使用了，可以通过vscode直接ssg访问archlinux（注意新安装archlinux 需要安装 openssh）</p><h2 id="计算机启动过程、GRUB和multiboot标准"><a href="#计算机启动过程、GRUB和multiboot标准" class="headerlink" title="计算机启动过程、GRUB和multiboot标准"></a>计算机启动过程、GRUB和multiboot标准</h2><p>GRUB全称 GRand Unified Bootloader，是一个多重操作系统启动管理器，可以用来引导不同的操作系统。</p><p>可以通过阮一峰博客的文章了解一下整体的大概启动思路<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的-阮一峰</a></p><p>目标内核32位，使用32位地址总线来寻址，所以能编址出2的32次方，也就是4G的地址空间。那么引出第一个问题，<strong>这4G的空间指向哪</strong>？说到这里，引出两个专业名词：端口统一编址和端口独立编址。端口统一编址把所有和外设存储单元对应的端口直接编址在4G的地址空间里，当我们对某一个地址进行访问实际上是在访问某个外设的存储单元。</p><p>而端口独立编址就是说这些端口没有编址在地址空间里，而是另行独立编址。而x86架构部分采用端口独立编址，部分采用端口统一编址。</p><p>CPU在加电后的启动过程：从按下电源开始，CPU重置。主板加电之后在电压尚未稳定之前，主机上的北桥控制芯片向CPU发出重置信号（Reset），此时CPU进行初始化。电压稳定后，控制芯片撤销Reset信号，CPU开始模块化工作。此时形成第一条指令的地址为0xFFFFFFF0 ，从这里开始，CPU进入“取址-翻译-执行”的循环。这个地址指向BIOS芯片中（在4G的地址空间里，有一些地址是分给外设的，这个地址便是映射BIOS的）。</p><p>接着BIOS的POST（Power On Self Test，上电自检），BIOS对计算机各个部件开始初始化，如有错误给出报警音。当BIOS完成这些工作之后，任务是在外部存储设备中寻找操作系统，最常见的外村便是各种硬盘。BIOS根据设备启动表列出的顺序查找可启动设备。什么是可启动设备呢？规则很简单，在这个存储设备的第一个扇区中512字节的最后两个字节为0x55和0xAA，那么改存储设备就是可启动的。所以BIOS会对列表中的设备注意检测，只要有一个设备满足要求，后续的设备将不再测试。</p><p>当BIOS找到可启动的设备后，便将该设备的第一个扇区加载到内存的0x7C00地址处，并且跳转过去执行。</p><p>因为一个扇区只有521字节，所以常规的做法是写 载入操作系统内核的代码，这段代码就是bootloader。</p><p>如何让GRUB加载我们自己的小内核呢？答案是GRUB提供的multi boot规范。这个规范描述如何构造出一个能被GRUB识别，并且按照我们定义的规则去加载的操作系统内核。</p><h2 id="裸机上运行的-Hello-OS-Kernel"><a href="#裸机上运行的-Hello-OS-Kernel" class="headerlink" title="裸机上运行的 Hello OS Kernel"></a>裸机上运行的 Hello OS Kernel</h2><h3 id="Makefile和ld脚本的简单解释"><a href="#Makefile和ld脚本的简单解释" class="headerlink" title="Makefile和ld脚本的简单解释"></a>Makefile和ld脚本的简单解释</h3><p>首先看Makefile中关于gcc编译参数的这一行：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I include</span><br></pre></td></tr></tbody></table></figure><p>几个参数说明：</p><ul><li>-m32 生成32位代码，加此参数后可以在64位Linux系统上编译</li><li>-ggdb 和 -gstabs+ 是添加相关的调试信息</li><li>-nostdinc 不包含C语言的标准库的头文件</li><li>-fno-builtin 要求gcc不适用自己的内建函数，除非显式声明</li><li>-fno-stack-protector 不适用栈保护等检测</li></ul><p>ld链接命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_FLAGS = -T scripts/kernel.ld -m elf_i386 -nostdlib</span><br></pre></td></tr></tbody></table></figure><ul><li>-T scripts/kernel.ld 使用我们自己的链接器脚本</li><li>-m elf_i386 生成i386平台下的ELF格式的可执行文件</li><li>-nostdlib 不链接c语言的标准库</li></ul><p>接下来讨论链接器脚本。</p><p>我们知道一个可执行文件大致有代码段和数据段组成，但是操作系统怎么加载它呢？事实上可执行文件有义务向操作系统提供代码段和数据段位置等信息，以便操作系统正确找到它的代码段和数据段并加载执行。通常这个信息被统一组织放置在可执行文件的头部区域。</p><p>ld支持多种可执行文件格式，为什么选择elf呢？因为GRUB可以检测识别出ELF格式的可执行文件，并且能找到相关的代码段和数据段的位置信息，从而正确的把我们的内核加载到正确的位置上去。</p><h3 id="启动镜像的制作"><a href="#启动镜像的制作" class="headerlink" title="启动镜像的制作"></a>启动镜像的制作</h3><p>解决了理论的问题，来解决一个实际的问题。这个小内核放在哪里？虚拟机是它的运行场所，那么虚拟磁盘自然就是放内核的地方了。我们此次实验不选择磁盘，选择已经消失殆尽的1.44MB的软盘。为什么？因为简单。</p><p>在Linux下制作一个1.44MB的软件太简单了，使用dd命令即可。</p><p>不过在软盘镜像上安装GRUB稍有难度，所以直接使用已经做好的。</p><p>引入一个新名词–文件系统，什么是文件系统呢？文件系统指的是用于明确磁盘或分区上的文件存储的方法和数据结构，即在磁盘上组织文件的方法。</p><p>软盘一般使用FAT12文件系统。</p><h3 id="内核的入口和初始化"><a href="#内核的入口和初始化" class="headerlink" title="内核的入口和初始化"></a>内核的入口和初始化</h3><p>代码是从什么函数开始执行呢？</p><p>ld链接脚本中的一行文字：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(start)</span><br></pre></td></tr></tbody></table></figure><p>告诉我们ld链接器入口函数是start，所以代码从start函数开始。</p><p>接着看一下入口函数：</p><p>在boot/boot.s中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">; ----------------------------------------------------------------</span><br><span class="line">;</span><br><span class="line">; boot.s -- 内核从这里开始</span><br><span class="line">;</span><br><span class="line">;                 这里还有根据 GRUB Multiboot 规范的一些定义</span><br><span class="line">;</span><br><span class="line">; ----------------------------------------------------------------</span><br><span class="line">; Intel 汇编语法</span><br><span class="line">MBOOT_HEADER_MAGIC equ 0x1BADB002 ; Multiboot 魔数，由规范决定的</span><br><span class="line"></span><br><span class="line">MBOOT_PAGE_ALIGN equ 1 &lt;&lt; 0    ; 0 号位表示所有的引导模块将按页(4KB)边界对齐</span><br><span class="line">MBOOT_MEM_INFO equ 1 &lt;&lt; 1    ; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息</span><br><span class="line"> ; (告诉GRUB把内存空间的信息包含在Multiboot信息结构中)</span><br><span class="line"></span><br><span class="line">; 定义我们使用的 Multiboot 的标记</span><br><span class="line">MBOOT_HEADER_FLAGS equ MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO</span><br><span class="line"></span><br><span class="line">; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)相加时，</span><br><span class="line">; 要求其结果必须是32位的无符号值 0 (即magic + flags + checksum = 0)</span><br><span class="line">MBOOT_CHECKSUM equ - (MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)</span><br><span class="line"></span><br><span class="line">; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头</span><br><span class="line"></span><br><span class="line">; Multiboot 头的分布必须如下表所示：</span><br><span class="line">; ----------------------------------------------------------</span><br><span class="line">; 偏移量  类型  域名        备注</span><br><span class="line">;</span><br><span class="line">;   0     u32   magic       必需</span><br><span class="line">;   4     u32   flags       必需 </span><br><span class="line">;   8     u32   checksum    必需 </span><br><span class="line">;</span><br><span class="line">; 我们只使用到这些就够了，更多的详细说明请参阅 GNU 相关文档</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">[BITS 32]  ; 所有代码以 32-bit 的方式编译</span><br><span class="line"></span><br><span class="line">section .text ; 代码段从这里开始</span><br><span class="line"></span><br><span class="line">; 在代码段的起始位置设置符合 Multiboot 规范的标记</span><br><span class="line"></span><br><span class="line">dd MBOOT_HEADER_MAGIC ; GRUB 会通过这个魔数判断该映像是否支持</span><br><span class="line">dd MBOOT_HEADER_FLAGS   ; GRUB 的一些加载时选项，其详细注释在定义处</span><br><span class="line">dd MBOOT_CHECKSUM       ; 检测数值，其含义在定义处</span><br><span class="line"></span><br><span class="line">[GLOBAL start] ; 内核代码入口，此处提供该声明给 ld 链接器</span><br><span class="line">[GLOBAL glb_mboot_ptr] ; 全局的 struct multiboot * 变量</span><br><span class="line">[EXTERN kern_entry] ; 声明内核 C 代码的入口函数</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">cli   ; 此时还没有设置好保护模式的中断处理，要关闭中断</span><br><span class="line"> ; 所以必须关闭中断</span><br><span class="line">mov esp, STACK_TOP   ; 设置内核栈地址</span><br><span class="line">mov ebp, 0  ; 帧指针修改为 0</span><br><span class="line">and esp, 0FFFFFFF0H ; 栈地址按照16字节对齐</span><br><span class="line">mov [glb_mboot_ptr], ebx ; 将 ebx 中存储的指针存入全局变量</span><br><span class="line">call kern_entry ; 调用内核入口函数</span><br><span class="line">stop:</span><br><span class="line">hlt  ; 停机指令，什么也不做，可以降低 CPU 功耗</span><br><span class="line">jmp stop  ; 到这里结束，关机什么的后面再说</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">section .bss  ; 未初始化的数据段从这里开始</span><br><span class="line">stack:</span><br><span class="line">resb 32768   ; 这里作为内核栈</span><br><span class="line">glb_mboot_ptr:  ; 全局的 multiboot 结构体指针</span><br><span class="line">resb 4</span><br><span class="line"></span><br><span class="line">STACK_TOP equ $-stack-1  ; 内核栈顶，$ 符指代是当前地址</span><br><span class="line"></span><br><span class="line">;-----------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>首先是一些宏定义，定义了Multiboot标准的魔数和几个标识，GRUB读取这些信息判断我们的意图。真正的代码是从39行以后开始<code>section .text</code></p><p>前面为定义Multiboot头，其格式如下</p><table><thead><tr><th>偏移量</th><th>类型</th><th>域名</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>u32</td><td>magic</td><td>必需</td></tr><tr><td>4</td><td>u32</td><td>flags</td><td>必需</td></tr><tr><td>8</td><td>u32</td><td>checksum</td><td>必需</td></tr></tbody></table><p>checksum域需满足条件<br>$$<br> magic + flags + checksum = 0<br>$$<br>也即<br>$$<br>checksum = - (magic + flags)<br>$$<br>通过这几个关键字告诉GRUB我们要求它提供可用内存的信息，而且要求所有内核中的段在内存里按照4KB进行对齐。紧接着就是入口函数start了，入口函数很短，主要是关闭终端，传参数（按照协议，GRUB把一些计算机硬件和我们内核相关的信息放在一个结构体中，并且将这个结构体指针放在ebx中），并且调用内核的入口函数。</p><p>下面就进入到c语言的世界了。</p><p>init/init.c下的kern_entry</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kern_entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后我再列出当GRUB载入我们的内核时，CPU的一些状态信息:<a href="http://wiki.0xffffff.org/posts/hurlex-3.html#fn:17">17</a></p><ol><li>CS 指向基地址为 0x00000000，限长为4G – 1的代码段描述符。</li><li>DS，SS，ES，FS 和 GS 指向基地址为0x00000000，限长为4G–1的数据段描述符。</li><li>A20 地址线已经打开。</li><li>页机制被禁止。</li><li>中断被禁止。</li><li>EAX = 0x2BADB002</li><li>系统信息和启动信息块的线性地址保存在 EBX中(相当于一个指针)。</li></ol><p>准备好这一切之后，把之前下载的软怕映像放在Makefile文件的同级目录下，直接执行make命令编译源代码，没有意外的话会生成一个hx_kernel的文件，并且自动挂载软盘镜像把这个文件复制进去。</p><p>使用<code>make qemu</code>来运行它。注意我使用archlinux无ui，所以需要在makefile中加上-nographic，但是此时出现一个问题，在终端中并不显示”Hello,OS World!”。原因是使用了-nographic 选项，需要在kernel启动前将重定向到终端，具体看<a href="https://blog.csdn.net/qq_41961459/article/details/119108333" title="加上-nographic后终端无输出">1</a> <a href="https://serverfault.com/questions/471719/how-to-start-qemu-directly-in-the-console-not-in-curses-or-sdl#">2</a>，试了下<a href="https://blog.csdn.net/qq_41961459/article/details/119108333" title="加上-nographic后终端无输出">1</a>、<a href="https://serverfault.com/questions/471719/how-to-start-qemu-directly-in-the-console-not-in-curses-or-sdl#">2</a>中的方案，还是不行，还是给archlinux装个桌面吧[3]，安装桌面后，显示正常。</p><p><img src="https://gitee.com/glj0/imgur/raw/master/photo/20220221195140.png"></p><p>archlinux 安装桌面</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S plasma   #KDE桌面</span><br><span class="line">sudo pacman -S konsole  #终端</span><br><span class="line">sudo pacman -S sddm #桌面管理器</span><br><span class="line">sudo pacman -S dolphin  #文件管理器</span><br><span class="line">sudo systemctl enable sddm #配置桌面自启，重启系统就可以了</span><br></pre></td></tr></tbody></table></figure><p>使用以下命令停止它。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(ps -ef | grep qemu | awk {'print $2'} | head -n 1)</span><br></pre></td></tr></tbody></table></figure><h2 id="字符模式下的显卡驱动"><a href="#字符模式下的显卡驱动" class="headerlink" title="字符模式下的显卡驱动"></a>字符模式下的显卡驱动</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编（狂神聊汇编）(未完待续)</title>
      <link href="/posts/3/"/>
      <url>/posts/3/</url>
      
        <content type="html"><![CDATA[<p>学习思想</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>汇编语言是你的必经之路</p><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>人和人沟通，通过语言来交流。</p><p>学习计算机的语言。</p><p>什么是机器语言？</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们目前主流的电子计算机</span></span><br><span class="line"> 状态：0 和 1 </span><br><span class="line"><span class="comment"># 最早的程序员：穿孔卡带</span></span><br><span class="line">加</span><br><span class="line">减</span><br><span class="line">乘</span><br><span class="line">除</span><br></pre></td></tr></tbody></table></figure><p>这些复杂的机器语言，能简化吗？助记符。汇编语言。人能够理解的语言转为机器能够理解的语言！</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加 INC</span><br><span class="line">减 DEC</span><br><span class="line">乘 MUL</span><br><span class="line">除 DIV</span><br></pre></td></tr></tbody></table></figure><p>C语言</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加 INC</span><br><span class="line">减 DEC</span><br><span class="line">乘 MUL</span><br><span class="line">除 DIV</span><br></pre></td></tr></tbody></table></figure><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h3 id="进制是如何运算的"><a href="#进制是如何运算的" class="headerlink" title="进制是如何运算的"></a>进制是如何运算的</h3><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h3 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h3><h3 id="有符号数和无符号数"><a href="#有符号数和无符号数" class="headerlink" title="有符号数和无符号数"></a>有符号数和无符号数</h3><h3 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h3><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h3 id="位运算计算"><a href="#位运算计算" class="headerlink" title="位运算计算"></a>位运算计算</h3><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h3 id="内存复制"><a href="#内存复制" class="headerlink" title="内存复制"></a>内存复制</h3><h3 id="堆栈的智力高"><a href="#堆栈的智力高" class="headerlink" title="堆栈的智力高"></a>堆栈的智力高</h3><h3 id="汇编如何写函数"><a href="#汇编如何写函数" class="headerlink" title="汇编如何写函数"></a>汇编如何写函数</h3><h3 id="堆栈传参"><a href="#堆栈传参" class="headerlink" title="堆栈传参"></a>堆栈传参</h3><h3 id="堆栈平衡"><a href="#堆栈平衡" class="headerlink" title="堆栈平衡"></a>堆栈平衡</h3><h3 id="外挂"><a href="#外挂" class="headerlink" title="外挂"></a>外挂</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/1/"/>
      <url>/posts/1/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
