<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>u-boot-2014.04 分析（未完待续） | Gong's Blog</title><meta name="author" content="lj gong"><meta name="copyright" content="lj gong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="u-boot-2014.04 分析由于要分析一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。 本文使用的版本是 u-boot-2022.04-rc4.tar.bz2 u-boot-2014.04（因作者能力不够，遂从2014.04开始） s5pv210芯片启动流程由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iROM中，BL">
<meta property="og:type" content="article">
<meta property="og:title" content="u-boot-2014.04 分析（未完待续）">
<meta property="og:url" content="http://gonglja.github.io/posts/f88e6d17/index.html">
<meta property="og:site_name" content="Gong&#39;s Blog">
<meta property="og:description" content="u-boot-2014.04 分析由于要分析一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。 本文使用的版本是 u-boot-2022.04-rc4.tar.bz2 u-boot-2014.04（因作者能力不够，遂从2014.04开始） s5pv210芯片启动流程由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iROM中，BL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png">
<meta property="article:published_time" content="2022-03-29T01:33:08.000Z">
<meta property="article:modified_time" content="2022-04-11T13:59:10.067Z">
<meta property="article:author" content="lj gong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gonglja.github.io/posts/f88e6d17/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'u-boot-2014.04 分析（未完待续）',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-04-11 21:59:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111228921.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://gonglja.github.io/Notes"><i class="fa-fw fas fa-link"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Gong's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://gonglja.github.io/Notes"><i class="fa-fw fas fa-link"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">u-boot-2014.04 分析（未完待续）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-29T01:33:08.000Z" title="发表于 2022-03-29 09:33:08">2022-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-11T13:59:10.067Z" title="更新于 2022-04-11 21:59:10">2022-04-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="u-boot-2014.04 分析（未完待续）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="u-boot-2014-04-分析"><a href="#u-boot-2014-04-分析" class="headerlink" title="u-boot-2014.04 分析"></a>u-boot-2014.04 分析</h1><p>由于要分析一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。</p>
<p>本文使用的版本是 <del><a href="ttps://ftp.denx.de/pub/u-boot/u-boot-2022.04-rc4.tar.bz2">u-boot-2022.04-rc4.tar.bz2</a></del> <a target="_blank" rel="noopener" href="https://github.com/Gonglja/u-boot-smart210">u-boot-2014.04</a>（因作者能力不够，遂从2014.04开始）</p>
<h2 id="s5pv210"><a href="#s5pv210" class="headerlink" title="s5pv210"></a>s5pv210</h2><h3 id="芯片启动流程"><a href="#芯片启动流程" class="headerlink" title="芯片启动流程"></a>芯片启动流程</h3><p>由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iROM中，BL1和BL2运行在SRAM中，但在实际项目中使用的比较通用的启动流程与官方流程有较大差异，为什么呢？因为编译的u-boot过大，超过最大80k限制。所以BL2在SDRAM中运行，而三星官方是放在内部SRAM中运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png"></p>
<h4 id="BL0"><a href="#BL0" class="headerlink" title="BL0"></a>BL0</h4><ul>
<li>运行在iROM上</li>
<li>代码固定在s5pv210的IROM中，无法修改。上电后直接从IROM中开始执行</li>
<li>主要工作<ul>
<li>初始化系统时钟、特殊设备控制器、启动设备、看门狗、SRAM等</li>
<li>验证BL1镜像</li>
<li>从存储介质上（比如SD/eMMC/nand flash）等加载BL1镜像到内部SRAM中</li>
<li>跳转到BL1镜像所在地址</li>
</ul>
</li>
</ul>
<h4 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h4><ul>
<li>运行在SRAM上</li>
<li>BL1代码在BL0段被加载到SRAM中</li>
<li>主要工作<ul>
<li>初始化部分时钟（SDRAM相关）</li>
<li>初始化DDR（外部SDRAM）</li>
<li>从存储介质上将BL2镜像加载到SDRAM中</li>
<li>验证BL2镜像合法性</li>
<li>跳转到BL2镜像所在的地址上</li>
</ul>
</li>
</ul>
<h4 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h4><ul>
<li>运行在SDRAM上</li>
<li>BL2代码在BL1段被加载到SDRAM中</li>
<li>BL2就是传统意义上的bootloader，主要负责加载OS和启动OS</li>
</ul>
<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082025672.png"></p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0x0000_0000</strong></td>
<td><strong>0x1FFF_FFFF</strong></td>
<td><strong>512MB</strong></td>
<td><strong>Boot area（取决于启动模式）</strong></td>
</tr>
<tr>
<td><strong>0x2000_0000</strong></td>
<td><strong>0x3FFF_FFFF</strong></td>
<td><strong>512MB</strong></td>
<td><strong>DRAM 0</strong></td>
</tr>
<tr>
<td><strong>0x4000_0000</strong></td>
<td><strong>0x7FFF_FFFF</strong></td>
<td><strong>1024MB</strong></td>
<td><strong>DRAM 1</strong></td>
</tr>
<tr>
<td>0x8000_0000</td>
<td>0x87FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 0</td>
</tr>
<tr>
<td>0x8800_0000</td>
<td>0x8FFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 1</td>
</tr>
<tr>
<td>0x9000_0000</td>
<td>0x97FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 2</td>
</tr>
<tr>
<td>0x9800_0000</td>
<td>0x9FFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 3</td>
</tr>
<tr>
<td>0xA000_0000</td>
<td>0xA7FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 4</td>
</tr>
<tr>
<td>0xA800_0000</td>
<td>0xAFFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 5</td>
</tr>
<tr>
<td>0xB000_0000</td>
<td>0xBFFF_FFFF</td>
<td>256MB</td>
<td>OneNAND/NAND Controller and SFR</td>
</tr>
<tr>
<td>0xC000_0000</td>
<td>0xCFFF_FFFF</td>
<td>256MB</td>
<td>MP3_SRAM output buffer</td>
</tr>
<tr>
<td><strong>0xD000_0000</strong></td>
<td><strong>0xD000_FFFF</strong></td>
<td><strong>64KB</strong></td>
<td><strong>IROM</strong></td>
</tr>
<tr>
<td>0xD001_0000</td>
<td>0xD001_FFFF</td>
<td>64KB</td>
<td>Reserved</td>
</tr>
<tr>
<td><strong>0xD002_0000</strong></td>
<td><strong>0xD003_7FFF</strong></td>
<td><strong>96KB</strong></td>
<td><strong>IRAM</strong></td>
</tr>
<tr>
<td>0xD800_0000</td>
<td>0xDFFF_FFFF</td>
<td>128MB</td>
<td>DMZ ROM</td>
</tr>
<tr>
<td>0xE000_0000</td>
<td>0xFFFF_FFFF</td>
<td>512MB</td>
<td>SFR region</td>
</tr>
</tbody></table>
<p>s5pv210芯片上电之后，CPU会直接从0x0地址取指令，也就是直接运行BL0。</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x0000_0000</td>
<td>0x0000_FFFF</td>
<td>64KB</td>
<td>Internal ROM</td>
</tr>
</tbody></table>
<p>BL1运行在IRAM中，IRAM空间如下</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0xD002_0000</td>
<td>0xD003_7FFF</td>
<td>96KB</td>
<td>IRAM</td>
</tr>
</tbody></table>
<p>但需注意：BL1运行在IRAM上，但并不意味着就从0xD002_0000开始。其实0xD002_0000开头的16B被用做BL1的header，BL1真正是从<strong>0xD002_0010</strong>开始运行的。前16字节被用来验证BL1镜像的完整性，其格式如下：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0xD002_0000</td>
<td>BL1镜像包括header的长度</td>
</tr>
<tr>
<td>0xD002_0004</td>
<td>保留，设置为0</td>
</tr>
<tr>
<td>0xD002_0008</td>
<td>BL1镜像除去header的校验和</td>
</tr>
<tr>
<td>0xD002_000c</td>
<td>保留，设置为0</td>
</tr>
</tbody></table>
<p>BL2运行地址在SDRAM中， smart210使用的是DRAM0，所以地址为</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x2000_0000</td>
<td>0x3FFF_FFFF</td>
<td>512MB</td>
<td>DRAM 0</td>
</tr>
</tbody></table>
<h2 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h2><p>由以上可知，上电后首先运行BL0阶段（BL0段代码起始地址为<code>0</code>）。</p>
<p>BL0 阶段运行的代码为IROM中自带的，其主要功能为 初始化系统时钟、特殊设备控制器、启动设备、看门狗、SRAM等，验证BL1镜像是否完整（<code>0xD002_0000</code>处存在长度和校验）然后跳转到BL1处（<code>0xD002_0010</code>）执行。</p>
<p>BL1 阶段运行在IRAM中，其主要功能是初始化部分时钟和DDR，拷贝BL2段代码到SDRAM中，验证BL2并跳转执行。</p>
<blockquote>
<p>那么，BL1段代码是怎么被拷贝到SRAM中的？</p>
<p>答：在BL0段将BL1的代码拷贝到SRAM中（参考<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code> 中 <code>2.2 iROM(BL0) boot-up sequence (Refer 2.3 V210 boot-up diagram)</code>），由于BL0三星不开源，所以我我们只能按照三星的要求存放BL1的位置（参考<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code> 中<code>2.8 Boot Block Assignment Guide</code>），如果从SD卡启动，也即从SD卡的第<code>1</code>个块开始；如果从NAND Flash启动，就放到Flash中的<code>0</code>块处。拷贝多少呢？这个不知道，有人说是<code>16k</code>也有人说是<code>8k</code>，尽可能将BL1的代码控制在<code>8K</code>以内。</p>
</blockquote>
<p>BL2 阶段运行在SDRAM中，就是传统意义上的bootloader，主要负责加载OS和启动OS</p>
<p>u-boot代码中有两部分：u-boot-spl、u-boot，其中u-boot-spl与芯片启动流程中的BL1对应、u-boot与BL2对应。</p>
<p>那么问题来了，u-boot-spl是如何生成的？u-boot又是怎么生成的?</p>
<p>spl的编译时编译uboot的一部分，和uboot.bin走的是两条编译流程。</p>
<p>一般来说，会先编译主体uboot，也就是uboot.bin，在编译uboot-spl，也就是uboot-spl.bin，两个流程。</p>
<p>编译成功后有几个文件名需要注意下，</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>u-boot-spl</td>
<td>初步链接后得到的spl文件</td>
</tr>
<tr>
<td>u-boot-spl-nodtb.bin</td>
<td>在u-boot-spl的基础上，经过objcopy去除符号表信息之后的可执行程序</td>
</tr>
<tr>
<td>u-boot-spl.bin</td>
<td>在不需要dtb的情况下，直接由u-boot-spl-nodtb.bin复制而来，也就是编译spl的最终目标</td>
</tr>
<tr>
<td>smart210-spl.bin</td>
<td>由s5pv210平台决定，需要在u-boot-spl.bin的基础上加上16B的header用作校验</td>
</tr>
<tr>
<td>u-boot-spl.lds</td>
<td>spl的连接脚本</td>
</tr>
<tr>
<td>u-boot-spl.map</td>
<td>连接之后的符号表文件</td>
</tr>
<tr>
<td>u-boot-spl.cfg</td>
<td>由spl配置生成的文件</td>
</tr>
</tbody></table>
<p><strong>框架</strong></p>
<blockquote>
<p>一般情况下，u-boot采用”board–&gt;machine–&gt;arch–&gt;cpu”框架，如图：</p>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201605/29bd3da4b061810a74093c33d3292b4320160519144243.gif"></p>
</blockquote>
<blockquote>
<p>基于这个架构，u-boot和平台有关的初始化流程就很清晰了。</p>
<ol>
<li>u-boot 启动后，会先执行CPU（如armv8）的初始化代码</li>
<li>CPU相关的代码， 会调用ARCH的公共代码（如arch/arm）</li>
<li>ARCH的公共代码，在适当的时候，调用board有关的接口。u-boot的功能逻辑，大多是由common代码实现，部分和平台有关的部分，则由公共代码声明，由board代码实现。</li>
<li>board代码在需要的时候，会调用machine(arch/arm/mach-xxx)提供的接口，实现特定的功能。因此machine的定位是提供一些基础的代码支持，不会直接参与到u-boot的逻辑功能中去。</li>
</ol>
</blockquote>
<p>由此可知，当u-boot上电后，首先执行的是CPU的初始化代码。板卡型号为smart210，CPU型号为s5pv210，armv7指令集。</p>
<p>通过 <code>u-boot-spl.lds</code>（<code>arch/arm/cpu/u-boot-spl.lds</code>） 和 <code>u-boot.lds</code>（arch/arm/cpu/u-boot.lds） 中 <code>ENTRY(_start)</code>可知，不管是u-boot-spl还是u-boot都是从<code>_start</code>开始的。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先解决编译问题，其次是分析代码，在分析代码的过程中遇到不会的指令和寄存器及时记录下来，防止下次还是不会。</p>
<h3 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h3><h4 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h4><p>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</p>
<p>dirname: missing operand</p>
<p>具体如下</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">glj0@glj0-ubuntu21:~/worksapce/os/smart210/u-boot-2014.04$ ./make.sh </span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">Configuring <span class="keyword">for</span> smart210 board...</span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">  GEN     include/autoconf.mk.dep</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">  GEN     include/autoconf.mk</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">  CHK     include/config/uboot.release</span><br><span class="line">  CHK     include/generated/timestamp_autogenerated.h</span><br><span class="line">  UPD     include/generated/timestamp_autogenerated.h</span><br><span class="line">  UPD     include/config/uboot.release</span><br><span class="line">  HOSTCC  scripts/basic/fixdep</span><br><span class="line">  CHK     include/generated/version_autogenerated.h</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-ld: not found</span><br><span class="line">  UPD     include/generated/version_autogenerated.h</span><br><span class="line">  CC      lib/asm-offsets.s</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">make[1]: *** [/home/glj0/worksapce/os/smart210/u-boot-2014.04/./Kbuild:35: lib/asm-offsets.s] Error 127</span><br><span class="line">make[1]: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>....</span><br><span class="line">  CC      arch/arm/lib/asm-offsets.s</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">make[1]: *** [/home/glj0/worksapce/os/smart210/u-boot-2014.04/./Kbuild:84: arch/arm/lib/asm-offsets.s] Error 127</span><br><span class="line">make: *** [Makefile:999: prepare0] Error 2</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>缺少32位库，安装就可以了。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgl1-mesa-dri:i386</span><br></pre></td></tr></tbody></table></figure>



<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><strong>TODO：待补充</strong></p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r0</td>
<td></td>
</tr>
<tr>
<td>r1</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>pc</td>
<td>程序寄存器，保留下一条CPU即将执行的指令</td>
</tr>
<tr>
<td>lr</td>
<td>连接返回寄存器，保留函数返回后，下一条应执行的指令</td>
</tr>
</tbody></table>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><strong>TODO：待补充</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>指令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>条件（有符号数）</td>
<td>GE</td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LE</td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>GT</td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LT</td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td>条件（用于无符号数）</td>
<td>HS</td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LS</td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HI</td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LO</td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>STR{条件} 源寄存器，&lt;存储器地址&gt;</td>
<td>从源寄存器中将一个32位的字数据传送到存储器中</td>
<td><code>STR r1, [r0]</code>将r1里面值复制到以r0里面的值作为地址的内存中</td>
</tr>
<tr>
<td></td>
<td>STRLO 源寄存器，&lt;存储器地址&gt;</td>
<td>当满足条件小于时，从源寄存器中将一个32位的字数据传送到存储器中</td>
<td><code>CMP r0，r1;STRLO r2，[r0];</code> 首先r0=r0-r1,当满足条件r0&lt;r1时，将r2中的值复制到以r0里面的值作为地址的内存中。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>地址读取伪指令</td>
<td>ADR{条件}目的寄存器，相对地址或标签</td>
<td>将基于PC相对偏移的地址值或基于寄存器相对地址值传送到目的寄存器中（小范围）</td>
<td><code>ADR r0, here;here: ....</code>将标签here处的相对地址传递给寄存器r0</td>
</tr>
<tr>
<td></td>
<td>LDR{条件}目的寄存器，&lt;存储器地址&gt;</td>
<td>从存储器中将一个32位的字数据传送到目的寄存器中（大范围）</td>
<td><code>LDR r0, [r1]</code>将r1里面的值作为地址，将地址里面的值复制给寄存器r0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>跳转指令</td>
<td>B{条件} 目标地址</td>
<td>跳转指令</td>
<td><code>B Label</code>程序无条件跳转到标号Label处执行</td>
</tr>
<tr>
<td></td>
<td>BL{条件} 目标地址</td>
<td>带返回的跳转指令（跳转之前，将PC内容存到R14中）</td>
<td><code>BL Label</code>程序将当前PC值存到R14中，程序无条件跳转至标号Label中执行</td>
</tr>
<tr>
<td></td>
<td>BLX</td>
<td>带返回和状态切换的跳转指令</td>
<td></td>
</tr>
<tr>
<td></td>
<td>BX</td>
<td>带状态切换的跳转指令</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>CMP 寄存器1，寄存器2</td>
<td>寄存器1=寄存器1-寄存器2</td>
<td><code>CMP r0，r1</code> 也就是<code>r0=r0-r1</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>.globl</td>
<td>伪指令，声明一个全局变量</td>
<td><code>.globl _start</code>声明_start，下面调用时才不会出现链接错误。类似c语言中的extern。</td>
</tr>
</tbody></table>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="2022中的-start不看"><a href="#2022中的-start不看" class="headerlink" title="2022中的_start不看"></a><strong><del>2022中的_start不看</del></strong></h4><p><del>所以首先会执行armv7中的start.S代码，但是呢，通过代码，我们没有发现start.S中有 <code>_start</code>相关的定义，而且也没有一些向量表的处理，这就很奇怪了，代码放哪呢了呢？没有<code>_start</code>又要怎么启动呢？带着问题，我们接着往下走。</del></p>
<p>由于我们的代码是最新的，但有印象在2014版本中是有这一部分的，所以我们直接去查找git上这个文件的history</p>
<p>于是有了找到了以下</p>
<p><a target="_blank" rel="noopener" href="https://source.denx.de/u-boot/u-boot/-/commit/41623c91b09a0c865fab41acdaff30f060f29ad6">https://source.denx.de/u-boot/u-boot/-/commit/41623c91b09a0c865fab41acdaff30f060f29ad6</a></p>
<p>在这个链接右上角可以看到，删除了2426行，新增了313行。看了下发现删除的都是 下面这种代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start: b    reset </span><br><span class="line">...</span><br><span class="line">	.balignl 16,0xdeadbeef</span><br></pre></td></tr></tbody></table></figure>

<p>那这些代码去哪了呢？</p>
<p>接着搜索armv7，发现也是这种代码被删除。</p>
<p>接着走，看看新增了什么，在u-boot-spl.lds和u-boot.lds中 代码中新增了一个 *(vectors)并且位置比start.o靠前，什么意思？中断向量表存到这个地方了嘛？是的，接着往下看，一切都会真相大白</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203291016583.png"></p>
<p>终于看到vector.S了，这部分代码是存在 arch/arm/lib下，有没有发现很熟悉，没错，就是上面删掉的代码，而且 <code>.global _start</code>也在这，由此可以猜测，<strong>开发人员将各个处理器的公共代码抽离，最终以vector.S体现</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203291030263.png"></p>
<p>借助 u-boot.lds（arch/arm/cpu/u-boot.lds）可知，<code>ENTRY(_start)</code>，整个u-boot的开始依然是<code>_start</code>，由以上分析可知，<code>_start</code>在vectors.S中定义，所以整个U-boot的入口为vector.S中的<code>_start</code>，接着 ARM_VECTORS 是一个宏，展开就是 <code>.macro/.endm</code>之间包裹的。接着往下走，就会走入<code>b reset</code>，调用reset。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* arch/arm/lib/vectors.S */</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">	.section ".vectors", "ax"</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)</span><br><span class="line">#include &lt;asm/arch/boot0.h&gt;</span><br><span class="line">#else   /*走这个分支 (怎么确认的呢？在此处随便加个乱七八糟的字符，然后编译，如果编译过，则说明走的不是此分支)*/</span><br><span class="line">_start: /*U-boot程序入口*/</span><br><span class="line">#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">	.word	CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">#endif</span><br><span class="line">	ARM_VECTORS /* 一个宏*/</span><br><span class="line">#endif /* !defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) */</span><br><span class="line">	/* 在.macro 和 .endm 中的为*/</span><br><span class="line">    .macro ARM_VECTORS</span><br><span class="line">#ifdef CONFIG_ARCH_K3</span><br><span class="line">	ldr     pc, _reset</span><br><span class="line">#else</span><br><span class="line">	b	reset	// 走这个分支</span><br><span class="line">#endif</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>reset标签在哪呢？<code>arch/arm/cpu/armv7/start.S</code>中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* arch/arm/cpu/armv7/start.S */</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	/* Allow the board to save important registers */</span><br><span class="line">	b	save_boot_params</span><br><span class="line">save_boot_params_ret:</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,</span><br><span class="line"> * except if in HYP mode already</span><br><span class="line"> * 禁用中断，同时设置CPU模式，除非已经处于HYP模式下</span><br><span class="line"> */</span><br><span class="line">    mrs		r0, cpsr			;读取寄存器cpsr中的值，并保存到r0寄存器中。</span><br><span class="line">    and		r1, r0, #0x1f		@ mask mode bits</span><br><span class="line">    teq		r1, 	#0x1a		@ test for HYP mode</span><br><span class="line">    bicne	r0, r0, #0x1f		@ clear all mode bits</span><br><span class="line">    orrne	r0, r0, #0x13		@ set SVC mode</span><br><span class="line">    orr		r0, r0, #0xc0		@ disable FIQ and IRQ</span><br><span class="line">    msr		cpsr,r0</span><br><span class="line"></span><br><span class="line">ENTRY(save_boot_params)</span><br><span class="line">	b	save_boot_params_ret		@ back to my caller</span><br><span class="line">ENDPROC(save_boot_params)</span><br></pre></td></tr></tbody></table></figure>

<p><code>mrs        r0, cpsr</code> ;读取寄存器cpsr中的值，并保存到r0寄存器中。</p>
<p><code>and        r1, r0, #0x1f</code>寄存器r0中的值与0X1F进行与运算，结果保存到r1寄存器中，目的就是提取cpsr的bit0~bit4这5位，这5位为M4 M3 M2 M1 M0，M[4:0]这五位用来设置处理器的工作模式</p>
<p>以上为 u-boot-2022.04中的内容</p>
<hr>
<h4 id="start"><a href="#start" class="headerlink" title="_start"></a>_start</h4><p>由于我们的处理器使用的指令集为armv7，所以**_start**的路径为<code>arch/arm/cpu/armv7/start.S</code></p>
<p>其实对于u-boot的<code>start.S</code>，主要做的几件事就是系统各方面的初始化。</p>
<p>从大的方面分，可分为以下部分</p>
<ul>
<li><p>设置 CPU 模式</p>
</li>
<li><p>关闭看门狗</p>
</li>
<li><p>关闭中断</p>
</li>
<li><p>设置堆栈 sp 指针</p>
</li>
<li><p>清除 bss 段</p>
</li>
<li><p>异常中断处理</p>
</li>
</ul>
<p>接着我们看代码，</p>
<p><code>.globl _start</code> 声明<code>_start</code>标号对全局可见，类似于c语言中的<code>extern</code></p>
<p><code>_start: b    reset</code> <code>_start</code>后加一个冒号，表示其实一个Label。而同时<code>_start</code>的值，也就是代码的最开始的位置，相对是<code>0</code>。在u-boot-spl中其地址是<code>0</code>，在u-boot中，由于经过了relocate之后，代码的运行地址是我们定义的基地址（TODO：找到基地址的定义）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">reset:</span><br><span class="line">	bl	save_boot_params       //跳转到save_boot_params符号处</span><br><span class="line">	/*</span><br><span class="line">	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,</span><br><span class="line">	 * except if in HYP mode already</span><br><span class="line">	 */</span><br><span class="line">	mrs		r0, cpsr			//将cpsr寄存器的值读到r0中</span><br><span class="line">	and		r1, r0, #0x1f		@ mask mode bits</span><br><span class="line">	teq		r1, 	#0x1a		@ test for HYP mode</span><br><span class="line">	bicne	r0, r0, #0x1f		@ clear all mode bits  </span><br><span class="line">	orrne	r0, r0, #0x13		@ set SVC mode 			//更改处理器模式为SVC模式</span><br><span class="line">	orr		r0, r0, #0xc0		@ disable FIQ and IRQ	//将I、F位（7、6位）置1 也即0xc0，关闭快中断和中断</span><br><span class="line">	msr	cpsr,r0					//将r0的内容写入cpsr寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY(save_boot_params)</span><br><span class="line">	bx	lr			@ back to my caller</span><br><span class="line">ENDPROC(save_boot_params)</span><br><span class="line">	.weak	save_boot_params</span><br></pre></td></tr></tbody></table></figure>

<p>这一段，首先会跳转到 <strong>save_boot_params</strong> 标号处，而 <code>ENTRY(save_boot_params)</code> 表示 <code>save_boot_params</code> 入口，进入后就一句 <code>bx lr</code>，其作用为 跳转到 <code>lr</code> 中存放的地址处。而<code>lr</code>的用途：当通过BL或者BLX调用<strong>子程序</strong>时，硬件将自动将子程序返回地址保存在R14寄存器中，在子程序返回时，把LR的值复制到程序计数器就可以实现子程序返回。所以这段代码的意思就是跳转到调用者处。也就是接着执行 bl save_boot_params 后面的代码。</p>
<p><code>mrs    r0, cpsr</code> ;读取寄存器cpsr中的值，并保存到r0寄存器中。</p>
<p><code>and    r1, r0, #0x1f</code>寄存器r0中的值与0X1F进行与运算，结果保存到r1寄存器中，目的就是提取cpsr的bit0~bit4这5位，这5位为M4 M3 M2 M1 M0，M[4:0]这五位用来设置处理器的工作模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101725592.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101726017.png"></p>
<p>如果<code>r1</code>和<code>0X1A(0b11010)</code>不相等，也就是CPU不处于Hyp模式的话就将<code>r0</code>寄存器的bit0~5进行清零，其实就是清除模式位。</p>
<p>如果处理器不处于Hyp模式的话就将r0的寄存器的值与<code>0x13</code>进行或运算，<code>0x13(0b10011)</code>，也就是设置处理器进入SVC模式。</p>
<p><code>r0</code>寄存器的值再与<code>0xC0(0b1100_0000)</code>进行或运算，那么r0寄存器此时的值就是<code>0xD3(0b1101_0000)</code>，cpsr的I位和F位分别控制IRQ和FIQ这两个中断的开关，设置为1就关闭了FIQ和IRQ！</p>
<p>将<code>r0</code>寄存器写回到<code>cpsr</code>寄存器中。完成设置CPU处于SVC32模式，并且关闭FIQ和IRQ这两个中断。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">/*</span><br><span class="line"> * Setup vector:</span><br><span class="line"> * (OMAP4 spl TEXT_BASE is not 32 byte aligned.</span><br><span class="line"> * Continue to use ROM code vector only in OMAP4 spl)</span><br><span class="line"> */</span><br><span class="line">#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))</span><br><span class="line">	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register</span><br><span class="line">	bic	r0, #CR_V		@ V = 0</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register</span><br><span class="line"></span><br><span class="line">	/* Set vector address in CP15 VBAR register */</span><br><span class="line">	ldr	r0, =_start</span><br><span class="line">	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p>这部分代码通过对协处理器CP15进行操作，设置了处理器的异常向量入口地址为<code>_start</code>。</p>
<p>这是因为ARM默认的异常向量表入口在0x0地址，然而S5PV210中0x0地址存放的是IROM，不可修改，自然不可能存放异常向量表，所以需要修改异常向量表入口，将它们映射到其他位置上去。</p>
<p>接着是三个跳转，每个跳转后都会返回到当前位置的下一条地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">	/* the mask ROM code should have PLL and others stable */</span><br><span class="line">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span><br><span class="line">	bl	cpu_init_cp15</span><br><span class="line">	bl	cpu_init_crit</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	bl	_main</span><br></pre></td></tr></tbody></table></figure>



<h4 id="cpu-init-cp15"><a href="#cpu-init-cp15" class="headerlink" title="cpu_init_cp15"></a>cpu_init_cp15</h4><p>首先跳转到 <strong>cpu_init_cp15</strong> 中，我们可以看到在<code>ENDPROC(cpu_init_cp15)</code>之前，有一条 <code>mov pc, lr</code>，此命令作用和<code>bx lr</code>相同，跳转回子函数调用的地方。在 <code>cpu_init_cp15</code> 中，主要是失效  L1 I/D、关闭 MMU 等</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(cpu_init_cp15)</span><br><span class="line">	...</span><br><span class="line">	mov	pc, lr			@ back to my caller //子过程运行结束，跳转回去</span><br><span class="line">ENDPROC(cpu_init_cp15)</span><br></pre></td></tr></tbody></table></figure>



<h4 id="cpu-init-crit"><a href="#cpu-init-crit" class="headerlink" title="cpu_init_crit"></a>cpu_init_crit</h4><p>接着跳转到 <strong>cpu_init_crit</strong> 中，里面又一个跳转 <code>lowlevel_init</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(cpu_init_crit)</span><br><span class="line">	b	lowlevel_init		@ go setup pll,mux,memory</span><br><span class="line">ENDPROC(cpu_init_crit)</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h4 id="lowlevel-init-分析错误"><a href="#lowlevel-init-分析错误" class="headerlink" title="lowlevel_init(分析错误)"></a><del>lowlevel_init(分析错误)</del></h4><p><strong>注意：以下分析错误，请直接看下一个 lowlevel_init</strong> </p>
<p><del><strong>lowlevel_init</strong> 位于 <code>arch/arm/cpu/armv7/lowlevel_init.S</code></del>，主要是设置栈顶指针为 CONFIG_SYS_INIT_SP_ADDR ，然后栈顶指针8字节对齐。如果在SPL，设置r9数据为 gdata 地址，否则为GD数据分配空间，并将分配后的栈顶指针给r9。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(lowlevel_init)</span><br><span class="line">	/*</span><br><span class="line">	 * Setup a temporary stack</span><br><span class="line">	 */</span><br><span class="line">	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR</span><br><span class="line">	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */</span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">	ldr	r9, =gdata</span><br><span class="line">#else</span><br><span class="line">	sub	sp, sp, #GD_SIZE</span><br><span class="line">	bic	sp, sp, #7</span><br><span class="line">	mov	r9, sp</span><br><span class="line">#endif</span><br><span class="line">	/*</span><br><span class="line">	 * Save the old lr(passed in ip) and the current lr to stack</span><br><span class="line">	 */</span><br><span class="line">	push	{ip, lr}</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * go setup pll, mux, memory</span><br><span class="line">	 */</span><br><span class="line">	bl	s_init</span><br><span class="line">	pop	{ip, pc}</span><br><span class="line">ENDPROC(lowlevel_init)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>CONFIG_SYS_INIT_SP_ADDR</strong> 在 <code>include/configs/smart210.h</code>，也就是说设置栈顶指针为SDRAM结束的高地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR + PHYS_SDRAM_1_SIZE)</span><br><span class="line">...</span><br><span class="line">#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE</span><br><span class="line">...</span><br><span class="line">/* DRAM Base */</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br><span class="line">...</span><br><span class="line">#define PHYS_SDRAM_1_SIZE	(512 &lt;&lt; 20)				/* 0x2000_0000, 512 MB Bank #1 */</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101814781.png"></p>
<p>其中 gddata 定义在 <code>arch/arm/lib/spl.c</code>中，这里需要补充一个高级用法。具体用法查看 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html</a> ，这里则是将 gdata 位置存放到 .data 段中。</p>
<blockquote>
<p>_<em>attribute</em>_</p>
<p>该关键字允许您指定变量、函数参数或结构体、联合体以及类成员的特殊属性</p>
<p>而 _<em>attribute</em>_ ((section(“.data”))) </p>
<p>则说明将 前者定义的放入.data段中</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pointer to as well as the global data structure for SPL */</span></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"><span class="keyword">gd_t</span> gdata __attribute__ ((section(<span class="string">".data"</span>)));</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 在 arch/arm/include/asm/global_data.h 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm (<span class="meta-string">"r9"</span>)</span></span><br></pre></td></tr></tbody></table></figure>

<p>此时需要注意下 DECLARE_GLOBAL_DATA_PTR 这个宏，这个宏的意思是定义了全局数据结构gd（<strong>寄存器r9来表示全局数据结构gd</strong>）</p>
<p><code>register volatile gd_t *gd asm ("r9")</code> 其中register关键字是必须的，asm (“r9”)为嵌入式汇编，表示用r9寄存器存储gd指针，r9和CPU体系结构相关。寄存器变量。</p>
<p>所以不管 <code>ldr    r9, =gdata</code>还是<code>mov    r9, sp</code>都是更新 gd 的地址，不同的是在SPL下，gd结构体空间被分配在 <code>.data</code>段中，在u-boot中，gd结构体空间被分配在<code>CONFIG_SYS_INIT_SP_ADDR - GD_SIZE</code> （需要8字节对齐）处。</p>
<p>接着往下走，<code>push    {ip, lr}</code>用stack的形式保存<code>lr</code>(返回指针)，将ip和lr入栈</p>
<p>然后一个跳转到<code>bl    s_init</code>中。</p>
<p>下面 <code>pop    {ip, pc}</code> 恢复到<code>ip</code>、<code>pc</code>，意思是改变pc的指向，将lr内容恢复到pc中，也即返回到lr指向的地方，在此处应为<code>bl    cpu_init_crit</code>的下方，也即<code>bl    _main</code>。</p>
<p>接着分析 <code>s_init</code>，在与smart210相关的任何地方找不到与s_init相关的定义，也找不到与s5pv210任何相关的，所以此处应该是有问题的，通过在指令间添加一些异常数据，编译，编译通过，得知在调用 lowlevel_init时并不是找的此处。</p>
<p><strong>以上分析错误，请直接查看下一个 lowlevel_init</strong> </p>
<hr>
<h4 id="lowlevel-init"><a href="#lowlevel-init" class="headerlink" title="lowlevel_init"></a>lowlevel_init</h4><p><strong>lowlevel_init</strong> 位于 <code>board/samsung/smart210/lowlevel_init.S</code> ，这个相对简单，但还是说一下，首先将<code>lr</code>返回地址保存到<code>r9</code>中（此处不应该使用r9，或者说在使用r9前先保存r9的值），如果在SPL下，则需要初始化时钟和ddr，并配置串口寄存器<code>PA0CON</code>值为<code>0x22222222</code>（查看手册 <code>S5PV210_UM_REV1.1.pdf</code>中<code>2.2.2.1 Port Group GPA0 Control Register (GPA0CON, R/W, Address = 0xE020_0000)</code> ）。之后，恢复<code>pc</code>值为<code>lr</code>，返回到调用 <code>lowlevel_init</code> 的地方。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; board/samsung/smart210/lowlevel_init.S</span><br><span class="line"></span><br><span class="line">	.globl lowlevel_init</span><br><span class="line">lowlevel_init:</span><br><span class="line">	mov	r9, lr</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">    bl clock_init                   /* clock init */</span><br><span class="line">    bl ddr_init                     /* DDR init */</span><br><span class="line"></span><br><span class="line">    /* add by Flinn, for uart */</span><br><span class="line">    ldr r0, =0xE0200000     		/* GPA0_CON */</span><br><span class="line">    ldr r1, =0x22222222</span><br><span class="line">    str r1, [r0]</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">    mov pc, r9                		/* return */</span><br></pre></td></tr></tbody></table></figure>



<p>返回到<code>bl cpu_init_crit</code>的下一句指令，也即执行 <code>bl _main</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line"></span><br><span class="line">	/* the mask ROM code should have PLL and others stable */</span><br><span class="line">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span><br><span class="line">	bl	cpu_init_cp15</span><br><span class="line">	bl	cpu_init_crit</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	bl	_main</span><br></pre></td></tr></tbody></table></figure>



<h4 id="main"><a href="#main" class="headerlink" title="_main"></a>_main</h4><p><strong>_main</strong>位于<code>arch/arm/lib/crt0.S</code>中，具体代码一会回来分析。</p>
<p>终于来到<code>_main</code>中了，首先如果定义了<code>CONFIG_SPL_BUILD</code>和<code>CONFIG_SPL_STACK</code>，也即SPL时，sp值为<code>CONFIG_SPL_STACK</code>，但经过验证没有走这个分支；所以sp的值只可能为<code>CONFIG_SYS_INIT_SP_ADDR</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">/*</span><br><span class="line"> * entry point of crt0 sequence</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">ENTRY(_main)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set up initial C runtime environment and call board_init_f(0).</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">	ldr	sp, =(CONFIG_SPL_STACK)</span><br><span class="line">#else</span><br><span class="line">	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line">#endif</span><br><span class="line">	...</span><br><span class="line">ENDPROC(_main)</span><br></pre></td></tr></tbody></table></figure>



<p><strong>CONFIG_SYS_INIT_SP_ADDR</strong> 在 <code>include/configs/smart210.h</code>，也就是说设置栈顶指针为SDRAM结束的高地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* include/configs/smart210.h */</span><br><span class="line">#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR + PHYS_SDRAM_1_SIZE)</span><br><span class="line">...</span><br><span class="line">#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE</span><br><span class="line">...</span><br><span class="line">/* DRAM Base */</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br><span class="line">...</span><br><span class="line">#define PHYS_SDRAM_1_SIZE	(512 &lt;&lt; 20)				/* 0x2000_0000, 512 MB Bank #1 */</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101814781.png"></p>
<p>接着往下走，是给<code>gd</code>数据结构分配空间。gd是什么？</p>
<blockquote>
<p>gd是一个寄存器变量。此时需要注意下 DECLARE_GLOBAL_DATA_PTR 这个宏，这个宏的意思是定义了全局数据结构gd（<strong>寄存器r9来表示全局数据结构gd</strong>）</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// arch/arm/include/asm/global_data.h </span></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm (<span class="meta-string">"r9"</span>)</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>register volatile gd_t *gd asm ("r9")</code> 其中<code>register</code>关键字是必须的，<code>asm ("r9")</code>为嵌入式汇编，表示用<code>r9</code>寄存器存储<code>gd</code>指针，<code>r9</code>和CPU体系结构相关。</p>
</blockquote>
<p>先8字节对齐，然后给<code>gd</code>结构分配大小为<code>GD_SIZE</code>的空间，然后继续8字节对齐。<code>GD_SIZE</code>是一个宏，在<code>include/generated/generic-asm-offsets.h</code>中定义为<code>160</code>（<code>sizeof(struct global_data)</code>），该文件也是生成的。</p>
<p>更新<code>r9</code>值为<code>sp</code>，此时<code>r9 = sp = [CONFIG_SYS_INIT_SP_ADDR - GD_SIZE]</code>（<code>[CONFIG_SYS_INIT_SP_ADDR - GD_SIZE]</code>为对应地址处的值），接着给<code>r0</code>清零</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	bic	sp, sp, #7			/* 8-byte alignment for ABI compliance */</span><br><span class="line">	sub	sp, sp, #GD_SIZE	/* allocate one GD above SP */</span><br><span class="line">	bic	sp, sp, #7			/* 8-byte alignment for ABI compliance */</span><br><span class="line">	mov	r9, sp				/* GD is above SP */</span><br><span class="line">	mov	r0, #0</span><br></pre></td></tr></tbody></table></figure>



<p>接着往下走，分为两种情况，第一种SPL下，跳转到 <code>copy_bl2_to_ram</code>（完成BL2阶段镜像校验并拷贝到SDRAM中），执行结束后返回，更改PC指针为<code>CONFIG_SYS_SDRAM_BASE</code>，也即跳转到 BL2阶段（SDRAM中）。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">        bl      copy_bl2_to_ram</span><br><span class="line">        ldr pc, =CONFIG_SYS_SDRAM_BASE</span><br><span class="line">#else</span><br><span class="line">        bl      board_init_f</span><br><span class="line">#endif</span><br><span class="line">-----------------------------------------------</span><br><span class="line">; include/configs/smart210.h</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br></pre></td></tr></tbody></table></figure>



<h4 id="copy-bl2-to-ram"><a href="#copy-bl2-to-ram" class="headerlink" title="copy_bl2_to_ram"></a>copy_bl2_to_ram</h4><p><code>copy_bl2_to_ram</code>函数在 <code>board/samsung/smart210/smart210.c</code> 中</p>
<p>首先是几个宏定义，让我们看一下是什么东东？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从SD/MMC拷贝（加载）块到内存中的函数 </span></span><br><span class="line"><span class="comment">** ch:  通道号</span></span><br><span class="line"><span class="comment">** sb:  起始块号</span></span><br><span class="line"><span class="comment">** bs:  块数量</span></span><br><span class="line"><span class="comment">** dst: 要拷贝到内存的什么位置上</span></span><br><span class="line"><span class="comment">** i:   是否需要初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CopySDMMCtoMem(ch, sb, bs, dst, i) \</span></span><br><span class="line"><span class="meta">        (((u8(*)(int, u32, unsigned short, u32*, u8))\</span></span><br><span class="line"><span class="meta">        (*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_1CON  (*(volatile u32 *)0xE02002E0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_3CON  (*(volatile u32 *)0xE0200320)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_6CON  (*(volatile u32 *)0xE0200380) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF8_ReadPage_Adv(a,b,c) (((int(*)(u32, u32, u8*))(*((u32 *)0xD0037F90)))(a,b,c))</span></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CopySDMMCtoMem(ch, sb, bs, dst, i) \</span></span><br><span class="line"><span class="meta">(((u8(*)(int, u32, unsigned short, u32*, u8))(*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))   </span></span><br></pre></td></tr></tbody></table></figure>

<p>这个宏定义分为三段来看，分别对应着 <strong>函数返回值数据类型 （*指针变量名）（函数的实际参数或者函数参数的类型）</strong><br>第一段：<code>((u8 (*)(int, u32, unsigned short, u32*, u8))</code> 是一个函数类型强制类型转换，其中<code>u8</code>为返回值，<code>(int, u32, unsigned short, u32*, u8)</code>为传入参数类型。<br>第二段：<code>(*((u32 *)0xD0037F98)))</code> ，在地址<code>0xD0037F98</code>中存放了一个名字叫<code>CopySDMMCtoMem</code>的函数，armv7 为32位cpu，所以先转成<strong>指针类型为u32*<strong>，然后再把这个地址</strong>解引用</strong>，就得到了地址中存在的值也就是CopySDMMCtoMem</p>
<p>第三段：将函数的实际参数传入即可<code>(ch, sb, bs, dst, i)</code>，最外层加上一个大括号。</p>
<p>接着三个宏表示 将对<strong>对应地址处的值</strong>操作。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_1CON  (*(volatile u32 *)0xE02002E0) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.25.1*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_3CON  (*(volatile u32 *)0xE0200320) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.27.1*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_6CON  (*(volatile u32 *)0xE0200380) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.30.1*/</span></span></span><br></pre></td></tr></tbody></table></figure>

<p><code>NF8_ReadPage_Adv(a,b,c)</code>与<code>CopySDMMCtoMem(ch, sb, bs, dst, i)</code>一致，不在讲解。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CopySDMMCtoMem(ch, sb, bs, dst, i)</td>
<td>从SD/MMC拷贝（加载）块到内存中的函数 （从通道ch的sb块处，加载bs块内存到以dst起始的地方）</td>
</tr>
<tr>
<td>NF8_ReadPage_Adv(a,b,c)</td>
<td>从nand flash拷贝（加载）页到内存中的函数（a：要复制的源块地址号，b：要复制的源页地址号，c：目标缓冲区指针，返回值成功或失败）</td>
</tr>
</tbody></table>
<p>接着就进入到<code>copy_bl2_to_ram</code>，整个<code>copy_bl2_to_ram</code>框架如下。也就是上来先定义bl2的大小为250k（编译结束后生成u-boot.bin大小为240k），所以此处最好大小调大一些（建议512k）。OM为寄存器<code>0xE0000004</code>中存储的值，通过手册（<code>SIAP</code> 中<code>3 Boot configuration</code>）可知OM低5位控制着从哪里启动，所以下面两个分支也就是选择从哪边启动。0x2（0b0010）也即<code>Nand 2KB,5cycle X-TAL</code>；0xc（0b1100）也即<code>SD/MMC X-TAL</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_bl2_to_ram</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    u32 bl2Size = <span class="number">250</span> * <span class="number">1024</span>;       		<span class="comment">// 250K</span></span><br><span class="line">    u32 OM = *(<span class="keyword">volatile</span> u32 *)(<span class="number">0xE0000004</span>); <span class="comment">// OM Register</span></span><br><span class="line">    OM &amp;= <span class="number">0x1F</span>;                             <span class="comment">// 取出低5位</span></span><br><span class="line">    <span class="keyword">if</span> (OM == <span class="number">0x2</span>) {						<span class="comment">// Nand 2KB,5cycle X-TAL</span></span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (OM == <span class="number">0xC</span>) {					<span class="comment">// SD/MMC X-TAL</span></span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204112027872.png"></p>
<p>先分析SD/MMC下的代码（SD卡下的代码），首先取出当前boot的<code>SDMMC_BASE</code>基地址（查看手册<code>SIAP</code> 中<code>2.6 Global Variable</code> ），查看 手册<code>S5PV210_UM_REV1.1.pdf</code>中的<code>7.9.1 REGISTER MAP</code> 得到对应的channel，然后将SD卡中第32块开始的250k区域数据拷贝到<code>CONFIG_SYS_SDRAM_BASE</code> （<code>0x20000000</code>）中去。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (OM == <span class="number">0xC</span>) {</span><br><span class="line">         u32 V210_SDMMC_BASE = *(<span class="keyword">volatile</span> u32 *)(<span class="number">0xD0037488</span>);    <span class="comment">// V210_SDMMC_BASE</span></span><br><span class="line">         u8 ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 7.9.1 SD/MMC REGISTER MAP */</span></span><br><span class="line">         <span class="keyword">if</span> (V210_SDMMC_BASE == <span class="number">0xEB000000</span>)</span><br><span class="line">                 ch = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (V210_SDMMC_BASE == <span class="number">0xEB200000</span>)</span><br><span class="line">                 ch = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 将BL2 从SD卡（32块开始的250k区域数据）拷贝到SDRAM中</span></span><br><span class="line">         CopySDMMCtoMem(ch, <span class="number">32</span>, bl2Size / <span class="number">512</span>, (u32 *)CONFIG_SYS_SDRAM_BASE, <span class="number">0</span>);</span><br><span class="line">     }</span><br></pre></td></tr></tbody></table></figure>

<p>接着分析如果u-boot在nand中是怎样将BL2拷贝到内存中的？</p>
<p>首先初始化配置，将配置写入到 <code>nand_reg-&gt;nfconf</code> 和 <code>nand_reg-&gt;nfcont</code> 中，接着配置GPIO。<code>pages = bl2Size/2048</code>，看一下BL2一共有多少页。下一个offset = 0x4000/2048，意思是BL2在nand的页偏移。0x4000/512 = 32blocks</p>
<blockquote>
<p><code>void writel(unsigned char data , unsigned short addr)</code> 往内存映射的IO空间上写数据</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (OM == <span class="number">0x2</span>) {</span><br><span class="line">    u32 cfg = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s5pv210_nand</span> *<span class="title">nand_reg</span> =</span> (struct s5pv210_nand *)(struct s5pv210_nand *)samsung_get_base_nand();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize hardware */</span></span><br><span class="line">    <span class="comment">/* HCLK_PSYS=133MHz(7.5ns) */</span></span><br><span class="line">    cfg =   (<span class="number">0x1</span> &lt;&lt; <span class="number">23</span>) |   <span class="comment">/* Disable 1-bit and 4-bit ECC */</span></span><br><span class="line">            (<span class="number">0x3</span> &lt;&lt; <span class="number">12</span>) |   <span class="comment">/* 7.5ns * 2 &gt; 12ns tALS tCLS */</span></span><br><span class="line">            (<span class="number">0x2</span> &lt;&lt; <span class="number">8</span>) |    <span class="comment">/* (1+1) * 7.5ns &gt; 12ns (tWP) */</span></span><br><span class="line">            (<span class="number">0x1</span> &lt;&lt; <span class="number">4</span>) |    <span class="comment">/* (0+1) * 7.5 &gt; 5ns (tCLH/tALH) */</span></span><br><span class="line">            (<span class="number">0x0</span> &lt;&lt; <span class="number">3</span>) |    <span class="comment">/* SLC NAND Flash */</span></span><br><span class="line">            (<span class="number">0x0</span> &lt;&lt; <span class="number">2</span>) |    <span class="comment">/* 2KBytes/Page */</span></span><br><span class="line">            (<span class="number">0x1</span> &lt;&lt; <span class="number">1</span>);     <span class="comment">/* 5 address cycle */</span></span><br><span class="line"></span><br><span class="line">    writel(cfg, &amp;nand_reg-&gt;nfconf);</span><br><span class="line"></span><br><span class="line">    writel((<span class="number">0x1</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">0x1</span> &lt;&lt; <span class="number">0</span>), &amp;nand_reg-&gt;nfcont);</span><br><span class="line">    <span class="comment">/* Disable chip select and Enable NAND Flash Controller */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Config GPIO */</span></span><br><span class="line">    MP0_1CON &amp;= ~(<span class="number">0xFFFF</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    MP0_1CON |= (<span class="number">0x3333</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    MP0_3CON = <span class="number">0x22222222</span>;</span><br><span class="line">    MP0_6CON = <span class="number">0x22222222</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pages = bl2Size / <span class="number">2048</span>;             <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0x4000</span> / <span class="number">2048</span>;             <span class="comment">// u-boot.bin</span></span><br><span class="line">    u8 *p = (u8 *)CONFIG_SYS_SDRAM_BASE;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pages; i++, p += <span class="number">2048</span>, offset += <span class="number">1</span>)</span><br><span class="line">    	NF8_ReadPage_Adv(offset / <span class="number">64</span>, offset % <span class="number">64</span>, p);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204112111124.png"></p>
<h4 id="board-init-f"><a href="#board-init-f" class="headerlink" title="board_init_f"></a>board_init_f</h4><p><code>board_init_f</code> 在<code>arch/arm/lib/board.c</code>中</p>
<p><strong>TODO：待补充</strong></p>
<h4 id="main-继续，接上文"><a href="#main-继续，接上文" class="headerlink" title="_main 继续，接上文"></a>_main 继续，接上文</h4><p>在非SPL下，接着就是更新<code>sp</code>和<code>gd</code>，然后重定位代码。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	...</span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">	ldr	sp, [r9, #GD_START_ADDR_SP]	/* sp = gd-&gt;start_addr_sp */</span><br><span class="line">	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */</span><br><span class="line">	ldr	r9, [r9, #GD_BD]		/* r9 = gd-&gt;bd */</span><br><span class="line">	sub	r9, r9, #GD_SIZE		/* new GD is below bd */</span><br><span class="line">	...</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p><code>GD_START_ADDR_SP</code>在 <code>include/generated/generic-asm-offsets.h</code>中定义，其值为 <code>start_addr_sp</code> 在  <code>global_data</code> 结构中的相对偏移，同样是编译后才生成的。</p>
<p>由上面的代码可知，刚刚为<code>gd</code>也就是<code>global_data</code>分配了大小为<code>GD_SIZE</code>的空间，现在<code>r9</code>和<code>sp</code>内的数据为地址<code>CONFIG_SYS_INIT_SP_ADDR - GD_SIZE</code> （需要8字节对齐）中的数据。换句话说此时<code>r9</code>中为<code>gd</code>的地址，那么再加上 <code>GD_START_ADDR_SP</code>，也就是<code>gd+GD_START_ADDR_SP</code>，将<code>gd+GD_START_ADDR_SP</code>地址中的值（<code>gd-&gt;start_addr_sp</code>）传递给<code>sp</code>，接着8字节对齐。</p>
<p>然后更新<code>r9</code>的值为<code>[r9 + GD_BD]</code>，也就是<code>r9 = gd-&gt;bd</code>。</p>
<p>然后又分配一个大小为<code>GD_SIZE</code>的空间。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	...</span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">	...</span><br><span class="line">	adr	lr, here</span><br><span class="line">	ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd-&gt;reloc_off */</span><br><span class="line">	add	lr, lr, r0</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd-&gt;relocaddr */</span><br><span class="line">	b	relocate_code</span><br><span class="line">	</span><br><span class="line">here:</span><br><span class="line">/* Set up final (full) environment */</span><br><span class="line">	bl	c_runtime_cpu_setup	/* we still call old routine here */</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p>将<code>here</code>处的相对地址复制给<code>lr</code>，将<code>gd</code>结构中的<code>reloc_off</code>值（其相对于<code>gd</code>偏移为<code>GD_RELOC_OFF</code>）给<code>r0</code>。</p>
<p><code>lr</code>与<code>r0</code>相加给<code>lr</code>,即<code>lr = lr + r0</code>，将<code>gd</code>结构中的<code>relocaddr</code>值（其相对于<code>gd</code>偏移为<code>GD_RELOCADDR</code>）给<code>r0</code>。</p>
<p>此时<code>lr = here + gd-&gt;reloc_off</code> ; <code>r0 = gd-&gt;relocaddr</code>;</p>
<p>然后调用<code>relocate_code</code>。</p>
<h4 id="relocate-code"><a href="#relocate-code" class="headerlink" title="relocate_code"></a>relocate_code</h4><p>其定义位于 <code>include/common.h</code>中，由于定义了宏<code>CONFIG_ARM</code>，所以其声明为如下代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/common.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relocate_code</span><span class="params">(ulong)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>其实现位于 <code>arch/arm/lib/relocate.S</code>中</p>
<p>是一个比较麻烦的地方，并且需要函数传参。</p>
<p><strong>TODO：待补充</strong></p>
<p>未定义__ARM_ARCH_4__，所以执行<code>bx lr</code>，而此时<code>lr</code>中的值为<code>here + gd-&gt;reloc_off</code>，怎么解释？此时重定位已经完成，重定位后的地址为<code>gd-&gt;reloc_off</code>，<code>here</code> 为<code>here</code>处的相对地址，所以<strong>二者相加后为重定位后的<code>here</code>处的地址</strong>，然后跳回去。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">/* ARMv4- don't know bx lr but the assembler fails to see that */</span><br><span class="line"></span><br><span class="line">#ifdef __ARM_ARCH_4__</span><br><span class="line">	mov        pc, lr</span><br><span class="line">#else</span><br><span class="line">	bx        lr</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>



<h4 id="main-继续，接上文：here"><a href="#main-继续，接上文：here" class="headerlink" title="_main 继续，接上文：here"></a>_main 继续，接上文：here</h4><p>回到<code>here</code>处开始跳转到 <code>c_runtime_cpu_setup</code>，<code>c_runtime_cpu_setup</code>执行结束后返回。</p>
<p>继续执行<code>r0 = __bss_start</code>，<code>r1 = __bss_end</code>，<code>r2 = 0</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">here:</span><br><span class="line"></span><br><span class="line">/* Set up final (full) environment */</span><br><span class="line"></span><br><span class="line">	bl	c_runtime_cpu_setup	/* we still call old routine here */</span><br><span class="line"></span><br><span class="line">	ldr	r0, =__bss_start	/* this is auto-relocated! */</span><br><span class="line">	ldr	r1, =__bss_end		/* this is auto-relocated! */</span><br><span class="line"></span><br><span class="line">	mov	r2, #0x00000000		/* prepare zero to clear BSS */</span><br></pre></td></tr></tbody></table></figure>

<p>将<code>[__bss_start,__bss_end]</code>范围内的内存清零。</p>
<p>比较<code>r0</code>和<code>r1</code>的值，首先<code>r0=r0-r1</code>,当满足条件<code>r0&lt;r1</code>时，将<code>r2</code>中的值0复制给以将<code>r0</code>的值作为地址的内存中，当满足条件<code>r0&lt;r1</code>时，<code>r0=r0+4</code>，当满足条件<code>r0&lt;r1</code>时，跳转到<code>clbss_l</code>处。接着循环，知道二者相等时，不满足条件，继续执行<code>bl coloured_LED_init</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line"></span><br><span class="line">clbss_l:cmp	r0, r1			/* while not at end of BSS */</span><br><span class="line">	strlo	r2, [r0]		/* clear 32-bit BSS word */</span><br><span class="line">	addlo	r0, r0, #4		/* move to next */</span><br><span class="line">	blo	clbss_l</span><br></pre></td></tr></tbody></table></figure>



<p>跳转到coloured_LED_init，跳转到red_led_on，没啥内容。主要关注一下语法即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">    </span><br><span class="line">	bl coloured_LED_init</span><br><span class="line">	bl red_led_on</span><br><span class="line">------------------------------</span><br><span class="line">// common/board_f.c</span><br><span class="line">inline void __coloured_LED_init(void) {}</span><br><span class="line">void coloured_LED_init(void)</span><br><span class="line">        __attribute__((weak, alias("__coloured_LED_init")));</span><br><span class="line">inline void __red_led_on(void) {}</span><br><span class="line">void red_led_on(void) __attribute__((weak, alias("__red_led_on")));</span><br></pre></td></tr></tbody></table></figure>



<p><code>r0 = r9 = gd</code>，<code>r1 = [r9(gd) + GD_RELOCADDR]</code>，也就是说<code>r0</code>此时为<code>gd</code>,<code>r1</code>为相对于<code>gd</code>偏移<code>GD_RELOCADDR</code>的地址中的值。</p>
<p>将<code>pc</code>值更改为<code>board_init_r</code>，也就是跳转到<code>board_init_r</code>执行，此处不需要返回。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	/* call board_init_r(gd_t *id, ulong dest_addr) */</span><br><span class="line">	mov     r0, r9                  /* gd_t */</span><br><span class="line">	ldr	r1, [r9, #GD_RELOCADDR]		/* dest_addr */</span><br><span class="line">	/* call board_init_r */</span><br><span class="line">	ldr	pc, =board_init_r	/* this is auto-relocated! */</span><br><span class="line"></span><br><span class="line">	/* we should not return here. */</span><br></pre></td></tr></tbody></table></figure>

<p>到此 <code>_main</code>就结束了。</p>
<h4 id="c-runtime-cpu-setup"><a href="#c-runtime-cpu-setup" class="headerlink" title="c_runtime_cpu_setup"></a>c_runtime_cpu_setup</h4><p><code>c_runtime_cpu_setup</code>位于 <code>arch/arm/cpu/armv7/start.S</code>，</p>
<p><strong>TODO：待补充</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(c_runtime_cpu_setup)</span><br><span class="line">/*</span><br><span class="line"> * If I-cache is enabled invalidate it</span><br><span class="line"> */</span><br><span class="line">#ifndef CONFIG_SYS_ICACHE_OFF</span><br><span class="line">	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache</span><br><span class="line">	mcr     p15, 0, r0, c7, c10, 4	@ DSB</span><br><span class="line">	mcr     p15, 0, r0, c7, c5, 4	@ ISB</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * Move vector table</span><br><span class="line"> */</span><br><span class="line">	/* Set vector address in CP15 VBAR register */</span><br><span class="line">	ldr     r0, =_start</span><br><span class="line">	mcr     p15, 0, r0, c12, c0, 0  @Set VBAR</span><br><span class="line"></span><br><span class="line">	bx	lr</span><br><span class="line"></span><br><span class="line">ENDPROC(c_runtime_cpu_setup)</span><br></pre></td></tr></tbody></table></figure>



<h4 id="board-init-r"><a href="#board-init-r" class="headerlink" title="board_init_r"></a>board_init_r</h4><p><strong>board_init_r</strong>函数位于<code>common/board_r.c</code>中，</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *new_gd, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_X86</span></span><br><span class="line">	gd = new_gd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(init_sequence_r); i++)</span><br><span class="line">		init_sequence_r[i] += gd-&gt;reloc_off;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcall_run_list(init_sequence_r))</span><br><span class="line">		hang();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* NOTREACHED - run_main_loop() does not return */</span></span><br><span class="line">	hang();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>TODO：待补充</strong>分析这个函数，这也太麻烦了。。。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/u-boot/boot_flow_1.html">wowo的u-boot启动流程分析（1）平台相关部分_</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ooonebook/category_6471981.html">ooonebook大佬的project-X系列</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ooonebook/category_6484145.html">ooonebook大佬的u-boot系列</a></li>
<li> <a target="_blank" rel="noopener" href="https://github.com/limingth/ARM-Resources/blob/master/tiny210/Datasheet/S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf">S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/limingth/ARM-Resources/blob/master/tiny210/Datasheet/S5PV210_UM_REV1.1.pdf">S5PV210_UM_REV1.1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://re-eject.gbadev.org/files/GasARMRef.pdf">https://re-eject.gbadev.org/files/GasARMRef.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_55796564/article/details/119949722">第三十二章 U-Boot启动流程详解 -摘自【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.0</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012176730/article/details/54670569">嵌入式Linux学习：u-boot源码分析（1）–AM335X系列的2014.10版</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40531974/article/details/83897559">ARM汇编指令集汇总</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouqt/article/details/78172332">ARM指令CMP详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zackary/p/9343253.html"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zackary/p/9343253.html">ARM 汇编指令 ADR 与 LDR 使用 </a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lj gong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gonglja.github.io/posts/f88e6d17/">http://gonglja.github.io/posts/f88e6d17/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gonglja.github.io" target="_blank">Gong's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/eeea93b8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TEST</div></div></a></div><div class="next-post pull-right"><a href="/posts/d78cdbc6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://archlinux.org/static/logos/archlinux-logo-dark-1200dpi.b42bd35d5916.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Archlinux从安装到使用（持续更新中）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111228921.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lj gong</div><div class="author-info__description">蓬生麻中，不扶而直，白沙在涅，与之俱黑。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Gonglja"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/gonglja" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:glj0@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">2022重新出发！加油加油</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#u-boot-2014-04-%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">u-boot-2014.04 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#s5pv210"><span class="toc-number">1.1.</span> <span class="toc-text">s5pv210</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">芯片启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BL0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">BL0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BL1"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">BL1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BL2"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">BL2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">地址映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u-boot"><span class="toc-number">1.2.</span> <span class="toc-text">u-boot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">编译问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">错误1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2022%E4%B8%AD%E7%9A%84-start%E4%B8%8D%E7%9C%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">2022中的_start不看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">_start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-init-cp15"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">cpu_init_cp15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-init-crit"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">cpu_init_crit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lowlevel-init-%E5%88%86%E6%9E%90%E9%94%99%E8%AF%AF"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">lowlevel_init(分析错误)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lowlevel-init"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">lowlevel_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">_main</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-bl2-to-ram"><span class="toc-number">1.3.4.8.</span> <span class="toc-text">copy_bl2_to_ram</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#board-init-f"><span class="toc-number">1.3.4.9.</span> <span class="toc-text">board_init_f</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E7%BB%A7%E7%BB%AD%EF%BC%8C%E6%8E%A5%E4%B8%8A%E6%96%87"><span class="toc-number">1.3.4.10.</span> <span class="toc-text">_main 继续，接上文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#relocate-code"><span class="toc-number">1.3.4.11.</span> <span class="toc-text">relocate_code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E7%BB%A7%E7%BB%AD%EF%BC%8C%E6%8E%A5%E4%B8%8A%E6%96%87%EF%BC%9Ahere"><span class="toc-number">1.3.4.12.</span> <span class="toc-text">_main 继续，接上文：here</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-runtime-cpu-setup"><span class="toc-number">1.3.4.13.</span> <span class="toc-text">c_runtime_cpu_setup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#board-init-r"><span class="toc-number">1.3.4.14.</span> <span class="toc-text">board_init_r</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3b31c731/" title="c语言中给定一个函数地址如何调用呢？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111548715.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言中给定一个函数地址如何调用呢？"/></a><div class="content"><a class="title" href="/posts/3b31c731/" title="c语言中给定一个函数地址如何调用呢？">c语言中给定一个函数地址如何调用呢？</a><time datetime="2022-04-11T07:48:18.000Z" title="发表于 2022-04-11 15:48:18">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eeea93b8/" title="TEST"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TEST"/></a><div class="content"><a class="title" href="/posts/eeea93b8/" title="TEST">TEST</a><time datetime="2022-04-11T04:16:45.000Z" title="发表于 2022-04-11 12:16:45">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f88e6d17/" title="u-boot-2014.04 分析（未完待续）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="u-boot-2014.04 分析（未完待续）"/></a><div class="content"><a class="title" href="/posts/f88e6d17/" title="u-boot-2014.04 分析（未完待续）">u-boot-2014.04 分析（未完待续）</a><time datetime="2022-03-29T01:33:08.000Z" title="发表于 2022-03-29 09:33:08">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d78cdbc6/" title="Archlinux从安装到使用（持续更新中）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://archlinux.org/static/logos/archlinux-logo-dark-1200dpi.b42bd35d5916.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Archlinux从安装到使用（持续更新中）"/></a><div class="content"><a class="title" href="/posts/d78cdbc6/" title="Archlinux从安装到使用（持续更新中）">Archlinux从安装到使用（持续更新中）</a><time datetime="2022-03-25T08:31:48.000Z" title="发表于 2022-03-25 16:31:48">2022-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/74f0a0fa/" title="GS87D键盘说明书"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111243846.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GS87D键盘说明书"/></a><div class="content"><a class="title" href="/posts/74f0a0fa/" title="GS87D键盘说明书">GS87D键盘说明书</a><time datetime="2022-03-22T12:46:51.000Z" title="发表于 2022-03-22 20:46:51">2022-03-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By lj gong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'cf6d7d2674b768ef1bf7',
      clientSecret: 'a8254412e77947a4ff26d08ce7af7b5853efbb44',
      repo: 'gonglja.github.io',
      owner: 'Gonglja',
      admin: ['Gonglja'],
      id: '927bcc1d0a6a057c311dda4e328110e5',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>