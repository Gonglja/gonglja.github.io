<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【源码分析】u-boot-2014.04 分析（未完待续） | Gong's Blog</title><meta name="author" content="lj gong"><meta name="copyright" content="lj gong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="u-boot-2014.04 分析​    由于要移植一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。 本文使用的版本是 u-boot-2022.04-rc4.tar.bz2 u-boot-2014.04（因作者能力不够，遂从2014.04开始） s5pv210芯片启动流程由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iRO">
<meta property="og:type" content="article">
<meta property="og:title" content="【源码分析】u-boot-2014.04 分析（未完待续）">
<meta property="og:url" content="http://gonglja.github.io/posts/f88e6d17/index.html">
<meta property="og:site_name" content="Gong&#39;s Blog">
<meta property="og:description" content="u-boot-2014.04 分析​    由于要移植一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。 本文使用的版本是 u-boot-2022.04-rc4.tar.bz2 u-boot-2014.04（因作者能力不够，遂从2014.04开始） s5pv210芯片启动流程由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iRO">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png">
<meta property="article:published_time" content="2022-03-29T01:33:08.000Z">
<meta property="article:modified_time" content="2022-06-08T14:13:43.733Z">
<meta property="article:author" content="lj gong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gonglja.github.io/posts/f88e6d17/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【源码分析】u-boot-2014.04 分析（未完待续）',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-06-08 22:13:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111228921.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://gonglja.github.io/Notes"><i class="fa-fw fas fa-link"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Gong's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://gonglja.github.io/Notes"><i class="fa-fw fas fa-link"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【源码分析】u-boot-2014.04 分析（未完待续）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-29T01:33:08.000Z" title="发表于 2022-03-29 09:33:08">2022-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-08T14:13:43.733Z" title="更新于 2022-06-08 22:13:43">2022-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/">技术随笔</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>143分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【源码分析】u-boot-2014.04 分析（未完待续）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="u-boot-2014-04-分析"><a href="#u-boot-2014-04-分析" class="headerlink" title="u-boot-2014.04 分析"></a>u-boot-2014.04 分析</h1><p>​    由于要移植一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。</p>
<p>本文使用的版本是 <del><a href="ttps://ftp.denx.de/pub/u-boot/u-boot-2022.04-rc4.tar.bz2">u-boot-2022.04-rc4.tar.bz2</a></del> <a target="_blank" rel="noopener" href="https://github.com/Gonglja/u-boot-smart210">u-boot-2014.04</a>（因作者能力不够，遂从2014.04开始）</p>
<h2 id="s5pv210"><a href="#s5pv210" class="headerlink" title="s5pv210"></a>s5pv210</h2><h3 id="芯片启动流程"><a href="#芯片启动流程" class="headerlink" title="芯片启动流程"></a>芯片启动流程</h3><p>由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iROM中，BL1和BL2运行在SRAM中，但在实际项目中使用的比较通用的启动流程与官方流程有较大差异，为什么呢？因为编译的u-boot过大，超过最大80k限制。所以BL2在SDRAM中运行，而三星官方是放在内部SRAM中运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png"></p>
<h4 id="BL0"><a href="#BL0" class="headerlink" title="BL0"></a>BL0</h4><ul>
<li>运行在iROM上</li>
<li>代码固定在s5pv210的IROM中，无法修改。上电后直接从IROM中开始执行</li>
<li>主要工作<ul>
<li>初始化系统时钟、特殊设备控制器、启动设备、看门狗、SRAM等</li>
<li>验证BL1镜像</li>
<li>从存储介质上（比如SD/eMMC/nand flash）等加载BL1镜像到内部SRAM中</li>
<li>跳转到BL1镜像所在地址</li>
</ul>
</li>
</ul>
<h4 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h4><ul>
<li>运行在SRAM上</li>
<li>BL1代码在BL0段被加载到SRAM中</li>
<li>主要工作<ul>
<li>初始化部分时钟（SDRAM相关）</li>
<li>初始化DDR（外部SDRAM）</li>
<li>从存储介质上将BL2镜像加载到SDRAM中</li>
<li>验证BL2镜像合法性</li>
<li>跳转到BL2镜像所在的地址上</li>
</ul>
</li>
</ul>
<h4 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h4><ul>
<li>运行在SDRAM上</li>
<li>BL2代码在BL1段被加载到SDRAM中</li>
<li>BL2就是传统意义上的bootloader，主要负责加载OS和启动OS</li>
</ul>
<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082025672.png"></p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0x0000_0000</strong></td>
<td><strong>0x1FFF_FFFF</strong></td>
<td><strong>512MB</strong></td>
<td><strong>Boot area（取决于启动模式）</strong></td>
</tr>
<tr>
<td><strong>0x2000_0000</strong></td>
<td><strong>0x3FFF_FFFF</strong></td>
<td><strong>512MB</strong></td>
<td><strong>DRAM 0</strong></td>
</tr>
<tr>
<td><strong>0x4000_0000</strong></td>
<td><strong>0x7FFF_FFFF</strong></td>
<td><strong>1024MB</strong></td>
<td><strong>DRAM 1</strong></td>
</tr>
<tr>
<td>0x8000_0000</td>
<td>0x87FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 0</td>
</tr>
<tr>
<td>0x8800_0000</td>
<td>0x8FFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 1</td>
</tr>
<tr>
<td>0x9000_0000</td>
<td>0x97FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 2</td>
</tr>
<tr>
<td>0x9800_0000</td>
<td>0x9FFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 3</td>
</tr>
<tr>
<td>0xA000_0000</td>
<td>0xA7FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 4</td>
</tr>
<tr>
<td>0xA800_0000</td>
<td>0xAFFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 5</td>
</tr>
<tr>
<td>0xB000_0000</td>
<td>0xBFFF_FFFF</td>
<td>256MB</td>
<td>OneNAND/NAND Controller and SFR</td>
</tr>
<tr>
<td>0xC000_0000</td>
<td>0xCFFF_FFFF</td>
<td>256MB</td>
<td>MP3_SRAM output buffer</td>
</tr>
<tr>
<td><strong>0xD000_0000</strong></td>
<td><strong>0xD000_FFFF</strong></td>
<td><strong>64KB</strong></td>
<td><strong>IROM</strong></td>
</tr>
<tr>
<td>0xD001_0000</td>
<td>0xD001_FFFF</td>
<td>64KB</td>
<td>Reserved</td>
</tr>
<tr>
<td><strong>0xD002_0000</strong></td>
<td><strong>0xD003_7FFF</strong></td>
<td><strong>96KB</strong></td>
<td><strong>IRAM</strong></td>
</tr>
<tr>
<td>0xD800_0000</td>
<td>0xDFFF_FFFF</td>
<td>128MB</td>
<td>DMZ ROM</td>
</tr>
<tr>
<td>0xE000_0000</td>
<td>0xFFFF_FFFF</td>
<td>512MB</td>
<td>SFR region</td>
</tr>
</tbody></table>
<p>s5pv210芯片上电之后，CPU会直接从0x0地址取指令，也就是直接运行BL0。</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x0000_0000</td>
<td>0x0000_FFFF</td>
<td>64KB</td>
<td>Internal ROM</td>
</tr>
</tbody></table>
<p>BL1运行在IRAM中，IRAM空间如下</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0xD002_0000</td>
<td>0xD003_7FFF</td>
<td>96KB</td>
<td>IRAM</td>
</tr>
</tbody></table>
<p>但需注意：BL1运行在IRAM上，但并不意味着就从0xD002_0000开始。其实0xD002_0000开头的16B被用做BL1的header，BL1真正是从<strong>0xD002_0010</strong>开始运行的。前16字节被用来验证BL1镜像的完整性，其格式如下：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0xD002_0000</td>
<td>BL1镜像包括header的长度</td>
</tr>
<tr>
<td>0xD002_0004</td>
<td>保留，设置为0</td>
</tr>
<tr>
<td>0xD002_0008</td>
<td>BL1镜像除去header的校验和</td>
</tr>
<tr>
<td>0xD002_000c</td>
<td>保留，设置为0</td>
</tr>
</tbody></table>
<p>BL2运行地址在SDRAM中， smart210使用的是DRAM0，所以地址为</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x2000_0000</td>
<td>0x3FFF_FFFF</td>
<td>512MB</td>
<td>DRAM 0</td>
</tr>
</tbody></table>
<h2 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h2><p>由以上可知，上电后首先运行BL0阶段（BL0段代码起始地址为<code>0</code>）。</p>
<p>BL0 阶段运行的代码为IROM中自带的，其主要功能为 初始化系统时钟、特殊设备控制器、启动设备、看门狗、SRAM等，验证BL1镜像是否完整（<code>0xD002_0000</code>处存在长度和校验）然后跳转到BL1处（<code>0xD002_0010</code>）执行。</p>
<p>BL1 阶段运行在IRAM中，其主要功能是初始化部分时钟和DDR，拷贝BL2段代码到SDRAM中，验证BL2并跳转执行。</p>
<blockquote>
<p>那么，BL1段代码是怎么被拷贝到SRAM中的？</p>
<p>答：在BL0段将BL1的代码拷贝到SRAM中（参考<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code> 中 <code>2.2 iROM(BL0) boot-up sequence (Refer 2.3 V210 boot-up diagram)</code>），由于BL0三星不开源，所以我我们只能按照三星的要求存放BL1的位置（参考<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code> 中<code>2.8 Boot Block Assignment Guide</code>），如果从SD卡启动，也即从SD卡的第<code>1</code>个块开始；如果从NAND Flash启动，就放到Flash中的<code>0</code>块处。拷贝多少呢？这个不知道，有人说是<code>16k</code>也有人说是<code>8k</code>，尽可能将BL1的代码控制在<code>8K</code>以内。</p>
</blockquote>
<p>BL2 阶段运行在SDRAM中，就是传统意义上的bootloader，主要负责加载OS和启动OS</p>
<p>u-boot代码中有两部分：u-boot-spl、u-boot，其中u-boot-spl与芯片启动流程中的BL1对应、u-boot与BL2对应。</p>
<p>那么问题来了，u-boot-spl是如何生成的？u-boot又是怎么生成的?</p>
<p>spl的编译时编译uboot的一部分，和uboot.bin走的是两条编译流程。</p>
<p>一般来说，会先编译主体uboot，也就是uboot.bin，在编译uboot-spl，也就是uboot-spl.bin，两个流程。</p>
<p>编译成功后有几个文件名需要注意下，</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>u-boot-spl</td>
<td>初步链接后得到的spl文件</td>
</tr>
<tr>
<td>u-boot-spl-nodtb.bin</td>
<td>在u-boot-spl的基础上，经过objcopy去除符号表信息之后的可执行程序</td>
</tr>
<tr>
<td>u-boot-spl.bin</td>
<td>在不需要dtb的情况下，直接由u-boot-spl-nodtb.bin复制而来，也就是编译spl的最终目标</td>
</tr>
<tr>
<td>smart210-spl.bin</td>
<td>由s5pv210平台决定，需要在u-boot-spl.bin的基础上加上16B的header用作校验</td>
</tr>
<tr>
<td>u-boot-spl.lds</td>
<td>spl的连接脚本</td>
</tr>
<tr>
<td>u-boot-spl.map</td>
<td>连接之后的符号表文件</td>
</tr>
<tr>
<td>u-boot-spl.cfg</td>
<td>由spl配置生成的文件</td>
</tr>
</tbody></table>
<p><strong>框架</strong></p>
<blockquote>
<p>一般情况下，u-boot采用”board–&gt;machine–&gt;arch–&gt;cpu”框架，如图：</p>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201605/29bd3da4b061810a74093c33d3292b4320160519144243.gif"></p>
</blockquote>
<blockquote>
<p>基于这个架构，u-boot和平台有关的初始化流程就很清晰了。</p>
<ol>
<li>u-boot 启动后，会先执行CPU（如armv8）的初始化代码</li>
<li>CPU相关的代码， 会调用ARCH的公共代码（如arch/arm）</li>
<li>ARCH的公共代码，在适当的时候，调用board有关的接口。u-boot的功能逻辑，大多是由common代码实现，部分和平台有关的部分，则由公共代码声明，由board代码实现。</li>
<li>board代码在需要的时候，会调用machine(arch/arm/mach-xxx)提供的接口，实现特定的功能。因此machine的定位是提供一些基础的代码支持，不会直接参与到u-boot的逻辑功能中去。</li>
</ol>
</blockquote>
<p>由此可知，当u-boot上电后，首先执行的是CPU的初始化代码。板卡型号为smart210，CPU型号为s5pv210，armv7指令集。</p>
<p>通过 <code>u-boot-spl.lds</code>（<code>arch/arm/cpu/u-boot-spl.lds</code>） 和 <code>u-boot.lds</code>（arch/arm/cpu/u-boot.lds） 中 <code>ENTRY(_start)</code>可知，不管是u-boot-spl还是u-boot都是从<code>_start</code>开始的。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先解决编译问题，其次是分析代码，在分析代码的过程中遇到不会的指令和寄存器及时记录下来，防止下次还是不会。</p>
<h3 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h3><h4 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h4><p>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</p>
<p>dirname: missing operand</p>
<p>具体如下</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">glj0@glj0-ubuntu21:~/worksapce/os/smart210/u-boot-2014.04$ ./make.sh </span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">Configuring <span class="keyword">for</span> smart210 board...</span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">  GEN     include/autoconf.mk.dep</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">  GEN     include/autoconf.mk</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">  CHK     include/config/uboot.release</span><br><span class="line">  CHK     include/generated/timestamp_autogenerated.h</span><br><span class="line">  UPD     include/generated/timestamp_autogenerated.h</span><br><span class="line">  UPD     include/config/uboot.release</span><br><span class="line">  HOSTCC  scripts/basic/fixdep</span><br><span class="line">  CHK     include/generated/version_autogenerated.h</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-ld: not found</span><br><span class="line">  UPD     include/generated/version_autogenerated.h</span><br><span class="line">  CC      lib/asm-offsets.s</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">make[1]: *** [/home/glj0/worksapce/os/smart210/u-boot-2014.04/./Kbuild:35: lib/asm-offsets.s] Error 127</span><br><span class="line">make[1]: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>....</span><br><span class="line">  CC      arch/arm/lib/asm-offsets.s</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">make[1]: *** [/home/glj0/worksapce/os/smart210/u-boot-2014.04/./Kbuild:84: arch/arm/lib/asm-offsets.s] Error 127</span><br><span class="line">make: *** [Makefile:999: prepare0] Error 2</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>缺少32位库，安装就可以了。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgl1-mesa-dri:i386</span><br></pre></td></tr></tbody></table></figure>



<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><blockquote>
<p>32位处理器能同时处理32位的数据，所以对应寄存器为32位的</p>
<p>64位处理器能同时处理32位的数据，所以对应寄存器为64位的</p>
<p>ARM处理器用到的指令集分为ARM 和 THUMB两种。</p>
<p>ARM指令集长度固定为32bit，THUMB指令集长度固定为16bit。ARM64指令集长度也是32bit。</p>
</blockquote>
<table>
<thead>
<tr>
<th>类别</th>
<th>寄存器</th>
<th>APCS(ARM 过程调用标准)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>通用寄存器/不分组寄存器</td>
<td>r0</td>
<td>a1</td>
<td>用作传入函数参数，传出函数返回值。在子程序调用之间，可以将r0-r3用于任何用途</td>
</tr>
<tr>
<td></td>
<td>r1</td>
<td>a2</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r2</td>
<td>a3</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r3</td>
<td>a4</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r4</td>
<td>v1</td>
<td><strong>存放函数的局部变量</strong>如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值</td>
</tr>
<tr>
<td></td>
<td>r5</td>
<td>v2</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r6</td>
<td>v3</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r7</td>
<td>v4</td>
<td>同上</td>
</tr>
<tr>
<td>通用寄存器/分组寄存器</td>
<td>r8</td>
<td>v5</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r9</td>
<td>v6</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r10</td>
<td>sl (stack limit)</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r11</td>
<td>fp ()</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r12</td>
<td>ip (intra-prpcedure-call scratch regiser)</td>
<td>内部调用暂时寄存器。</td>
</tr>
<tr>
<td></td>
<td>r13</td>
<td>sp (stack pointer)</td>
<td>栈指针sp，存放的值在退出被调用函数时必须与进入时的值相同。</td>
</tr>
<tr>
<td></td>
<td>r14</td>
<td>lr (link register)</td>
<td>通常被用作子程序链接寄存器，也称lr,指向函数的返回地址。通常用来保存子程序执行的下一条指令。</td>
</tr>
<tr>
<td>通用寄存器/程序计数器</td>
<td>r15</td>
<td>pc (program counter)</td>
<td>程序计数器，保留下一条CPU即将执行的指令。不能用于其它用途。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>程序状态字寄存器</td>
<td>cpsr</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>spsr</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>协处理器</td>
<td>cp15</td>
<td></td>
<td>在基于ARM的嵌入式应用系统中，存储系统的操作通常是由协处理器CP15完成的。CP15包含16个32位的寄存器，其编号为0～15。</td>
</tr>
</tbody></table>
<p><strong>CP15</strong>的寄存器列表如表所示：</p>
<table>
<thead>
<tr>
<th>寄存器编号</th>
<th>基本作用</th>
<th>在MMU中的作用</th>
<th>在PU中的作用</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ID 编码（只读）</td>
<td>ID 编码和 cache 类型</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>控制位（可读写）</td>
<td>各种控制位</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>存储保护和控制</td>
<td>地址转换表基地址</td>
<td>Cachability 的控制位</td>
</tr>
<tr>
<td>3</td>
<td>存储保护和控制</td>
<td>域访问控制位</td>
<td>Bufferablity 控制位</td>
</tr>
<tr>
<td>4</td>
<td>存储保护和控制</td>
<td>保留</td>
<td>保留</td>
</tr>
<tr>
<td>5</td>
<td>存储保护和控制</td>
<td>内存失效状态</td>
<td>访问权限控制位</td>
</tr>
<tr>
<td>6</td>
<td>存储保护和控制</td>
<td>内存失效地址</td>
<td>保护区域控制</td>
</tr>
<tr>
<td>7</td>
<td>高速缓存和写缓存</td>
<td>高速缓存和写缓存控制</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>存储保护和控制</td>
<td>TLB 控制</td>
<td>保留</td>
</tr>
<tr>
<td>9</td>
<td>高速缓存和写缓存</td>
<td>高速缓存锁定</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>存储保护和控制</td>
<td>TLB 锁定</td>
<td>保留</td>
</tr>
<tr>
<td>11</td>
<td>保留</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>保留</td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>进程标识符</td>
<td>进程标识符</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>保留</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>因不同设计而异</td>
<td>因不同设计而异</td>
<td>因不同设计而异</td>
</tr>
</tbody></table>
<h3 id="negative-squared-cross-mark-指令"><a href="#negative-squared-cross-mark-指令" class="headerlink" title=":negative_squared_cross_mark:指令"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>指令</h3><p><strong>指令集二进制编码</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204271909384.png"></p>
<p><strong>条件码</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131656507.png"></p>
<p><strong>指令</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>指令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>条件（有符号数）</td>
<td>GE</td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LE</td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>GT</td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LT</td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td>条件（用于无符号数）</td>
<td>HS</td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LS</td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HI</td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LO</td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>STR{cond} 源寄存器，&lt;存储器地址&gt;</td>
<td>从源寄存器中将一个32位的字数据传送到存储器中</td>
<td><code>STR r1, [r0]</code>将r1里面值复制到以r0里面的值作为地址的内存中</td>
</tr>
<tr>
<td></td>
<td>STRLO 源寄存器，&lt;存储器地址&gt;</td>
<td>当满足条件小于时，从源寄存器中将一个32位的字数据传送到存储器中</td>
<td><code>CMP r0，r1;STRLO r2，[r0];</code> 首先r0=r0-r1,当满足条件r0&lt;r1时，将r2中的值复制到以r0里面的值作为地址的内存中。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>地址读取伪指令</td>
<td>ADR{cond}目的寄存器，相对地址或标签</td>
<td>将基于PC相对偏移的地址值或基于寄存器相对地址值传送到目的寄存器中（小范围）</td>
<td><code>ADR r0, here;here: ....</code>将标签here处的相对地址传递给寄存器r0</td>
</tr>
<tr>
<td></td>
<td>LDR{cond}目的寄存器，&lt;存储器地址&gt;</td>
<td>从存储器中将一个32位的字数据传送到目的寄存器中（大范围）</td>
<td><code>LDR r0, [r1]</code>将r1里面的值作为地址，将地址里面的值复制给寄存器r0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>跳转指令</td>
<td>B{cond} 目标地址</td>
<td>跳转指令</td>
<td><code>B Label</code>程序无条件跳转到标号Label处执行</td>
</tr>
<tr>
<td></td>
<td>BL{cond} 目标地址</td>
<td>带返回的跳转指令（跳转之前，将PC内容存到R14中）</td>
<td><code>BL Label</code>程序将当前PC值存到R14中，程序无条件跳转至标号Label中执行</td>
</tr>
<tr>
<td></td>
<td>BX{cond} Rm</td>
<td>带状态切换的跳转指令，最低位为1时，切换到Thumb指令执行，为0时，解释为ARM指令执行（最低位指的是Rm的第0位）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>BLX</td>
<td>带返回和状态切换的跳转指令</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>算术运算指令</td>
<td>SUB 寄存器1，寄存器2，寄存器3</td>
<td>寄存器1=寄存器2-寄存器3</td>
<td><code>SUB r0，r1,#1</code> r0=r1-1</td>
</tr>
<tr>
<td></td>
<td>SUBS 寄存器1，寄存器2，寄存器3</td>
<td>寄存器1=寄存器2-寄存器3;S表示并将进位结果写到CPSR中</td>
<td><code>SUBS r0，r1,#1</code> r0=r1-1，并将进位结果写道CPSR</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>CMP 寄存器1，寄存器2</td>
<td>寄存器1=寄存器1-寄存器2</td>
<td><code>CMP r0，r1</code> 也就是<code>r0=r0-r1</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>多数据传输条件</td>
<td>IA（Increase After）</td>
<td>每次传送后地址加4,其中的寄存器<strong>从左到右执行</strong>,例如:STMIA R0,{R1,LR} 先存R1,再存LR</td>
<td></td>
</tr>
<tr>
<td></td>
<td>IB（Increase Before）</td>
<td>每次传送前地址加4,同上</td>
<td></td>
</tr>
<tr>
<td></td>
<td>DA（Decrease After）</td>
<td>每次传送后地址减4,其中的寄存器<strong>从右到左执行</strong>,例如:STMDA R0,{R1,LR} 先存LR,再存R1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>DB（Decrease Before）</td>
<td>每次传送前地址减4,同上</td>
<td></td>
</tr>
<tr>
<td></td>
<td>FD</td>
<td>满递减堆栈 (每次传送前地址减4)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>FA</td>
<td>满递增堆栈 (每次传送后地址减4)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ED</td>
<td>空递减堆栈 (每次传送前地址加4)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>EA</td>
<td>空递增堆栈 (每次传送后地址加4)</td>
<td></td>
</tr>
<tr>
<td>多数据传输（加载）</td>
<td>LDM{cond} Rn{!},reglist{^}</td>
<td>多数据加载，将地址上的值加载到寄存器中。Rn：基址寄存器，装有传送数据的起始地址，Rn不允许为R15；！：表示最后的地址写回到Rn中；reglist：可包含多于一个寄存器范围，用“，”隔开，如{R1，R2，R6-R9}，寄存器由小到大顺序排列；^：不允许在用户模式和系统模式下运行</td>
<td><code>LDR R0,=0x100000;LDMIA R0!,{R1-R8}</code>也就是从左往右加载，首先将0x100000中的数据加载到R1,然后R0=R0+4，然后将0x1000004中的数据加载到R2,然后R0=R0+4….</td>
</tr>
<tr>
<td>多数据传输（存储）</td>
<td>STM{cond} mode Rn{!}, reglist{^}</td>
<td>多数据存储，将寄存器的值存到地址上。同上</td>
<td></td>
</tr>
<tr>
<td>协处理器CP15操作</td>
<td>MRC{cond} p15,<opcode1>,<rd>,<crn>,<crm>,<opcode2></opcode2></crm></crn></rd></opcode1></td>
<td>协处理器寄存器到ARM处理器寄存器的数据传送指令（读出协处理器寄存器）。cond为指令执行条件码，当忽略时无条件执行。Opcode1:协处理器的特性操作码，对于CP15来说，其为0。Rd：源寄存器的ARM寄存器，其值被传送到协处理器中或者将协处理器的值传送到该寄存器中。CRn:目标寄存器的的协处理器寄存器，C~C15。CRm：协处理器中附件的目标寄存器或源操作数寄存器，默认为c0。Opcode2：可选的协处理器特定操作码。</td>
<td><code>mrc p15, 0, r0, c1, c0, 0</code>                将CP15的寄存器C1的值读到r0中</td>
</tr>
<tr>
<td></td>
<td>MCR{cond} p15,<opcode1>,<rd>,<crn>,<crm>,<opcode2></opcode2></crm></crn></rd></opcode1></td>
<td>ARM处理器寄存器到协处理器寄存器的数据传送指令（写入协处理器寄存器）</td>
<td><code>mcr p15, 0, r0, c7, c7, 0</code>            关闭ICaches和DCachesmcr <br><code>p15, 0, r0, c8, c7, 0</code>                 使无效整个数据TLB和指令TLB</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>.globl</td>
<td>伪指令，声明一个全局变量</td>
<td><code>.globl _start</code>声明_start，下面调用时才不会出现链接错误。类似c语言中的extern。</td>
</tr>
</tbody></table>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="x-2022中的-start不看"><a href="#x-2022中的-start不看" class="headerlink" title=":x:2022中的_start不看"></a><span class="github-emoji"><span>❌</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><del>2022中的_start不看</del></h4><p><del>所以首先会执行armv7中的start.S代码，但是呢，通过代码，我们没有发现start.S中有 <code>_start</code>相关的定义，而且也没有一些向量表的处理，这就很奇怪了，代码放哪呢了呢？没有<code>_start</code>又要怎么启动呢？带着问题，我们接着往下走。</del></p>
<p>由于我们的代码是最新的，但有印象在2014版本中是有这一部分的，所以我们直接去查找git上这个文件的history</p>
<p>于是有了找到了以下</p>
<p><a target="_blank" rel="noopener" href="https://source.denx.de/u-boot/u-boot/-/commit/41623c91b09a0c865fab41acdaff30f060f29ad6">https://source.denx.de/u-boot/u-boot/-/commit/41623c91b09a0c865fab41acdaff30f060f29ad6</a></p>
<p>在这个链接右上角可以看到，删除了2426行，新增了313行。看了下发现删除的都是 下面这种代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start: b    reset </span><br><span class="line">...</span><br><span class="line">	.balignl 16,0xdeadbeef</span><br></pre></td></tr></tbody></table></figure>

<p>那这些代码去哪了呢？</p>
<p>接着搜索armv7，发现也是这种代码被删除。</p>
<p>接着走，看看新增了什么，在u-boot-spl.lds和u-boot.lds中 代码中新增了一个 *(vectors)并且位置比start.o靠前，什么意思？中断向量表存到这个地方了嘛？是的，接着往下看，一切都会真相大白</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203291016583.png"></p>
<p>终于看到vector.S了，这部分代码是存在 arch/arm/lib下，有没有发现很熟悉，没错，就是上面删掉的代码，而且 <code>.global _start</code>也在这，由此可以猜测，<strong>开发人员将各个处理器的公共代码抽离，最终以vector.S体现</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203291030263.png"></p>
<p>借助 u-boot.lds（arch/arm/cpu/u-boot.lds）可知，<code>ENTRY(_start)</code>，整个u-boot的开始依然是<code>_start</code>，由以上分析可知，<code>_start</code>在vectors.S中定义，所以整个U-boot的入口为vector.S中的<code>_start</code>，接着 ARM_VECTORS 是一个宏，展开就是 <code>.macro/.endm</code>之间包裹的。接着往下走，就会走入<code>b reset</code>，调用reset。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* arch/arm/lib/vectors.S */</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">	.section ".vectors", "ax"</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)</span><br><span class="line">#include &lt;asm/arch/boot0.h&gt;</span><br><span class="line">#else   /*走这个分支 (怎么确认的呢？在此处随便加个乱七八糟的字符，然后编译，如果编译过，则说明走的不是此分支)*/</span><br><span class="line">_start: /*U-boot程序入口*/</span><br><span class="line">#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">	.word	CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">#endif</span><br><span class="line">	ARM_VECTORS /* 一个宏*/</span><br><span class="line">#endif /* !defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) */</span><br><span class="line">	/* 在.macro 和 .endm 中的为*/</span><br><span class="line">    .macro ARM_VECTORS</span><br><span class="line">#ifdef CONFIG_ARCH_K3</span><br><span class="line">	ldr     pc, _reset</span><br><span class="line">#else</span><br><span class="line">	b	reset	// 走这个分支</span><br><span class="line">#endif</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>reset标签在哪呢？<code>arch/arm/cpu/armv7/start.S</code>中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* arch/arm/cpu/armv7/start.S */</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	/* Allow the board to save important registers */</span><br><span class="line">	b	save_boot_params</span><br><span class="line">save_boot_params_ret:</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,</span><br><span class="line"> * except if in HYP mode already</span><br><span class="line"> * 禁用中断，同时设置CPU模式，除非已经处于HYP模式下</span><br><span class="line"> */</span><br><span class="line">    mrs		r0, cpsr			;读取寄存器cpsr中的值，并保存到r0寄存器中。</span><br><span class="line">    and		r1, r0, #0x1f		@ mask mode bits</span><br><span class="line">    teq		r1, 	#0x1a		@ test for HYP mode</span><br><span class="line">    bicne	r0, r0, #0x1f		@ clear all mode bits</span><br><span class="line">    orrne	r0, r0, #0x13		@ set SVC mode</span><br><span class="line">    orr		r0, r0, #0xc0		@ disable FIQ and IRQ</span><br><span class="line">    msr		cpsr,r0</span><br><span class="line"></span><br><span class="line">ENTRY(save_boot_params)</span><br><span class="line">	b	save_boot_params_ret		@ back to my caller</span><br><span class="line">ENDPROC(save_boot_params)</span><br></pre></td></tr></tbody></table></figure>

<p><code>mrs        r0, cpsr</code> ;读取寄存器cpsr中的值，并保存到r0寄存器中。</p>
<p><code>and        r1, r0, #0x1f</code>寄存器r0中的值与0X1F进行与运算，结果保存到r1寄存器中，目的就是提取cpsr的bit0~bit4这5位，这5位为M4 M3 M2 M1 M0，M[4:0]这五位用来设置处理器的工作模式</p>
<p>以上为 u-boot-2022.04中的内容</p>
<hr>
<h4 id="代码函数调用图"><a href="#代码函数调用图" class="headerlink" title="代码函数调用图"></a><strong>代码函数调用图</strong></h4><p><a target="_blank" rel="noopener" href="https://www.zhixi.com/view/18da9b99">https://www.zhixi.com/view/18da9b99</a></p>
<h4 id="start"><a href="#start" class="headerlink" title="_start"></a>_start</h4><p>由于我们的处理器使用的指令集为armv7，所以**_start**的路径为<code>arch/arm/cpu/armv7/start.S</code></p>
<p>其实对于u-boot的<code>start.S</code>，主要做的几件事就是系统各方面的初始化。</p>
<p>从大的方面分，可分为以下部分</p>
<ul>
<li><p>设置 CPU 模式</p>
</li>
<li><p>关闭看门狗</p>
</li>
<li><p>关闭中断</p>
</li>
<li><p>设置堆栈 sp 指针</p>
</li>
<li><p>清除 bss 段</p>
</li>
<li><p>异常中断处理</p>
</li>
</ul>
<p>接着我们看代码，</p>
<p><code>.globl _start</code> 声明<code>_start</code>标号对全局可见，类似于c语言中的<code>extern</code></p>
<p><code>_start: b    reset</code> <code>_start</code>后加一个冒号，表示其实一个Label。而同时<code>_start</code>的值，也就是代码的最开始的位置，相对是<code>0</code>。在u-boot-spl中其地址是<code>0</code>，在u-boot中，由于经过了relocate之后，代码的运行地址是我们定义的基地址（也就是重定位后的偏移地址<code>gd-&gt;relocaddr</code>）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">.globl _start   				/* .globl指示告诉汇编器，_start是一个全局符号*/</span><br><span class="line">_start: b	reset				/* 跳转到reset符号处*/</span><br><span class="line">	ldr	pc, _undefined_instruction	/* 未定义指令异常*/</span><br><span class="line">	ldr	pc, _software_interrupt		/* 软中断，Linux系统调用*/</span><br><span class="line">	ldr	pc, _prefetch_abort		/* 预取址中止，取不到下一条指令*/</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq			/* 中断*/</span><br><span class="line">	ldr	pc, _fiq			/* 快中断*/</span><br><span class="line">...</span><br><span class="line">reset:</span><br><span class="line">        bl	save_boot_params       //跳转到save_boot_params符号处</span><br><span class="line">	/*</span><br><span class="line">	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,</span><br><span class="line">	 * except if in HYP mode already</span><br><span class="line">	 */</span><br><span class="line">        mrs		r0, cpsr			//将cpsr寄存器的值读到r0中</span><br><span class="line">        and		r1, r0, #0x1f		 @ mask mode bits</span><br><span class="line">        teq		 r1,      #0x1a		    @ test for HYP mode</span><br><span class="line">        bicne	 r0, r0, #0x1f		   @ clear all mode bits  </span><br><span class="line">        orrne	 r0, r0, #0x13		  @ set SVC mode 			//更改处理器模式为SVC模式</span><br><span class="line">        orr		 r0, r0, #0xc0		  @ disable FIQ and IRQ	//将I、F位（7、6位）置1 也即0xc0，关闭快中断和中断</span><br><span class="line">        msr	cpsr,r0				      //将r0的内容写入cpsr寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY(save_boot_params)</span><br><span class="line">	bx	lr			@ back to my caller</span><br><span class="line">ENDPROC(save_boot_params)</span><br><span class="line">	.weak	save_boot_params</span><br></pre></td></tr></tbody></table></figure>

<p>这一段，首先会跳转到 <strong>save_boot_params</strong> 标号处，而 <code>ENTRY(save_boot_params)</code> 表示 <code>save_boot_params</code> 入口，进入后就一句 <code>bx lr</code>，其作用为 跳转到 <code>lr</code> 中存放的地址处。而<code>lr</code>的用途：当通过BL或者BLX调用<strong>子程序</strong>时，硬件将自动将子程序返回地址保存在R14寄存器中，在子程序返回时，把LR的值复制到程序计数器就可以实现子程序返回。所以这段代码的意思就是跳转到调用者处。也就是接着执行<code>bl save_boot_params</code>后面的代码。</p>
<p><code>mrs    r0, cpsr</code>读取寄存器cpsr中的值，并保存到<code>r0</code>寄存器中。</p>
<p><code>and    r1, r0, #0x1f</code>寄存器<code>r0</code>中的值与<code>0X1F</code>进行与运算，结果保存到<code>r1</code>寄存器中，目的就是提取<code>cpsr</code>的bit0~bit4这5位，这5位为M4 M3 M2 M1 M0，M[4:0]这五位用来设置处理器的工作模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101725592.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101726017.png"></p>
<p>如果<code>r1</code>和<code>0X1A(0b11010)</code>不相等，也就是CPU不处于Hyp模式的话就将<code>r0</code>寄存器的bit0~5进行清零，其实就是清除模式位。</p>
<p>如果处理器不处于Hyp模式的话就将r0的寄存器的值与<code>0x13</code>进行或运算，<code>0x13(0b10011)</code>，也就是设置处理器进入管理模式（SVC）。</p>
<p><code>r0</code>寄存器的值再与<code>0xC0(0b1100_0000)</code>进行或运算，那么r0寄存器此时的值就是<code>0xD3(0b1101_0000)</code>，cpsr的I位和F位分别控制IRQ和FIQ这两个中断的开关，设置为1就关闭了FIQ和IRQ！</p>
<p>将<code>r0</code>寄存器写回到<code>cpsr</code>寄存器中。完成设置CPU处于SVC32模式，并且关闭FIQ和IRQ这两个中断。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">/*</span><br><span class="line"> * Setup vector:</span><br><span class="line"> * (OMAP4 spl TEXT_BASE is not 32 byte aligned.</span><br><span class="line"> * Continue to use ROM code vector only in OMAP4 spl)</span><br><span class="line"> */</span><br><span class="line">#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))</span><br><span class="line">	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register</span><br><span class="line">	bic	r0, #CR_V		@ V = 0</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register</span><br><span class="line"></span><br><span class="line">	/* Set vector address in CP15 VBAR register */</span><br><span class="line">	ldr	r0, =_start</span><br><span class="line">	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p>这部分代码通过对协处理器CP15进行操作，设置了处理器的异常向量入口地址为<code>_start</code>。</p>
<p>这是因为ARM默认的异常向量表入口在0x0地址，然而S5PV210中0x0地址存放的是IROM，不可修改，自然不可能存放异常向量表，所以需要修改异常向量表入口，将它们映射到其他位置上去。</p>
<p>接着是三个跳转，每个跳转后都会返回到当前位置的下一条地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">	/* the mask ROM code should have PLL and others stable */</span><br><span class="line">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span><br><span class="line">	bl	cpu_init_cp15</span><br><span class="line">	bl	cpu_init_crit</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	bl	_main</span><br></pre></td></tr></tbody></table></figure>



<h4 id="cpu-init-cp15"><a href="#cpu-init-cp15" class="headerlink" title="cpu_init_cp15"></a>cpu_init_cp15</h4><p>首先跳转到 <strong>cpu_init_cp15</strong> 中，我们可以看到在<code>ENDPROC(cpu_init_cp15)</code>之前，有一条 <code>mov pc, lr</code>，此命令作用和<code>bx lr</code>相同，跳转回子函数调用的地方。在 <code>cpu_init_cp15</code> 中，主要是失效L1、I/D、关闭 MMU 等</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(cpu_init_cp15)</span><br><span class="line">	...</span><br><span class="line">	mov	pc, lr			@ back to my caller //子过程运行结束，跳转回去</span><br><span class="line">ENDPROC(cpu_init_cp15)</span><br></pre></td></tr></tbody></table></figure>



<h4 id="cpu-init-crit"><a href="#cpu-init-crit" class="headerlink" title="cpu_init_crit"></a>cpu_init_crit</h4><p>接着跳转到 <strong>cpu_init_crit</strong> 中，里面又一个跳转 <code>lowlevel_init</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(cpu_init_crit)</span><br><span class="line">	b	lowlevel_init		@ go setup pll,mux,memory</span><br><span class="line">ENDPROC(cpu_init_crit)</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h4 id="x-lowlevel-init-分析错误"><a href="#x-lowlevel-init-分析错误" class="headerlink" title=":x:lowlevel_init(分析错误)"></a><span class="github-emoji"><span>❌</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><del>lowlevel_init(分析错误)</del></h4><p><strong>注意：以下分析错误，请直接看下一个 lowlevel_init</strong> </p>
<p><del><strong>lowlevel_init</strong> 位于 <code>arch/arm/cpu/armv7/lowlevel_init.S</code></del>，主要是设置栈顶指针为 CONFIG_SYS_INIT_SP_ADDR ，然后栈顶指针8字节对齐。如果在SPL，设置r9数据为 gdata 地址，否则为GD数据分配空间，并将分配后的栈顶指针给r9。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(lowlevel_init)</span><br><span class="line">	/*</span><br><span class="line">	 * Setup a temporary stack</span><br><span class="line">	 */</span><br><span class="line">	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR</span><br><span class="line">	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */</span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">	ldr	r9, =gdata</span><br><span class="line">#else</span><br><span class="line">	sub	sp, sp, #GD_SIZE</span><br><span class="line">	bic	sp, sp, #7</span><br><span class="line">	mov	r9, sp</span><br><span class="line">#endif</span><br><span class="line">	/*</span><br><span class="line">	 * Save the old lr(passed in ip) and the current lr to stack</span><br><span class="line">	 */</span><br><span class="line">	push	{ip, lr}</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * go setup pll, mux, memory</span><br><span class="line">	 */</span><br><span class="line">	bl	s_init</span><br><span class="line">	pop	{ip, pc}</span><br><span class="line">ENDPROC(lowlevel_init)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>CONFIG_SYS_INIT_SP_ADDR</strong> 在 <code>include/configs/smart210.h</code>，也就是说设置栈顶指针为SDRAM结束的高地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR + PHYS_SDRAM_1_SIZE)</span><br><span class="line">...</span><br><span class="line">#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE</span><br><span class="line">...</span><br><span class="line">/* DRAM Base */</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br><span class="line">...</span><br><span class="line">#define PHYS_SDRAM_1_SIZE	(512 &lt;&lt; 20)				/* 0x2000_0000, 512 MB Bank #1 */</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101814781.png"></p>
<p>其中 gddata 定义在 <code>arch/arm/lib/spl.c</code>中，这里需要补充一个高级用法。具体用法查看 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html</a> ，这里则是将 gdata 位置存放到 .data 段中。</p>
<blockquote>
<p>_<em>attribute</em>_</p>
<p>该关键字允许您指定变量、函数参数或结构体、联合体以及类成员的特殊属性</p>
<p>而 _<em>attribute</em>_ ((section(“.data”))) </p>
<p>则说明将 前者定义的放入<code>.data</code>段中</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pointer to as well as the global data structure for SPL */</span></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"><span class="keyword">gd_t</span> gdata __attribute__ ((section(<span class="string">".data"</span>)));</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 在 arch/arm/include/asm/global_data.h 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm (<span class="meta-string">"r9"</span>)</span></span><br></pre></td></tr></tbody></table></figure>

<p>此时需要注意下 DECLARE_GLOBAL_DATA_PTR 这个宏，这个宏的意思是定义了全局数据结构gd（<strong>寄存器r9来表示全局数据结构gd</strong>）</p>
<p><code>register volatile gd_t *gd asm ("r9")</code> 其中register关键字是必须的，asm (“r9”)为嵌入式汇编，表示用r9寄存器存储gd指针，r9和CPU体系结构相关。寄存器变量。</p>
<p>所以不管 <code>ldr    r9, =gdata</code>还是<code>mov    r9, sp</code>都是更新 gd 的地址，不同的是在SPL下，gd结构体空间被分配在 <code>.data</code>段中，在u-boot中，gd结构体空间被分配在<code>CONFIG_SYS_INIT_SP_ADDR - GD_SIZE</code> （需要8字节对齐）处。</p>
<p>接着往下走，<code>push    {ip, lr}</code>用stack的形式保存<code>lr</code>(返回指针)，将ip和lr入栈</p>
<p>然后一个跳转到<code>bl    s_init</code>中。</p>
<p>下面 <code>pop    {ip, pc}</code> 恢复到<code>ip</code>、<code>pc</code>，意思是改变pc的指向，将lr内容恢复到pc中，也即返回到lr指向的地方，在此处应为<code>bl    cpu_init_crit</code>的下方，也即<code>bl    _main</code>。</p>
<p>接着分析 <code>s_init</code>，在与smart210相关的任何地方找不到与s_init相关的定义，也找不到与s5pv210任何相关的，所以此处应该是有问题的，通过在指令间添加一些异常数据，编译，编译通过，得知在调用 lowlevel_init时并不是找的此处。</p>
<p><strong>以上分析错误，请直接查看下一个 lowlevel_init</strong> </p>
<hr>
<h4 id="lowlevel-init"><a href="#lowlevel-init" class="headerlink" title="lowlevel_init"></a>lowlevel_init</h4><p><strong>lowlevel_init</strong> 位于 <code>board/samsung/smart210/lowlevel_init.S</code> ，这个相对简单，但还是说一下，首先将<code>lr</code>返回地址保存到<code>r9</code>中（此处不应该使用r9，或者说在使用r9前先保存r9的值），如果在SPL下，则需要初始化时钟和ddr，并配置串口寄存器<code>PA0CON</code>值为<code>0x00002222</code>（查看手册 <code>S5PV210_UM_REV1.1.pdf</code>中<code>2.2.2.1 Port Group GPA0 Control Register (GPA0CON, R/W, Address = 0xE020_0000)</code> ），也即配置<code>GPA0CON</code>功能为串口UART1。之后，恢复<code>pc</code>值为<code>lr</code>，返回到调用 <code>lowlevel_init</code> 的地方。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; board/samsung/smart210/lowlevel_init.S</span><br><span class="line"></span><br><span class="line">        .globl lowlevel_init</span><br><span class="line">lowlevel_init:</span><br><span class="line">	mov	r9, lr</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">	bl clock_init                   /* clock init */</span><br><span class="line">	bl ddr_init                     /* DDR init */</span><br><span class="line"></span><br><span class="line">	/* add by Flinn, for uart */</span><br><span class="line">	ldr r0, =0xE0200000     		/* GPA0_CON */</span><br><span class="line">	ldr r1, =0x22222222</span><br><span class="line">	str r1, [r0]</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">	mov pc, r9                		/* return */</span><br></pre></td></tr></tbody></table></figure>



<p>返回到<code>bl cpu_init_crit</code>的下一句指令，也即执行 <code>bl _main</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line"></span><br><span class="line">	/* the mask ROM code should have PLL and others stable */</span><br><span class="line">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span><br><span class="line">	bl	cpu_init_cp15</span><br><span class="line">	bl	cpu_init_crit</span><br><span class="line">#endif</span><br><span class="line">	bl	_main</span><br></pre></td></tr></tbody></table></figure>



<h4 id="main"><a href="#main" class="headerlink" title="_main"></a>_main</h4><p><strong>_main</strong>位于<code>arch/arm/lib/crt0.S</code>中，具体代码一会回来分析。</p>
<p>终于来到<code>_main</code>中了，首先如果定义了<code>CONFIG_SPL_BUILD</code>和<code>CONFIG_SPL_STACK</code>，也即SPL时，sp值为<code>CONFIG_SPL_STACK</code>，但经过验证没有走这个分支；所以sp的值只可能为<code>CONFIG_SYS_INIT_SP_ADDR</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">/*</span><br><span class="line"> * entry point of crt0 sequence</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">ENTRY(_main)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set up initial C runtime environment and call board_init_f(0).</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">	ldr	sp, =(CONFIG_SPL_STACK)</span><br><span class="line">#else</span><br><span class="line">	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line">#endif</span><br><span class="line">	...</span><br><span class="line">ENDPROC(_main)</span><br></pre></td></tr></tbody></table></figure>



<p><strong>CONFIG_SYS_INIT_SP_ADDR</strong> 在 <code>include/configs/smart210.h</code>，也就是说设置栈顶指针为SDRAM结束的高地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* include/configs/smart210.h */</span><br><span class="line">#define CONFIG_SYS_INIT_SP_ADDR		   (CONFIG_SYS_LOAD_ADDR + PHYS_SDRAM_1_SIZE)</span><br><span class="line">...</span><br><span class="line">#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE</span><br><span class="line">...</span><br><span class="line">/* DRAM Base */</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br><span class="line">...</span><br><span class="line">#define PHYS_SDRAM_1_SIZE			 (512 &lt;&lt; 20)				/* 0x2000_0000, 512 MB Bank #1 */</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101814781.png"></p>
<p>接着往下走，是给<code>gd</code>数据结构分配空间。gd是什么？</p>
<blockquote>
<p>gd是一个寄存器变量。此时需要注意下 DECLARE_GLOBAL_DATA_PTR 这个宏，这个宏的意思是定义了全局数据结构gd（<strong>寄存器r9来表示全局数据结构gd</strong>）</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// board/samsung/smart210/smart210.c</span></span><br><span class="line">&gt;DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line">&gt;---------------------------------------------------------------------------------------</span><br><span class="line">&gt;<span class="comment">// arch/arm/include/asm/global_data.h </span></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm (<span class="meta-string">"r9"</span>)</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>register volatile gd_t *gd asm ("r9")</code> 其中<code>register</code>关键字是必须的，<code>asm ("r9")</code>为嵌入式汇编，表示用<code>r9</code>寄存器存储<code>gd</code>指针，<code>r9</code>和CPU体系结构相关。</p>
</blockquote>
<p>先8字节对齐，然后给<code>gd</code>结构分配大小为<code>GD_SIZE</code>的空间，然后继续8字节对齐。<code>GD_SIZE</code>是一个宏，在<code>include/generated/generic-asm-offsets.h</code>中定义为<code>160</code>（<code>sizeof(struct global_data)</code>），该文件也是生成的。</p>
<p>更新<code>r9</code>值为<code>sp</code>，此时<code>r9 = sp = [CONFIG_SYS_INIT_SP_ADDR - GD_SIZE]</code>（<code>[CONFIG_SYS_INIT_SP_ADDR - GD_SIZE]</code>为对应地址处的值），接着给<code>r0</code>清零</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	bic	sp, sp, #7			/* 8-byte alignment for ABI compliance */</span><br><span class="line">	sub	sp, sp, #GD_SIZE	/* allocate one GD above SP */</span><br><span class="line">	bic	sp, sp, #7			/* 8-byte alignment for ABI compliance */</span><br><span class="line">	mov	r9, sp				/* GD is above SP */</span><br><span class="line">	mov	r0, #0</span><br></pre></td></tr></tbody></table></figure>



<p>接着往下走，分为两种情况，第一种SPL下，跳转到 <code>copy_bl2_to_ram</code>（完成BL2阶段镜像校验并拷贝到SDRAM中），执行结束后返回，更改PC指针为<code>CONFIG_SYS_SDRAM_BASE</code>，也即跳转到 BL2阶段（SDRAM中）。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">        bl       copy_bl2_to_ram</span><br><span class="line">        ldr pc,=CONFIG_SYS_SDRAM_BASE</span><br><span class="line">#else</span><br><span class="line">        bl       board_init_f</span><br><span class="line">#endif</span><br><span class="line">-----------------------------------------------</span><br><span class="line">; include/configs/smart210.h</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br></pre></td></tr></tbody></table></figure>



<h4 id="copy-bl2-to-ram"><a href="#copy-bl2-to-ram" class="headerlink" title="copy_bl2_to_ram"></a>copy_bl2_to_ram</h4><p><code>copy_bl2_to_ram</code>函数在 <code>board/samsung/smart210/smart210.c</code> 中</p>
<p>首先是几个宏定义，让我们看一下是什么东东？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从SD/MMC拷贝（加载）块到内存中的函数 </span></span><br><span class="line"><span class="comment">** ch:  通道号</span></span><br><span class="line"><span class="comment">** sb:  起始块号</span></span><br><span class="line"><span class="comment">** bs:  块数量</span></span><br><span class="line"><span class="comment">** dst: 要拷贝到内存的什么位置上</span></span><br><span class="line"><span class="comment">** i:   是否需要初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CopySDMMCtoMem(ch, sb, bs, dst, i) \</span></span><br><span class="line"><span class="meta">        (((u8(*)(int, u32, unsigned short, u32*, u8))\</span></span><br><span class="line"><span class="meta">        (*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_1CON  (*(volatile u32 *)0xE02002E0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_3CON  (*(volatile u32 *)0xE0200320)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_6CON  (*(volatile u32 *)0xE0200380) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF8_ReadPage_Adv(a,b,c) (((int(*)(u32, u32, u8*))(*((u32 *)0xD0037F90)))(a,b,c))</span></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CopySDMMCtoMem(ch, sb, bs, dst, i) \</span></span><br><span class="line"><span class="meta">(((u8(*)(int, u32, unsigned short, u32*, u8))(*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))   </span></span><br></pre></td></tr></tbody></table></figure>

<p>这个宏定义分为三段来看，分别对应着 <strong>函数返回值数据类型 （*指针变量名）（函数的实际参数或者函数参数的类型）</strong><br>第一段：<code>((u8 (*)(int, u32, unsigned short, u32*, u8))</code> 是一个函数类型强制类型转换，其中<code>u8</code>为返回值，<code>(int, u32, unsigned short, u32*, u8)</code>为传入参数类型。<br>第二段：<code>(*((u32 *)0xD0037F98)))</code> ，在地址<code>0xD0037F98</code>中存放了一个名字叫<code>CopySDMMCtoMem</code>的函数，armv7 为32位cpu，所以先转成<strong>指针类型为u32*<strong>，然后再把这个地址</strong>解引用</strong>，就得到了地址中存在的值也就是CopySDMMCtoMem</p>
<p>第三段：将函数的实际参数传入即可<code>(ch, sb, bs, dst, i)</code>，最外层加上一个大括号。</p>
<p>接着三个宏表示 将对<strong>对应地址处的值</strong>操作。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_1CON  (*(volatile u32 *)0xE02002E0) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.25.1*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_3CON  (*(volatile u32 *)0xE0200320) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.27.1*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_6CON  (*(volatile u32 *)0xE0200380) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.30.1*/</span></span></span><br></pre></td></tr></tbody></table></figure>

<p><code>NF8_ReadPage_Adv(a,b,c)</code>与<code>CopySDMMCtoMem(ch, sb, bs, dst, i)</code>一致，不在讲解。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CopySDMMCtoMem(ch, sb, bs, dst, i)</td>
<td>从SD/MMC拷贝（加载）块到内存中的函数 （从通道ch的sb块处，加载bs块内存到以dst起始的地方）</td>
</tr>
<tr>
<td>NF8_ReadPage_Adv(a,b,c)</td>
<td>从nand flash拷贝（加载）页到内存中的函数（a：要复制的源块地址号，b：要复制的源页地址号，c：目标缓冲区指针，返回值成功或失败）</td>
</tr>
</tbody></table>
<p>接着就进入到<code>copy_bl2_to_ram</code>，整个<code>copy_bl2_to_ram</code>框架如下。也就是上来先定义bl2的大小为250k（编译结束后生成u-boot.bin大小为240k），所以此处最好大小调大一些（建议512k）。OM为寄存器<code>0xE0000004</code>中存储的值，通过手册（<code>SIAP</code> 中<code>3 Boot configuration</code>）可知OM低5位控制着从哪里启动，所以下面两个分支也就是选择从哪边启动。0x2（0b0010）也即<code>Nand 2KB,5cycle X-TAL</code>；0xc（0b1100）也即<code>SD/MMC X-TAL</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_bl2_to_ram</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    u32 bl2Size = <span class="number">250</span> * <span class="number">1024</span>;       		  <span class="comment">// 250K</span></span><br><span class="line">    u32 OM = *(<span class="keyword">volatile</span> u32 *)(<span class="number">0xE0000004</span>); <span class="comment">// OM Register</span></span><br><span class="line">    OM &amp;= <span class="number">0x1F</span>;                             	       <span class="comment">// 取出低5位OM[4:0]</span></span><br><span class="line">    <span class="keyword">if</span> (OM == <span class="number">0x2</span>) {				       <span class="comment">// Nand 2KB,5cycle X-TAL</span></span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (OM == <span class="number">0xC</span>) {			           <span class="comment">// SD/MMC X-TAL</span></span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204112027872.png"></p>
<p>先分析SD/MMC下的代码（SD卡下的代码），首先取出当前boot的<code>V210_SDMMC_BASE</code>基地址（查看手册<code>SIAP</code> 中<code>2.6 Global Variable</code> ），接着看手册<code>S5PV210_UM_REV1.1.pdf</code>中的<code>7.9.1 REGISTER MAP</code> 找出对应地址的channel，然后从对应channel的SD卡中将以<code>32块开始的250k数据</code>拷贝到SDRAM中的<code>CONFIG_SYS_SDRAM_BASE</code> （<code>0x20000000</code>）中去。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (OM == <span class="number">0xC</span>) {</span><br><span class="line">	    u32 V210_SDMMC_BASE = *(<span class="keyword">volatile</span> u32 *)(<span class="number">0xD0037488</span>);    <span class="comment">// V210_SDMMC_BASE</span></span><br><span class="line">            u8 ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 7.9.1 SD/MMC REGISTER MAP */</span></span><br><span class="line">            <span class="keyword">if</span> (V210_SDMMC_BASE == <span class="number">0xEB000000</span>)</span><br><span class="line">                    ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (V210_SDMMC_BASE == <span class="number">0xEB200000</span>)</span><br><span class="line">                    ch = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 将BL2 从SD卡（32块开始的250k区域数据）拷贝到SDRAM中</span></span><br><span class="line">            CopySDMMCtoMem(ch, <span class="number">32</span>, bl2Size / <span class="number">512</span>, (u32 *)CONFIG_SYS_SDRAM_BASE, <span class="number">0</span>);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p>接着分析如果u-boot在nand中是怎样将BL2拷贝到内存中的？</p>
<p>首先初始化配置，将配置写入到 <code>nand_reg-&gt;nfconf</code> 和 <code>nand_reg-&gt;nfcont</code> 中，接着配置GPIO。<code>pages = bl2Size/2048</code>，看一下BL2一共有多少页。下一个<code>offset = 0x4000/2048</code>，意思是BL2在nand的页偏移。<code>0x4000/512 = 32blocks</code>，也就是在nand中第32个block开始，后256k</p>
<blockquote>
<p><code>void writel(unsigned char data, unsigned short addr)</code> 往内存映射的IO空间上写数据</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line">	<span class="keyword">if</span> (OM == <span class="number">0x2</span>) {</span><br><span class="line">            u32 cfg = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">s5pv210_nand</span> *<span class="title">nand_reg</span> =</span> (struct s5pv210_nand *)(struct s5pv210_nand *)samsung_get_base_nand();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* initialize hardware */</span></span><br><span class="line">            <span class="comment">/* HCLK_PSYS=133MHz(7.5ns) */</span></span><br><span class="line">            cfg =   (<span class="number">0x1</span> &lt;&lt; <span class="number">23</span>) |   <span class="comment">/* Disable 1-bit and 4-bit ECC */</span></span><br><span class="line">                       (<span class="number">0x3</span> &lt;&lt; <span class="number">12</span>) |   <span class="comment">/* 7.5ns * 2 &gt; 12ns tALS tCLS */</span></span><br><span class="line">                       (<span class="number">0x2</span> &lt;&lt; <span class="number">8</span>) |    <span class="comment">/* (1+1) * 7.5ns &gt; 12ns (tWP) */</span></span><br><span class="line">                       (<span class="number">0x1</span> &lt;&lt; <span class="number">4</span>) |    <span class="comment">/* (0+1) * 7.5 &gt; 5ns (tCLH/tALH) */</span></span><br><span class="line">                       (<span class="number">0x0</span> &lt;&lt; <span class="number">3</span>) |    <span class="comment">/* SLC NAND Flash */</span></span><br><span class="line">                       (<span class="number">0x0</span> &lt;&lt; <span class="number">2</span>) |    <span class="comment">/* 2KBytes/Page */</span></span><br><span class="line">                       (<span class="number">0x1</span> &lt;&lt; <span class="number">1</span>);     <span class="comment">/* 5 address cycle */</span></span><br><span class="line"></span><br><span class="line">            writel(cfg, &amp;nand_reg-&gt;nfconf);</span><br><span class="line"></span><br><span class="line">            writel((<span class="number">0x1</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">0x1</span> &lt;&lt; <span class="number">0</span>), &amp;nand_reg-&gt;nfcont);</span><br><span class="line">            <span class="comment">/* Disable chip select and Enable NAND Flash Controller */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Config GPIO */</span></span><br><span class="line">            MP0_1CON &amp;= ~(<span class="number">0xFFFF</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">            MP0_1CON |= (<span class="number">0x3333</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">            MP0_3CON = <span class="number">0x22222222</span>;</span><br><span class="line">            MP0_6CON = <span class="number">0x22222222</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pages = bl2Size / <span class="number">2048</span>;             <span class="comment">//</span></span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">0x4000</span> / <span class="number">2048</span>;             <span class="comment">// u-boot.bin</span></span><br><span class="line">            u8 *p = (u8 *)CONFIG_SYS_SDRAM_BASE;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; pages; i++, p += <span class="number">2048</span>, offset += <span class="number">1</span>)</span><br><span class="line">            	NF8_ReadPage_Adv(offset / <span class="number">64</span>, offset % <span class="number">64</span>, p);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204112111124.png"></p>
<h4 id="board-init-f"><a href="#board-init-f" class="headerlink" title="board_init_f"></a>board_init_f</h4><p><code>board_init_f</code> 在<code>arch/arm/lib/board.c</code>中，天哪，这是个什？这么多代码。</p>
<p>一点点分析吧，首先定义一堆变量，指针等。将<code>gd</code>（<code>global data</code>）中清零，什么，gd又是个什？gd是在什么时候赋值？什么时候分配空间的呢？</p>
<p>在<a href="#_main">_main</a>中通过<code>sub sp,sp,#GD_SIZE</code>给gd分配了空间，后面通过 <code>mov r9，sp</code>更新gd指针，使之指向分配的空间。所以此处直接清零没有任何问题。</p>
<h5 id="global-data"><a href="#global-data" class="headerlink" title="global_data"></a>global_data</h5><blockquote>
<p>在某些情况下，uboot运行在某些只读存储器上，在uboot被重定向到RAM（可读可写）之前，我们都无法写入数据，更无法通过全局变量来传递数据。而global_data则是为了解决这个问题。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/asm-generic/global_data.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> {</span></span><br><span class="line">	<span class="keyword">bd_t</span> *bd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> baudrate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_clk;	<span class="comment">/* CPU clock in Hz!		*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bus_clk;</span><br><span class="line">	<span class="comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pci_clk;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mem_clk;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fb_base;	<span class="comment">/* Base address of framebuffer mem */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> post_log_word;  <span class="comment">/* Record POST activities */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> post_log_res; <span class="comment">/* success of POST test */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> post_init_f_time;  <span class="comment">/* When post_init_f started */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> board_type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> have_console;	<span class="comment">/* serial_init() was called */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PRE_CONSOLE_BUFFER</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> precon_buf_idx;	<span class="comment">/* Pre-Console buffer index */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> do_mdm_init;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> be_quiet;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> env_addr;	<span class="comment">/* Address  of Environment struct */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> env_valid;	<span class="comment">/* Checksum of Environment valid? */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ram_top;	<span class="comment">/* Top address of RAM used by U-Boot */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> relocaddr;	<span class="comment">/* Start address of U-Boot in RAM */</span></span><br><span class="line">	<span class="keyword">phys_size_t</span> ram_size;	<span class="comment">/* RAM size */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mon_len;	<span class="comment">/* monitor len */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> irq_sp;		<span class="comment">/* irq stack pointer */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_addr_sp;	<span class="comment">/* start_addr_stackpointer */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> reloc_off;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">new_gd</span>;</span>	<span class="comment">/* relocated global data */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	*<span class="title">dm_root</span>;</span>	<span class="comment">/* Root instance for Driver Model */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">uclass_root</span>;</span>	<span class="comment">/* Head of core tree */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *fdt_blob;	<span class="comment">/* Our device tree, NULL if none */</span></span><br><span class="line">	<span class="keyword">void</span> *new_fdt;		<span class="comment">/* Relocated FDT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fdt_size;	<span class="comment">/* Space reserved for relocated FDT */</span></span><br><span class="line">	<span class="keyword">void</span> **jt;		<span class="comment">/* jump table */</span></span><br><span class="line">	<span class="keyword">char</span> env_buf[<span class="number">32</span>];	<span class="comment">/* buffer for getenv() before reloc. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">	<span class="keyword">void</span>		*trace_buff;	<span class="comment">/* The trace buffer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SYS_I2C)</span></span><br><span class="line">	<span class="keyword">int</span>		cur_i2c_bus;	<span class="comment">/* current used i2c bus */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timebase_h;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timebase_l;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arch_global_data</span> <span class="title">arch</span>;</span>	<span class="comment">/* architecture-specific data */</span></span><br><span class="line">} <span class="keyword">gd_t</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>重点说明</p>
<ul>
<li><code>bd_t *bd</code>：board info数据结构定义,位于文件 include/asm-arm/u-boot.h定义,主要是保存开发板的相关参数。</li>
<li><code>unsigned long env_addr</code>：环境变量的地址。</li>
<li><code>unsigned long ram_top</code>：RAM空间的顶端地址</li>
<li><code>unsigned long relocaddr</code>：UBOOT重定向后地址</li>
<li><code>phys_size_t ram_size</code>：物理ram的size</li>
<li><code>unsigned long irq_sp</code>：中断的堆栈地址</li>
<li><code>unsigned long start_addr_sp</code>：堆栈地址</li>
<li><code>unsigned long reloc_off</code>：uboot的relocation的偏移</li>
<li><code>struct global_data *new_gd</code>：重定向后的struct global_data结构体</li>
<li><code>const void *fdt_blob</code>：设备的dtb地址</li>
<li><code>void *new_fdt</code>：relocation之后的dtb地址</li>
<li><code>unsigned long fdt_size</code>：dtb的长度</li>
<li><code>struct udevice *cur_serial_dev</code>：当前使用的串口设备。</li>
</ul>
<p>计算监视区（monitor）长度（<code>__bss_end</code> - <code>_start</code>）并给<code>gd-&gt;mon_len</code></p>
<p>从环境变量中查找<code>fdtcontroladdr</code>，如果存在则更新<code>gd-&gt;fdt_blob</code></p>
<blockquote>
<p><code>ulong getenv_ulong(const char *name, int base, ulong default_val)</code>从环境变量中查找name，存在返回name对应的数值，不存在返回default_val。其中base为进制，例如10、16等。</p>
<p>环境变量的存储用hash表实现</p>
</blockquote>
<p>这一段的意思遍历<code>init_sequence</code>，<code>init_sequence</code>存放的是一系列的函数首地址，通过循环不断将函数地址取出<code>解引用</code>并调用。如果函数返回不为0，表示有错误则一直在此循环。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f</span><span class="params">(ulong bootflag)</span></span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {</span><br><span class="line">		<span class="keyword">if</span> ((*init_fnc_ptr)() != <span class="number">0</span>) {</span><br><span class="line">			hang ();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">        ...</span><br><span class="line"> }</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">init_fnc_t</span> *init_sequence[] = {</span><br><span class="line">	arch_cpu_init,		<span class="comment">/* basic arch cpu dependent setup */</span></span><br><span class="line">	mark_bootstage,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF_CONTROL</span></span><br><span class="line">	fdtdec_check_fdt,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BOARD_EARLY_INIT_F)</span></span><br><span class="line">	board_early_init_f,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	timer_init,		<span class="comment">/* initialize timer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOARD_POSTCLK_INIT</span></span><br><span class="line">	board_postclk_init,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSL_ESDHC</span></span><br><span class="line">	get_clocks,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	env_init,			<span class="comment">/* initialize environment */</span></span><br><span class="line">	init_baudrate,		<span class="comment">/* initialze baudrate settings */</span></span><br><span class="line">	serial_init,		  <span class="comment">/* serial communications setup */</span></span><br><span class="line">	console_init_f,		  <span class="comment">/* stage 1 init of console */</span></span><br><span class="line">	display_banner,		<span class="comment">/* say that we are here */</span></span><br><span class="line">	print_cpuinfo,		<span class="comment">/* display cpu info (and speed) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_DISPLAY_BOARDINFO)</span></span><br><span class="line">	checkboard,		<span class="comment">/* display board info */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span></span><br><span class="line">	init_func_i2c,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	dram_init,		<span class="comment">/* configure available RAM banks */</span></span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>让我们一个个的看看这些函数都是干什么的。</p>
<h5 id="arch-cpu-init"><a href="#arch-cpu-init" class="headerlink" title="arch_cpu_init"></a>arch_cpu_init</h5><p>这个函数做的是针对特定CPU的初始化，u-boot支持很多CPU，不同CPU的初始化也不尽相同，因此u-boot提供了arch_cpu_init用于CPU初始化。这个函数由移植者根据自己的硬件（CPU）的情况来提供，如果不提供，则默认的是一个仅返回0的函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arch_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span> __<span class="title">attribute__</span><span class="params">((weak, alias(<span class="string">"__arch_cpu_init"</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __arch_cpu_init(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="mark-bootstage"><a href="#mark-bootstage" class="headerlink" title="mark_bootstage"></a>mark_bootstage</h5><p>其中<code>bootstage_mark_name（id,name）</code>用于标记当前运行的id和名字。这个函数也就是用来标记当前运行的函数为<code>board_init_f</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mark_bootstage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, <span class="string">"board_init_f"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="fdtdec-check-fdt"><a href="#fdtdec-check-fdt" class="headerlink" title="fdtdec_check_fdt"></a>fdtdec_check_fdt</h5><p>由于未配置<code>CONFIG_OF_CONTROL</code>，所以不会检查fdt。</p>
<p>这个函数的功能是，在 控制台未准备好之前必须有一个FDT，否则会panic。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lib/fdtdec.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdtdec_check_fdt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We must have an FDT, but we cannot panic() yet since the console</span></span><br><span class="line"><span class="comment">	 * is not ready. So for now, just assert(). Boards which need an early</span></span><br><span class="line"><span class="comment">	 * FDT (prior to console ready) will need to make their own</span></span><br><span class="line"><span class="comment">	 * arrangements and do their own checks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	assert(!fdtdec_prepare_fdt());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="board-early-init-f"><a href="#board-early-init-f" class="headerlink" title="board_early_init_f"></a>board_early_init_f</h5><p>由于未配置<code>CONFIG_BOARD_EARLY_INIT_F</code>，不会执行</p>
<h5 id="timer-init"><a href="#timer-init" class="headerlink" title="timer_init"></a>timer_init</h5><p>这个配置貌似跟cpu有关系，在每个不同的cpu有不同的 <code>timer_init</code>，另外在 <code>lib/time.c</code> 中也有一个弱空实现。</p>
<p>s5pv210芯片的在 <code>arch/arm/cpu/armv7/s5p-common/time.c</code>中。</p>
<p>使用SOC的<code>Pwm Timer4</code>作为定时器，Timer4 没有输出引脚，不耽误其Pwm功能。设置Pwm Timer4 4分频，设置占空比为100000ns、周期为100000ns,开启定时器4。</p>
<p>接着将<code>gd-&gt;arch.timer_reset_value</code>复位。更新<code>gd-&gt;arch.lastinc</code>，复位<code>gd-&gt;arch.lastinc = readl(&amp;timer-&gt;tcnto4);</code>，<code>gd-&gt;arch.tbl = 0;</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/cpu/armv7/s5p-common/time.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* PWM Timer 4 */</span></span><br><span class="line">	pwm_init(<span class="number">4</span>, MUX_DIV_4, <span class="number">0</span>);</span><br><span class="line">	pwm_config(<span class="number">4</span>, <span class="number">100000</span>, <span class="number">100000</span>);</span><br><span class="line">	pwm_enable(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use this as the current monotonic time in us */</span></span><br><span class="line">	gd-&gt;arch.timer_reset_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use this as the last timer value we saw */</span></span><br><span class="line">	gd-&gt;arch.lastinc = timer_get_us_down();</span><br><span class="line">	reset_timer_masked();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="board-postclk-init"><a href="#board-postclk-init" class="headerlink" title="board_postclk_init"></a>board_postclk_init</h5><p>由于未配置<code>CONFIG_BOARD_POSTCLK_INIT</code>，不会执行</p>
<h5 id="get-clocks"><a href="#get-clocks" class="headerlink" title="get_clocks"></a>get_clocks</h5><p>由于未配置<code>CONFIG_FSL_ESDHC</code>，不会执行</p>
<h5 id="env-init"><a href="#env-init" class="headerlink" title="env_init"></a>env_init</h5><p>通过SI在Symbols中搜索发现有多个<code>env_init</code>,猜测是不同的板子可能存到不同的存储设备上。</p>
<blockquote>
<ol>
<li><p>环境变量可能位于很多地方，比如EEPROM、FLASH等地方，枚举<code>enum env_location</code>定义了一些常量用于标识环境变量的位置。这些常量有ENVL_EEPROM、ENVL_EXT4等</p>
</li>
<li><p>uboot获取环境变量的位置时，有一个先后顺序，比如优先看环境变量是否在EEPROM中。这个优先顺序实现很简单：定义一个数组<code>env_locations</code>，<strong>数组里存的是环境变量各个的位置，存的顺序就是优先顺序，</strong>然后只要从下标为0开始访问这个数组，即可按照数组指定的优先顺序来获取环境变量的位置。</p>
</li>
<li><p>对于存在于不同位置的环境变量，u-boot会使用<code>U_BOOT_ENV_LOCATION</code>定义一个相应的<code>struct env_driver</code>类型的entry，多个entry在内存中连续分布，因此可以向遍历数组元素那样遍历这些entry。而实现内存连续分布的关键在于<strong>自定义段</strong>，</p>
 <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在链接脚本中将这些段按照段名的字母顺序排列:</span></span><br><span class="line"><span class="comment">	.u_boot_list : {</span></span><br><span class="line"><span class="comment">  		KEEP(*(SORT(.u_boot_list*)));</span></span><br><span class="line"><span class="comment"> 	}</span></span><br><span class="line"><span class="comment">	因此可用u_boot_list_2_env_driver_1标记这些entry的起始地址</span></span><br><span class="line"><span class="comment">	而使用u_boot_list_2_env_driver_3标记相应的结束地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.u_boot_list_2_env_driver_1</span><br><span class="line">.u_boot_list_2_env_driver_2_eeprom</span><br><span class="line">.u_boot_list_2_env_driver_2_ext4</span><br><span class="line">.u_boot_list_2_env_driver_3</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</blockquote>
<p>smart210这个板子在执行<code>saveenv</code>是直接存储环境变量到<code>NAND</code>的0x60000处。实际上通过编译脚本来说更有说服力，首先，看下<code>common/Makefile</code>，要编译对应的文件，需要使能相关宏后才会编译。再次查看<code>include/configs/smart210.h</code>，其定义了<code>#define CONFIG_ENV_IS_IN_NAND 1</code>，所以env_init的路径为<code>common/env_nand.c</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># environment</span></span><br><span class="line">obj-y += env_attr.o</span><br><span class="line">obj-y += env_callback.o</span><br><span class="line">obj-y += env_flags.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o</span><br><span class="line">extra-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_embedded.o</span><br><span class="line">extra-$(CONFIG_ENV_IS_IN_FLASH) += env_embedded.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_embedded.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_MMC) += env_mmc.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o</span><br></pre></td></tr></tbody></table></figure>



<p>所以我们只关心<code>common/env_nand.c</code>中的，别看代码这么长。实际上<code>ENV_IS_EMBEDDED</code>与<code>CONFIG_NAND_ENV_DST</code>我们都没有定义，所以真正的代码只有两句。</p>
<p>从注释就基本可以看出这个函数的作用，因为<code>env_init</code>要早于静态存储器的初始化，所以无法进行<code>env</code>的读写，这里将<code>gd</code>中的<code>env</code>相关变量进行配置，默认设置<code>env</code>为<code>valid</code>。<code>default_environment</code>是什么？<strong>TODO:待分析</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gd-&gt;env_addr	= (ulong)&amp;default_environment[<span class="number">0</span>];</span><br><span class="line">gd-&gt;env_valid	  = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/env_nand.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is called before nand_init() so we can't read NAND to</span></span><br><span class="line"><span class="comment"> * validate env data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Mark it OK for now. env_relocate() in env_common.c will call our</span></span><br><span class="line"><span class="comment"> * relocate function which does the real validation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When using a NAND boot image (like sequoia_nand), the environment</span></span><br><span class="line"><span class="comment"> * can be embedded or attached to the U-Boot image in NAND flash.</span></span><br><span class="line"><span class="comment"> * This way the SPL loads not only the U-Boot image from NAND but</span></span><br><span class="line"><span class="comment"> * also the environment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ENV_IS_EMBEDDED) || defined(CONFIG_NAND_ENV_DST)</span></span><br><span class="line">	<span class="keyword">int</span> crc1_ok = <span class="number">0</span>, crc2_ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">env_t</span> *tmp_env1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ENV_OFFSET_REDUND</span></span><br><span class="line">	<span class="keyword">env_t</span> *tmp_env2;</span><br><span class="line"></span><br><span class="line">	tmp_env2 = (<span class="keyword">env_t</span> *)((ulong)env_ptr + CONFIG_ENV_SIZE);</span><br><span class="line">	crc2_ok = crc32(<span class="number">0</span>, tmp_env2-&gt;data, ENV_SIZE) == tmp_env2-&gt;crc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	tmp_env1 = env_ptr;</span><br><span class="line">	crc1_ok = crc32(<span class="number">0</span>, tmp_env1-&gt;data, ENV_SIZE) == tmp_env1-&gt;crc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!crc1_ok &amp;&amp; !crc2_ok) {</span><br><span class="line">		gd-&gt;env_addr	= <span class="number">0</span>;</span><br><span class="line">		gd-&gt;env_valid	= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (crc1_ok &amp;&amp; !crc2_ok) {</span><br><span class="line">		gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ENV_OFFSET_REDUND</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!crc1_ok &amp;&amp; crc2_ok) {</span><br><span class="line">		gd-&gt;env_valid = <span class="number">2</span>;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">/* both ok - check serial */</span></span><br><span class="line">		<span class="keyword">if</span> (tmp_env1-&gt;flags == <span class="number">255</span> &amp;&amp; tmp_env2-&gt;flags == <span class="number">0</span>)</span><br><span class="line">			gd-&gt;env_valid = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp_env2-&gt;flags == <span class="number">255</span> &amp;&amp; tmp_env1-&gt;flags == <span class="number">0</span>)</span><br><span class="line">			gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp_env1-&gt;flags &gt; tmp_env2-&gt;flags)</span><br><span class="line">			gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp_env2-&gt;flags &gt; tmp_env1-&gt;flags)</span><br><span class="line">			gd-&gt;env_valid = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">/* flags are equal - almost impossible */</span></span><br><span class="line">			gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;env_valid == <span class="number">2</span>)</span><br><span class="line">		env_ptr = tmp_env2;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;env_valid == <span class="number">1</span>)</span><br><span class="line">		env_ptr = tmp_env1;</span><br><span class="line"></span><br><span class="line">	gd-&gt;env_addr = (ulong)env_ptr-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */</span></span></span><br><span class="line">	gd-&gt;env_addr	= (ulong)&amp;default_environment[<span class="number">0</span>];</span><br><span class="line">	gd-&gt;env_valid	= <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="init-baudrate"><a href="#init-baudrate" class="headerlink" title="init_baudrate"></a>init_baudrate</h5><p>上面我们介绍了<code>getenv_ulong</code>，从环境变量中获取参数，所以本函数的作用是从环境变量中取出<code>baudrate</code>对应的值给<code>gd</code>，以10进制，如果没有，默认为<code>115200</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_baudrate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;baudrate = getenv_ulong(<span class="string">"baudrate"</span>, <span class="number">10</span>, CONFIG_BAUDRATE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="serial-init"><a href="#serial-init" class="headerlink" title="serial_init"></a>serial_init</h5><p>获取当前的串口设备，并调用当前串口设备的start成员函数</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/serial/serial.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serial_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> get_current()-&gt;start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于此时重定位还没做，GD_FLG_RELOC标志未设置，因此条件满足，会进入第一个分支，因此<code>dev = default_serial_console();</code>后面调用start。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/serial/serial.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct serial_device *<span class="title">get_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(gd-&gt;flags &amp; GD_FLG_RELOC))</span><br><span class="line">		dev = default_serial_console();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!serial_current)</span><br><span class="line">		dev = default_serial_console();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		dev = serial_current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We must have a console device */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev) {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPL_BUILD</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Cannot find console\n"</span>);</span><br><span class="line">		hang();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		panic(<span class="string">"Cannot find console\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>后面在重定位完成后，且当前<code>serial_current</code>也不为空，会进入第三个分支，而第三个分支的<code>dev = serial_current;</code>serial_current是怎么确认是哪个串口的呢？</p>
<p><code>board_init_r</code>中会有一个串口初始化 <code>serial_initialize</code>函数，这个函数中前面的都是初始化各种串口，比如我们板卡对应型号的为 <code>s5p_serial_initialize</code>，最后一个是设置要使用串口。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/serial/serial.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_initialize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">         ...</span><br><span class="line">	s5p_serial_initialize();</span><br><span class="line">        ...</span><br><span class="line">	serial_assign(default_serial_console()-&gt;name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>进去看下，四个注册函数，对应着我们板卡上的串口0-3</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/serial/serial_s5p.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s5p_serial_initialize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	serial_register(&amp;s5p_serial0_device);</span><br><span class="line">	serial_register(&amp;s5p_serial1_device);</span><br><span class="line">	serial_register(&amp;s5p_serial2_device);</span><br><span class="line">	serial_register(&amp;s5p_serial3_device);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而这个注册函数，则是把当前注册的串口添加到链表的最前面。哦对，所有注册的设备节点都串在一个链表中，该链表的头部，也就是<code>最近</code>注册过的。</p>
<p>所以上面初始化函数实际上就是将所有串口设备串到同一个链表中<code>serial_devices</code>。那么，如何知道使用哪个串口呢？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/serial/serial.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> *<span class="title">serial_devices</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> *<span class="title">serial_current</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_register</span><span class="params">(struct serial_device *dev)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dev-&gt;next = serial_devices;</span><br><span class="line">	serial_devices = dev;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际上，我们在其定义的结构中也许能看出一些端倪。其结构中有一个<code>name</code>成员，正是通过这个来确定是哪个串口的。那怎么确定的呢？名字又是从哪里来的呢？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/serial.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> {</span></span><br><span class="line">	<span class="comment">/* enough bytes to match alignment of following func pointer */</span></span><br><span class="line">	<span class="keyword">char</span>	name[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		(*start)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">int</span>		(*stop)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">void</span>	(*setbrg)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">int</span>		(*getc)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">int</span>		(*tstc)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">void</span>	(*putc)(<span class="keyword">const</span> <span class="keyword">char</span> c);</span><br><span class="line">	<span class="keyword">void</span>	(*<span class="built_in">puts</span>)(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_POST &amp; CONFIG_SYS_POST_UART</span></span><br><span class="line">	<span class="keyword">void</span>	(*loop)(<span class="keyword">int</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span>	*<span class="title">next</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>别忘记，我们在<code>serial_initialize</code>还有另一个函数，<code>serial_assign(default_serial_console()-&gt;name);</code>，没错，这个就是决定你使用哪个串口的关键。首先我们看下这个函数，之后在去<code>default_serial_console()</code>。代码很少，看着就很喜欢，其意思是什么呢？遍历上面我们初始化时注册的那些串口设备的链表，然后拿出名字来与传进来的名字比较，如果一致，<code>strcmp</code>返回<code>0</code>，条件不成立，继续往下走，<code>serial_current = s</code>就把从链表中获取的要使用串口描述符地址取出来了然后赋值给<code>serial_current</code>，所以后面通过<code>get_current</code>返回的地址为我们设定的串口描述符的地址。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serial_assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (s = serial_devices; s; s = s-&gt;next) {</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s-&gt;name, name))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		serial_current = s;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着我们看下 <code>default_serial_console()</code>，在serial_s5p中存在一个弱实现，<code>CONFIG_OF_CONTROL</code>我们没定义，所以选择另一个分支，<code>config.enable=1</code>，然后我们在<code>smart210.h中</code>定义了<code>CONFIG_SERIAL0</code>为1，所以此处<code>return &amp;s5p_serial0_device;</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/serial/serial_s5p.c</span></span><br><span class="line"><span class="function">__weak struct serial_device *<span class="title">default_serial_console</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF_CONTROL</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((!config.base_addr) &amp;&amp; (fdtdec_decode_console(&amp;index, &amp;config))) {</span><br><span class="line">		debug(<span class="string">"Cannot decode default console node\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (config.port_id) {</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;s5p_serial0_device;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;s5p_serial1_device;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;s5p_serial2_device;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;s5p_serial3_device;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		debug(<span class="string">"Unknown config.port_id: %d"</span>, config.port_id);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	config.enabled = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SERIAL0)</span></span><br><span class="line">	<span class="keyword">return</span> &amp;s5p_serial0_device;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SERIAL1)</span></span><br><span class="line">	<span class="keyword">return</span> &amp;s5p_serial1_device;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SERIAL2)</span></span><br><span class="line">	<span class="keyword">return</span> &amp;s5p_serial2_device;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SERIAL3)</span></span><br><span class="line">	<span class="keyword">return</span> &amp;s5p_serial3_device;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"CONFIG_SERIAL? missing."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在同文件中，<code>s5p_serial0_device</code> 是这样被定义的，也就是上面这三行，实际上定义了一堆函数，并把函数与结构体对应起来</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_S5P_SERIAL_FUNCTIONS(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> <span class="title">s5p_serial0_device</span> =</span></span><br><span class="line">	INIT_S5P_SERIAL_STRUCTURE(<span class="number">0</span>, <span class="string">"s5pser0"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_S5P_SERIAL_STRUCTURE(port, __name) {  \</span></span><br><span class="line"><span class="meta">	.name	= __name,						\</span></span><br><span class="line"><span class="meta">	.start	= s5p_serial##port##_init,			     \</span></span><br><span class="line"><span class="meta">	.stop	= NULL,							 \</span></span><br><span class="line"><span class="meta">	.setbrg	= s5p_serial##port##_setbrg,		  \</span></span><br><span class="line"><span class="meta">	.getc	= s5p_serial##port##_getc,			\</span></span><br><span class="line"><span class="meta">	.tstc	= s5p_serial##port##_tstc,			  \</span></span><br><span class="line"><span class="meta">	.putc	= s5p_serial##port##_putc,		       \</span></span><br><span class="line"><span class="meta">	.puts	= s5p_serial##port##_puts,		       \</span></span><br><span class="line"><span class="meta">}</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_S5P_SERIAL_FUNCTIONS(port) \</span></span><br><span class="line"><span class="meta">static int s5p_serial##port##_init(void) { return serial_init_dev(port); } \</span></span><br><span class="line"><span class="meta">static void s5p_serial##port##_setbrg(void) { serial_setbrg_dev(port); } \</span></span><br><span class="line"><span class="meta">static int s5p_serial##port##_getc(void) { return serial_getc_dev(port); } \</span></span><br><span class="line"><span class="meta">static int s5p_serial##port##_tstc(void) { return serial_tstc_dev(port); } \</span></span><br><span class="line"><span class="meta">static void s5p_serial##port##_putc(const char c) { serial_putc_dev(c, port); } \</span></span><br><span class="line"><span class="meta">static void s5p_serial##port##_puts(const char *s) { serial_puts_dev(s, port); }</span></span><br><span class="line">    </span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s5p_serial0_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>{ <span class="keyword">return</span> serial_init_dev(port); } </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s5p_serial0_setbrg</span><span class="params">(<span class="keyword">void</span>)</span> </span>{ serial_setbrg_dev(port); } </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s5p_serial0_getc</span><span class="params">(<span class="keyword">void</span>)</span> </span>{ <span class="keyword">return</span> serial_getc_dev(port); } </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s5p_serial0_tstc</span><span class="params">(<span class="keyword">void</span>)</span> </span>{ <span class="keyword">return</span> serial_tstc_dev(port); } </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s5p_serial0_putc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span> </span>{ serial_putc_dev(c, port); } </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s5p_serial0_puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{ serial_puts_dev(s, port); }</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> <span class="title">s5p_serial0_device</span> =</span> {</span><br><span class="line">        .name	= <span class="string">"s5pser0"</span>,			\</span><br><span class="line">	.start	    = s5p_serial0_init		    \</span><br><span class="line">	.stop	  = <span class="literal">NULL</span>,				 \</span><br><span class="line">	.setbrg	   = s5p_serial0_setbrg, 	   \</span><br><span class="line">        .getc	  = s5p_serial0_getc,              \</span><br><span class="line">	.tstc	   = s5p_serial0_tstc,		   \</span><br><span class="line">	.putc	 = s5p_serial0_putc,	      \</span><br><span class="line">	.<span class="built_in">puts</span>	 = s5p_serial0_puts,	      \</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>



<h5 id="console-init-f"><a href="#console-init-f" class="headerlink" title="console_init_f"></a>console_init_f</h5><p>将<code>gd</code>中<code>have_console</code>置为1，然后打印Pre-Console Buffer中的数据。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* common/console.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">console_init_f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;have_console = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SILENT_CONSOLE</span></span><br><span class="line">	<span class="keyword">if</span> (getenv(<span class="string">"silent"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">		gd-&gt;flags |= GD_FLG_SILENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	print_pre_console_buffer();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="display-banner"><a href="#display-banner" class="headerlink" title="display_banner"></a>display_banner</h5><p>上面我们已经配置好串口，现在可以输出信息到终端了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">display_banner</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\n%s\n\n"</span>, version_string);</span><br><span class="line">	debug(<span class="string">"U-Boot code: %08lX -&gt; %08lX  BSS: -&gt; %08lX\n"</span>,(ulong)&amp;_start,(ulong)&amp;__bss_start, (ulong)&amp;__bss_end);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span></span><br><span class="line">	debug(<span class="string">"Modem Support enabled\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_USE_IRQ</span></span><br><span class="line">	debug(<span class="string">"IRQ Stack: %08lx\n"</span>, IRQ_STACK_START);</span><br><span class="line">	debug(<span class="string">"FIQ Stack: %08lx\n"</span>, FIQ_STACK_START);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此处就是打印，如果定义了宏 <code>DEBUG</code>，将输出更多信息。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">U-Boot 2014.04-g8819fbf-dirty (Apr 12 2022 - 10:19:11) for SMART210</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h5 id="print-cpuinfo"><a href="#print-cpuinfo" class="headerlink" title="print_cpuinfo"></a>print_cpuinfo</h5><p>打印CPU信息，所以该函数位置为 <code>arch/arm/cpu/armv7/s5p-common/cpu_info.c</code></p>
<p>输出CPU名字、ID、频率信息。如</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU:	S5PC110@1000MHz</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/cpu/armv7/s5p-common/cpu_info.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_cpuinfo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CPU:\t%s%X@%sMHz\n"</span>,</span><br><span class="line">			s5p_get_cpu_name(), s5p_cpu_id,</span><br><span class="line">			strmhz(buf, get_arm_clk()));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="checkboard"><a href="#checkboard" class="headerlink" title="checkboard"></a>checkboard</h5><p>配置了宏<code>CONFIG_DISPLAY_BOARDINFO</code>,位于<code>board/samsung/smart210/smart210.c</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Board:	SMART210</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkboard</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Board:\tSMART210\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="init-func-i2c"><a href="#init-func-i2c" class="headerlink" title="init_func_i2c"></a>init_func_i2c</h5><p>似乎没有配置，暂不分析。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_func_i2c</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"I2C:   "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_I2C</span></span><br><span class="line">	i2c_init_all();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"ready\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>



<h5 id="negative-squared-cross-mark-dram-init"><a href="#negative-squared-cross-mark-dram-init" class="headerlink" title=":negative_squared_cross_mark: dram_init"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> dram_init</h5><p>更新<code>gd</code>中的内存大小，其值为<code> get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE)</code>。<code>get_ram_size</code>又是什么呢？是用来检测内给定范围内的内存是否有效的一个小函数，在当前函数中检测范围为<code>[PHYS_SDRAM_1, PHYS_SDRAM_1+PHYS_SDRAM_1_SIZE]</code>。如果没有问题，返回<code>PHYS_SDRAM_1_SIZE</code>。<code>TODO:剩下的下次在分析</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// board/samsung/smart210.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dram_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;ram_size = get_ram_size((<span class="keyword">long</span> *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/memsize.c</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_ram_size</span><span class="params">(<span class="keyword">long</span> *base, <span class="keyword">long</span> maxsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> *addr;</span><br><span class="line">	<span class="keyword">long</span>           save[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">long</span>           cnt;</span><br><span class="line">	<span class="keyword">long</span>           val;</span><br><span class="line">	<span class="keyword">long</span>           size;</span><br><span class="line">	<span class="keyword">int</span>            i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (cnt = (maxsize / <span class="keyword">sizeof</span> (<span class="keyword">long</span>)) &gt;&gt; <span class="number">1</span>; cnt &gt; <span class="number">0</span>; cnt &gt;&gt;= <span class="number">1</span>) {</span><br><span class="line">		addr = base + cnt;	<span class="comment">/* pointer arith! */</span></span><br><span class="line">		sync ();</span><br><span class="line">		save[i++] = *addr;</span><br><span class="line">		sync ();</span><br><span class="line">		*addr = ~cnt;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	addr = base;</span><br><span class="line">	sync ();</span><br><span class="line">	save[i] = *addr;</span><br><span class="line">	sync ();</span><br><span class="line">	*addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	sync ();</span><br><span class="line">	<span class="keyword">if</span> ((val = *addr) != <span class="number">0</span>) {</span><br><span class="line">		<span class="comment">/* Restore the original data before leaving the function.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sync ();</span><br><span class="line">		*addr = save[i];</span><br><span class="line">		<span class="keyword">for</span> (cnt = <span class="number">1</span>; cnt &lt; maxsize / <span class="keyword">sizeof</span>(<span class="keyword">long</span>); cnt &lt;&lt;= <span class="number">1</span>) {</span><br><span class="line">			addr  = base + cnt;</span><br><span class="line">			sync ();</span><br><span class="line">			*addr = save[--i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (cnt = <span class="number">1</span>; cnt &lt; maxsize / <span class="keyword">sizeof</span> (<span class="keyword">long</span>); cnt &lt;&lt;= <span class="number">1</span>) {</span><br><span class="line">		addr = base + cnt;	<span class="comment">/* pointer arith! */</span></span><br><span class="line">		val = *addr;</span><br><span class="line">		*addr = save[--i];</span><br><span class="line">		<span class="keyword">if</span> (val != ~cnt) {</span><br><span class="line">			size = cnt * <span class="keyword">sizeof</span> (<span class="keyword">long</span>);</span><br><span class="line">			<span class="comment">/* Restore the original data before leaving the function.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">for</span> (cnt &lt;&lt;= <span class="number">1</span>; cnt &lt; maxsize / <span class="keyword">sizeof</span> (<span class="keyword">long</span>); cnt &lt;&lt;= <span class="number">1</span>) {</span><br><span class="line">				addr  = base + cnt;</span><br><span class="line">				*addr = save[--i];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> (size);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (maxsize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p>上文我们将那一个初始化列表讲完了。下面接着对board_init_f分析。根据打印日志，删除没有用的宏开关，方便我们分析代码。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2014.04-g8819fbf-dirty (Apr 12 2022 - 10:16:10) for SMART210</span><br><span class="line"></span><br><span class="line">U-Boot code: 20000000 -&gt; 2003A2D0  BSS: -&gt; 200706D0</span><br><span class="line">CPU:	S5PC110@1000MHz</span><br><span class="line">Board:	SMART210</span><br><span class="line">monitor len: 000706D0</span><br><span class="line">ramsize: 20000000</span><br><span class="line">TLB table from 3fff0000 to 3fff4000</span><br><span class="line">Top of RAM usable for U-Boot at: 3fff0000</span><br><span class="line">Reserving 449k for U-Boot at: 3ff7f000</span><br><span class="line">Reserving 1280k for malloc() at: 3fe3f000</span><br><span class="line">Reserving 32 Bytes for Board Info at: 3fe3efe0</span><br><span class="line">Reserving 160 Bytes for Global Data at: 3fe3ef40</span><br><span class="line">New Stack Pointer is: 3fe3ef30</span><br><span class="line">RAM Configuration:</span><br><span class="line">Bank #0: 20000000 512 MiB</span><br><span class="line">relocation Offset is: 1ff7f000</span><br><span class="line">WARNING: Caches not enabled</span><br></pre></td></tr></tbody></table></figure>

<p>接着打印<code>gd-&gt;mon_len</code>和<code>gd-&gt;ram_size</code>，然后<code>addr=CONFIG_SYS_SDRAM_BASE+get_effective_memsize();</code> ，其中<code>CONFIG_SYS_SDRAM_BASE</code>为SDRAM起始地址，也就是<code>0x20000000</code>，<code>get_effective_memsize</code>在 <code>common/memsize.c</code> 有一个弱实现，其余与板级相关的地方没有发现该函数。</p>
<p>所以确认调用为<code>common/memsize.c</code>中<code>get_effective_memsize()</code>，其实也就是判断定义内存大小是否超过了最大界限，超过则返回最大值，否则<code>gd-&gt;ram_size</code>。而<code>gd-&gt;ram_size</code>在<a href="#dram_init">dram_init</a>中得到的大小为<code>PHYS_SDRAM_1_SIZE</code>，所以addr此时为<code>CONFIG_SYS_SDRAM_BASE+PHYS_SDRAM_1_SIZE</code>。</p>
<p>然后更新<code>gd-&gt;arch.tlb_size</code> 值为<code>PGTABLE_SIZE</code>（<code>4096*4</code>，也就是4k），然后下面一个64kb对齐（换句话说<code>PGTABLE_SIZE</code>最大可设置为64kb），接着更新<code>gd-&gt;arch.tlb_addr</code>。然后4kb对齐，<code>addr -= gd-&gt;mon_len</code>，继续4kb对齐。</p>
<p>最终内存分布是这样的。</p>
<p>总结一下，这段代码首先用来<code>更新gd结构体</code>中的内容，然后将<code>gd</code>结构体在拷贝到内存中对应位置。</p>
<p>此处需要注意下，当前代码还没有重定位，所以<code>_start</code>还是在起始位置，也就是<code>0x20000000</code>处，</p>
<p><code>gd-&gt;relocaddr = addr</code>，<code>gd-&gt;reloc_off = addr - (ulong)&amp;_start</code>，<code>gd-&gt;relocaddr</code>存储的为重定位后的地址，所以<code>gd-&gt;reloc_off</code>存储的是重定位前后<code>_start</code>的绝对值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131359579.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f</span><span class="params">(ulong bootflag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">bd_t</span> *bd;</span><br><span class="line">	<span class="keyword">init_fnc_t</span> **init_fnc_ptr;</span><br><span class="line">	<span class="keyword">gd_t</span> *id;</span><br><span class="line">	ulong addr, addr_sp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PRAM</span></span><br><span class="line">	ulong reg;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">void</span> *new_fdt = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> fdt_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	debug(<span class="string">"monitor len: %08lX\n"</span>, gd-&gt;mon_len);</span><br><span class="line">	debug(<span class="string">"ramsize: %08lX\n"</span>, gd-&gt;ram_size);</span><br><span class="line">	addr = CONFIG_SYS_SDRAM_BASE + get_effective_memsize();	<span class="comment">/* CONFIG_SYS_SDRAM_BASE+PHYS_SDRAM_1_SIZE */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF))</span></span><br><span class="line">	<span class="comment">/* reserve TLB table */</span></span><br><span class="line">	gd-&gt;arch.tlb_size = PGTABLE_SIZE;</span><br><span class="line">	addr -= gd-&gt;arch.tlb_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* round down to next 64 kB limit */</span></span><br><span class="line">	addr &amp;= ~(<span class="number">0x10000</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	gd-&gt;arch.tlb_addr = addr;</span><br><span class="line">	debug(<span class="string">"TLB table from %08lx to %08lx\n"</span>, addr, addr + gd-&gt;arch.tlb_size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* round down to next 4 kB limit */</span></span><br><span class="line">	addr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);</span><br><span class="line">	debug(<span class="string">"Top of RAM usable for U-Boot at: %08lx\n"</span>, addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * reserve memory for U-Boot code, data &amp; bss</span></span><br><span class="line"><span class="comment">	 * round down to next 4 kB limit</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr -= gd-&gt;mon_len;</span><br><span class="line">	addr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"Reserving %ldk for U-Boot at: %08lx\n"</span>, gd-&gt;mon_len &gt;&gt; <span class="number">10</span>, addr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPL_BUILD</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * reserve memory for malloc() arena</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp = addr - TOTAL_MALLOC_LEN;</span><br><span class="line">	debug(<span class="string">"Reserving %dk for malloc() at: %08lx\n"</span>,</span><br><span class="line">			TOTAL_MALLOC_LEN &gt;&gt; <span class="number">10</span>, addr_sp);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * (permanently) allocate a Board Info struct</span></span><br><span class="line"><span class="comment">	 * and a permanent copy of the "global" data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp -= <span class="keyword">sizeof</span> (<span class="keyword">bd_t</span>);</span><br><span class="line">	bd = (<span class="keyword">bd_t</span> *) addr_sp;</span><br><span class="line">	gd-&gt;bd = bd;</span><br><span class="line">	debug(<span class="string">"Reserving %zu Bytes for Board Info at: %08lx\n"</span>,</span><br><span class="line">			<span class="keyword">sizeof</span> (<span class="keyword">bd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MACH_TYPE</span></span><br><span class="line">	gd-&gt;bd-&gt;bi_arch_number = CONFIG_MACH_TYPE; <span class="comment">/* board id for Linux */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	addr_sp -= <span class="keyword">sizeof</span> (<span class="keyword">gd_t</span>);</span><br><span class="line">	id = (<span class="keyword">gd_t</span> *) addr_sp;</span><br><span class="line">	debug(<span class="string">"Reserving %zu Bytes for Global Data at: %08lx\n"</span>,</span><br><span class="line">			<span class="keyword">sizeof</span> (<span class="keyword">gd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ARM64</span></span><br><span class="line">	<span class="comment">/* setup stackpointer for exeptions */</span></span><br><span class="line">	gd-&gt;irq_sp = addr_sp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_USE_IRQ</span></span><br><span class="line">	addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);</span><br><span class="line">	debug(<span class="string">"Reserving %zu Bytes for IRQ stack at: %08lx\n"</span>,</span><br><span class="line">		CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* leave 3 words for abort-stack    */</span></span><br><span class="line">	addr_sp -= <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 8-byte alignment for ABI compliance */</span></span><br><span class="line">	addr_sp &amp;= ~<span class="number">0x07</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* CONFIG_ARM64 */</span></span></span><br><span class="line">	<span class="comment">/* 16-byte alignment for ABI compliance */</span></span><br><span class="line">	addr_sp &amp;= ~<span class="number">0x0f</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_ARM64 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	addr_sp += <span class="number">128</span>;	<span class="comment">/* leave 32 words for abort-stack   */</span></span><br><span class="line">	gd-&gt;irq_sp = addr_sp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"New Stack Pointer is: %08lx\n"</span>, addr_sp);</span><br><span class="line"></span><br><span class="line">	gd-&gt;bd-&gt;bi_baudrate = gd-&gt;baudrate;</span><br><span class="line">	<span class="comment">/* Ram ist board specific, so move it to board code ... */</span></span><br><span class="line">	dram_init_banksize(); <span class="comment">// 更新gd-&gt;bd-&gt;bi_dram[0] 的start(PHYS_SDRAM_1)和size(PHYS_SDRAM_1_SIZE)</span></span><br><span class="line">	display_dram_config();	<span class="comment">/* and display it */</span></span><br><span class="line"></span><br><span class="line">	gd-&gt;relocaddr = addr;</span><br><span class="line">	gd-&gt;start_addr_sp = addr_sp;</span><br><span class="line">	gd-&gt;reloc_off = addr - (ulong)&amp;_start;</span><br><span class="line">	debug(<span class="string">"relocation Offset is: %08lx\n"</span>, gd-&gt;reloc_off);</span><br><span class="line">	<span class="keyword">if</span> (new_fdt) {</span><br><span class="line">		<span class="built_in">memcpy</span>(new_fdt, gd-&gt;fdt_blob, fdt_size);</span><br><span class="line">		gd-&gt;fdt_blob = new_fdt;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">memcpy</span>(id, (<span class="keyword">void</span> *)gd, <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="main-继续，接上文"><a href="#main-继续，接上文" class="headerlink" title="_main 继续，接上文"></a>_main 继续，接上文</h4><p>在非SPL下，接着就是更新<code>sp</code>和<code>gd</code>，然后重定位代码。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	...</span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">	ldr	sp, [r9, #GD_START_ADDR_SP]	/* sp = gd-&gt;start_addr_sp */</span><br><span class="line">	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */</span><br><span class="line">	ldr	r9, [r9, #GD_BD]		/* r9 = gd-&gt;bd */</span><br><span class="line">	sub	r9, r9, #GD_SIZE		/* new GD is below bd */</span><br><span class="line">	...</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p><code>GD_START_ADDR_SP</code>在 <code>include/generated/generic-asm-offsets.h</code>中定义，其值为 <code>start_addr_sp</code> 在  <code>global_data</code> 结构中的相对偏移，同样是编译后才生成的。</p>
<p>由上面的代码可知，刚刚为<code>gd</code>也就是<code>global_data</code>分配了大小为<code>GD_SIZE</code>的空间，现在<code>r9</code>和<code>sp</code>内的数据为地址<code>CONFIG_SYS_INIT_SP_ADDR - GD_SIZE</code> （需要8字节对齐）中的数据。换句话说此时<code>r9</code>中为<code>gd</code>的地址，那么再加上 <code>GD_START_ADDR_SP</code>，也就是<code>gd+GD_START_ADDR_SP</code>，将<code>gd+GD_START_ADDR_SP</code>地址中的值（<code>gd-&gt;start_addr_sp</code>）传递给<code>sp</code>，接着8字节对齐。</p>
<p>然后更新<code>r9</code>的值为<code>[r9 + GD_BD]</code>，也就是<code>r9 = gd-&gt;bd</code>。</p>
<p>然后又分配一个大小为<code>GD_SIZE</code>的空间。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	...</span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">	...</span><br><span class="line">	adr	lr, here</span><br><span class="line">	ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd-&gt;reloc_off */</span><br><span class="line">	add	lr, lr, r0</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd-&gt;relocaddr */</span><br><span class="line">	b	relocate_code</span><br><span class="line">	</span><br><span class="line">here:</span><br><span class="line">/* Set up final (full) environment */</span><br><span class="line">	bl	c_runtime_cpu_setup	/* we still call old routine here */</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p>将<code>here</code>处的<code>相对地址</code>复制给<code>lr</code>，将<code>gd</code>结构中的<code>reloc_off</code>值（其相对于<code>gd</code>偏移为<code>GD_RELOC_OFF</code>）给<code>r0</code>。</p>
<p><code>lr</code>与<code>r0</code>相加给<code>lr</code>,即<code>lr = lr + r0</code>，将<code>gd</code>结构中的<code>relocaddr</code>值（其相对于<code>gd</code>偏移为<code>GD_RELOCADDR</code>）给<code>r0</code>。</p>
<p>此时<code>lr = here + gd-&gt;reloc_off</code>，<code>r0 = gd-&gt;relocaddr</code>，然后调用<code>relocate_code</code>。</p>
<h4 id="relocate-code"><a href="#relocate-code" class="headerlink" title="relocate_code"></a>relocate_code</h4><p>其定义位于 <code>include/common.h</code>中，由于定义了宏<code>CONFIG_ARM</code>，所以其声明为如下代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/common.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relocate_code</span><span class="params">(ulong)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>其实现位于 <code>arch/arm/lib/relocate.S</code>中</p>
<p>是一个比较麻烦的地方，并且需要函数传参。</p>
<p>看代码，进入到<code>relocate_code</code>后，此时r0寄存器中数据为<code>gd-&gt;relocaddr</code>，也就是为重定位后的u-boot程序地址。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	ldr	r1, =__image_copy_start	/* r1 &lt;- SRC &amp;__image_copy_start */</span><br><span class="line">	subs	r4, r0, r1		/* r4 &lt;- relocation offset */</span><br><span class="line">	beq	relocate_done		/* skip relocation */</span><br><span class="line">	ldr	r2, =__image_copy_end	/* r2 &lt;- SRC &amp;__image_copy_end */</span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, {r10-r11}		/* copy from source address [r1]    */</span><br><span class="line">	stmia	r0!, {r10-r11}		/* copy to   target address [r0]    */</span><br><span class="line">	cmp	r1, r2			/* until source end address [r2]    */</span><br><span class="line">	blo	copy_loop</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * fix .rel.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	ldr	r2, =__rel_dyn_start	/* r2 &lt;- SRC &amp;__rel_dyn_start */</span><br><span class="line">	ldr	r3, =__rel_dyn_end	/* r3 &lt;- SRC &amp;__rel_dyn_end */</span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, {r0-r1}		/* (r0,r1) &lt;- (SRC location,fixup) */</span><br><span class="line">	and	r1, r1, #0xff</span><br><span class="line">	cmp	r1, #23			/* relative fixup? */</span><br><span class="line">	bne	fixnext</span><br><span class="line"></span><br><span class="line">	/* relative fix: increase location by offset */</span><br><span class="line">	add	r0, r0, r4</span><br><span class="line">	ldr	r1, [r0]</span><br><span class="line">	add	r1, r1, r4</span><br><span class="line">	str	r1, [r0]</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3</span><br><span class="line">	blo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line"></span><br><span class="line">#ifdef __XSCALE__</span><br><span class="line">	/*</span><br><span class="line">	 * On xscale, icache must be invalidated and write buffers drained,</span><br><span class="line">	 * even with cache disabled - 4.2.7 of xscale core developer's manual</span><br><span class="line">	 */</span><br><span class="line">	mcr	p15, 0, r0, c7, c7, 0	/* invalidate icache */</span><br><span class="line">	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* ARMv4- don't know bx lr but the assembler fails to see that */</span><br><span class="line"></span><br><span class="line">#ifdef __ARM_ARCH_4__</span><br><span class="line">	mov        pc, lr</span><br><span class="line">#else</span><br><span class="line">	bx        lr</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></tbody></table></figure>



<p>在进入第一句代码之前，我们先了解一下<code>__image_copy_start</code>和<code>__image_copy_end</code>，在<code>arch/arc/lib/sections.c</code>定义，并通过<code>__attribute__</code>放到了对应段中。在编译之后，这些段有什么用呢？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arc/lib/sections.c</span></span><br><span class="line"><span class="keyword">char</span> __bss_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__bss_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __bss_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__bss_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __image_copy_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__image_copy_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __image_copy_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__image_copy_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __rel_dyn_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__rel_dyn_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __rel_dyn_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__rel_dyn_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __text_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__text_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __text_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__text_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __init_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__init_end"</span>)));</span><br></pre></td></tr></tbody></table></figure>

<p>查看<code>u-boot.lds</code>，在 <code>arch/arm/cpu/u-boot.lds</code>，但这个并不是最终的，最终的链接脚本是在此基础上生成的。需要编译u-boot后会在根目录下才会生成u-boot.lds。</p>
<blockquote>
<p>GNU编译器生成的目标文件缺省为elf格式，elf文件由若干段（section）组成，如不特殊指明，由C源程序生成的目标代码中包含如下段：</p>
<ul>
<li>.text(正文段)包含程序的指令代码；</li>
<li>.data(数据段)包含固定的数据，如常量、字符串；</li>
<li>.bss(未初始化数据段)包含未初始化的变量、数组等。</li>
</ul>
<p>C++源程序生成的目标代码中还包括</p>
<ul>
<li>.fini(析构函数代码)</li>
<li>.init(构造函数代码)等.<br>  链接器的任务就是将多个目标文件的.text、.data和.bss等段链接在一起，而链接脚本文件是告诉链接器从什么地址开始放置这些段.简而言之，由于一个工程中有多个.c文件，当它们生成.o文件后如何安排它们在可执行文件中的顺序，这就是链接脚本的作用.</li>
</ul>
<p>这里以u-boot的lds为例说明uboot的链接过程，首先看一下GNU官方网站上对.lds文件形式的完整描述：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;SECTIONS {</span><br><span class="line">&gt;...</span><br><span class="line">&gt;<span class="function">secname start <span class="title">BLOCK</span><span class="params">(align)</span> <span class="params">(NOLOAD)</span> : <span class="title">AT</span> <span class="params">( ldadr )</span></span></span><br><span class="line"><span class="function">&gt;</span>{ contents } &gt;region :phdr =fill</span><br><span class="line">&gt;...</span><br><span class="line">&gt;}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，secname和contents是必须的，前者用来命名这个段，后者用来确定代码中的什么部分放在这个段，以下是对这个描述中的一些关键字的解释。</p>
<ul>
<li>secname：段名</li>
<li>contents：决定哪些内容放在本段，可以是整个目标文件（如start.o），也可以是目标- 文件中的某段（代码段、数据段等）（如start.o (.text .rodata)）</li>
<li>start：是段的重定位地址，本段链接（运行）的地址，如果代码中有位置无关指令，程序运行时这个段必须放在这个地址上。start可以用任意一种描述地址的符号来描述。<br>  AT（ldadr）：定义本段存储（加载）的地址，如果不使用这个选项，则加载地址等于运行地址，通过这个选项可以控制各段分别保存于输出文件中不同的位置。</li>
</ul>
</blockquote>
<p>上面我们了解到lds文件的格式之后，就可以直接阅读下面的lds文件， <code>. = 0x00000000;</code>定义当前位置为<code>0x00000000</code>; 紧接着<code>.text:{...}</code>，所以.text的相对地址也是0，而在.text中<code>*(.__image_copy_start)</code>又在开始的位置，也就是说把我们前面定义的<code>.__image_copy_start</code>段在链接的时候挪到这个位置当前位置（0x0），紧接着<code>arch/arm/cpu/armv7/start.o (.text*)</code> 将<code>arch/arm/cpu/armv7/start.o</code>中的<code>.text*</code>段全部挪到当前位置（当前位置为 0x0 + <code>.__image_copy_start</code>大小），后面也是如此。</p>
<p>…</p>
<p>将<code>.__image_copy_end</code>挪到<code>.image_copy_end</code>段。所以从<code>.__image_copy_start</code>到<code>.__image_copy_end</code>包括了代码段、只读数据段、读写数据段、<code>.u_boot_list</code>(uboot的命令)。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(<span class="string">"elf32-littlearm"</span>, <span class="string">"elf32-littlearm"</span>, <span class="string">"elf32-littlearm"</span>)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">{</span><br><span class="line"> . = <span class="number">0x00000000</span>;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .text :</span><br><span class="line"> {</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  arch/arm/cpu/armv7/start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> }</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .data : {</span><br><span class="line">  *(.data*)</span><br><span class="line"> }</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> . = .;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .u_boot_list : {</span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line"> }</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .image_copy_end :</span><br><span class="line"> {</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> }</span><br><span class="line"> .rel_dyn_start :</span><br><span class="line"> {</span><br><span class="line">  *(.__rel_dyn_start)</span><br><span class="line"> }</span><br><span class="line"> .rel.dyn : {</span><br><span class="line">  *(.rel*)</span><br><span class="line"> }</span><br><span class="line"> .rel_dyn_end :</span><br><span class="line"> {</span><br><span class="line">  *(.__rel_dyn_end)</span><br><span class="line"> }</span><br><span class="line"> .end :</span><br><span class="line"> {</span><br><span class="line">  *(.__end)</span><br><span class="line"> }</span><br><span class="line"> _image_binary_end = .;</span><br><span class="line"> . = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> .mmutable : {</span><br><span class="line">  *(.mmutable)</span><br><span class="line"> }</span><br><span class="line"> .bss_start __rel_dyn_start (OVERLAY) : {</span><br><span class="line">  KEEP(*(.__bss_start));</span><br><span class="line">  __bss_base = .;</span><br><span class="line"> }</span><br><span class="line"> .bss __bss_base (OVERLAY) : {</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = ALIGN(<span class="number">4</span>);</span><br><span class="line">   __bss_limit = .;</span><br><span class="line"> }</span><br><span class="line"> .bss_end __bss_limit (OVERLAY) : {</span><br><span class="line">  KEEP(*(.__bss_end));</span><br><span class="line"> }</span><br><span class="line"> .dynsym _image_binary_end : { *(.dynsym) }</span><br><span class="line"> .dynbss : { *(.dynbss) }</span><br><span class="line"> .dynstr : { *(.dynstr*) }</span><br><span class="line"> .dynamic : { *(.dynamic*) }</span><br><span class="line"> .plt : { *(.plt*) }</span><br><span class="line"> .interp : { *(.interp*) }</span><br><span class="line"> .gnu.hash : { *(.gnu.hash) }</span><br><span class="line"> .gnu : { *(.gnu*) }</span><br><span class="line"> .ARM.exidx : { *(.ARM.exidx*) }</span><br><span class="line"> .gnu.linkonce.armexidx : { *(.gnu.linkonce.armexidx.*) }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着我们回到代码<code>ldr    r1, =__image_copy_start</code>则是将<code>__image_copy_start</code>的地址取出给到r1，<code>r4=r0-r1</code>,r0为重定位后的代码位置，r1为当前<code>__image_copy_start</code>的位置，那么r4为代码重定位前后的差，也就是<code>重定位的偏移</code>。<code>beq</code>实际上是一个跳转指令<code>b</code>和一个条件变量<code>eq</code>组合起来的，其意思也就是如果相等则跳转到<code>relocate_done</code>。什么意思呢？这个地方怎么可能会相等呢？不对，你在想想，当前代码的起始位置是<code>__image_copy_start</code>，重定位后代码的位置是r0即<code>gd-&gt;relocaddr</code>，当重定位后，当前代码的起始位置是哪呢？不就是<code>gd-&gt;relocaddr</code>，所以此时<code>r0-r1</code>为<code>0</code>，也即满足相等的条件，跳转到<code>relocate_done</code>，不需要重定位（<strong>此处有疑问？该代码上电后会执行两次吗？如果不会执行两次，那么相等这个条件也就不会满足，也就不会有跳转这个分支了。。。。</strong>）。重定位完成后执行xxxxxxx操作后跳出。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	ldr	r1, =__image_copy_start	  /* r1 &lt;- SRC &amp;__image_copy_start */</span><br><span class="line">	subs	r4, r0, r1		       /* r4 &lt;- relocation offset */</span><br><span class="line">	beq	relocate_done		   /* skip relocation */</span><br><span class="line">	ldr	r2, =__image_copy_end    /* r2 &lt;- SRC &amp;__image_copy_end */</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">relocate_done:</span><br><span class="line">#ifdef __XSCALE__</span><br><span class="line">	/*</span><br><span class="line">	 * On xscale, icache must be invalidated and write buffers drained,</span><br><span class="line">	 * even with cache disabled - 4.2.7 of xscale core developer's manual</span><br><span class="line">	 */</span><br><span class="line">	mcr	p15, 0, r0, c7, c7, 0	/* invalidate icache */</span><br><span class="line">	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */</span><br><span class="line">#endif</span><br><span class="line">	...</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></tbody></table></figure>

<p>建议先去寄存器中查看LDM、STM命令以及模式的用法。此时<code>r0=gd-&gt;relocaddr</code>，<code>r1=&amp;__image_copy_start</code>，<code>r2=&amp;__image_copy_end</code></p>
<p>此处从r1地址开始，将数据拷贝r10、r11，每次拷贝后r1地址加4，结束后r1的值为刚开始的值+8。</p>
<p>然后此处从r0地址开始，将r10、r11寄存器中的值拷贝到r0地址处，每次拷贝结束后r0地址加4，所以，结束后r0的值为刚开始的值+8。</p>
<p>比较r1和r2的值，当r1&lt;r2时，跳转到 <code>copy_loop</code>，继续拷贝。直到r1&gt;=r2时，拷贝结束。此时<code>__image_copy_start</code>至<code>__image_copy_end</code>地址的数据已经拷贝到<code>gd-&gt;relocaddr</code>处了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	...</span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, {r10-r11}		/* copy from source address [r1]    */</span><br><span class="line">	stmia	r0!, {r10-r11}		/* copy to   target address [r0]    */</span><br><span class="line">	cmp	r1, r2			          /* until source end address [r2]    */</span><br><span class="line">	blo	copy_loop</span><br><span class="line">	...</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></tbody></table></figure>

<p>接着 <code>r2=__rel_dyn_start</code>，<code>r3=__rel_dyn_end</code>，从r2处加载数据到r0和r1中，取出r1中数据的低8位，与23比较，如果不相等，跳转到<code>fixnext</code>，比较r2、r3，如果r2&lt;r3，说明没修正结束，接着修正；如果相等，<code>r0=r0+r4</code>，停，r4是什么？大家还有印象不，前面我们在刚进入<code>relocate_code</code>，r4为重定位前后的代码的相对地址偏移。所以代码的意思就是r0=r0+r4，然后以r0中存的值为地址取出 已拷贝到新地址的.text段中的值；将该值加上新旧.text段的偏移，在写回到 新的.text段中。这样就完成了重定位。<strong>此处需明白重定位，到底重定位的是什么？</strong></p>
<p>代码解释完了，但是这又是什么意思啊？完全不理解，从<code>.rel.dyn</code>取出的是什么值啊，接下来我们了解了解<code>.rel.dyn</code>段，之后在回来看这段代码，应该就一目了然了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	...</span><br><span class="line">	/*</span><br><span class="line">	 * fix .rel.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	ldr	r2, =__rel_dyn_start	/* r2 &lt;- SRC &amp;__rel_dyn_start */</span><br><span class="line">	ldr	r3, =__rel_dyn_end	/* r3 &lt;- SRC &amp;__rel_dyn_end */</span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, {r0-r1}		/* (r0,r1) &lt;- (SRC location,fixup) */</span><br><span class="line">	and	r1, r1, #0xff</span><br><span class="line">	cmp	r1, #23			/* relative fixup? */</span><br><span class="line">	bne	fixnext</span><br><span class="line"></span><br><span class="line">	/* relative fix: increase location by offset */</span><br><span class="line">	add	r0, r0, r4</span><br><span class="line">	ldr	r1, [r0]</span><br><span class="line">	add	r1, r1, r4</span><br><span class="line">	str	r1, [r0]</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3</span><br><span class="line">	blo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line">	...</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p><code>.rel.dyn</code>  存放<code>.text</code>段中需要重定位地址的集合</p>
<p>接下来我们来说明一个很重要的概念。</p>
<p>　u-boot在启动过程中，会把自己拷贝到RAM的顶端去执行。这一拷贝带来的问题是执行地址的混乱。代码的执行地址通常都是在编译时有链接地址指定的，如何保证拷贝前后都可以执行呢？<br>　　一个办法是使用拷贝到RAM后的地址作为编译时的链接地址，拷贝前所有函数与全局变量的调用都增加偏移量。（如VxWorks的bootloader）尽量减少拷贝前需要执行的代码量。<br>　　另一个办法是把image编译成与地址无关的程序，也就是PIC - Position independent code。编译器无法保证代码的独立性，它需要与加载器配合起来。U-boot自己加载自己，所以它自己就是加载器。PIC依赖于下面两种技术：<br>1） 使用相对地址<br>2） 加载器可以自动更新涉及到绝对地址的指令<br>　　对于PowerPC架构，u-boot只是在编译时使用了-fpic，这种方式会生成一个.got段来存储绝对地址符号。对于ARM架构，则是在编译时使用-mword-relocations，生成与位置无关代码，链接时使用-pie生成.rel.dyn段，该段中的每个条目被称为一个LABEL，用来存储绝对地址符号的地址。</p>
<p>为了理解地址表的概念我们分析一段代码。</p>
<p>借助两个工具 <code>readelf</code>、<code>objdump</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131923808.png"></p>
<p>通过readelf的<code>-r</code>选项查看<code>relocate段</code>，<code>readelf -r u-boot | less</code>打开，看到类型是可重定位段，其中有了<code>offset、info、type</code>以及后面没有为空的项。m每个需要修改地址的信息占用8个字节，第一个为可重定位的地址，第二个为0x17，0x17对应的是Arm32位。那么让我们看一下第一条可重定位地址处（0x20000020）放的是什么？<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204132024704.png"></p>
<p>通过命令 <code>objdump -S u-boot | less</code> ，看到此处存的正是 start.S 中<code>_undefined_instruction: .word undefined_instruction</code>入口地址。</p>
<p>因为这个入口地址如果直接.text段拷贝过去，将来执行跳转的还是旧的uboot里面的undefined_instruction，而不是我们新uboot里面的undefined_instruction，所以这个要修改。</p>
<p>即要修改所有位置有关码的地址。</p>
<p>如何修改？</p>
<p>很简单，<strong>旧的地址的值是什么我们取出来加上 新地址和旧地址的偏移，然后存入新的地址就可以了</strong>。</p>
<p>因为编译器已经帮我们剥离出来要修改的地址和它所属的类型，存放进了rel.dyn段，所以我们只要修改新地址的就可以。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131932905.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131936214.png"></p>
</blockquote>
<p>未定义__ARM_ARCH_4__，所以执行<code>bx lr</code>，而此时<code>lr</code>中的值为<code>here + gd-&gt;reloc_off</code>，怎么解释？此时重定位已经完成，重定位后的地址差值为<code>gd-&gt;reloc_off</code>，<code>here</code> 为<code>here</code>处的相对地址，所以<strong>二者相加后为重定位后的<code>here</code>处的地址</strong>，然后跳回去。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">/* ARMv4- don't know bx lr but the assembler fails to see that */</span><br><span class="line"></span><br><span class="line">#ifdef __ARM_ARCH_4__</span><br><span class="line">	mov        pc, lr</span><br><span class="line">#else</span><br><span class="line">	bx        lr</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204151531408.png"></p>
<h4 id="main-继续，接上文：here"><a href="#main-继续，接上文：here" class="headerlink" title="_main 继续，接上文：here"></a>_main 继续，接上文：here</h4><p>回到<code>here</code>处开始跳转到 <code>c_runtime_cpu_setup</code>，<code>c_runtime_cpu_setup</code>执行结束后返回。</p>
<h5 id="negative-squared-cross-mark-c-runtime-cpu-setup"><a href="#negative-squared-cross-mark-c-runtime-cpu-setup" class="headerlink" title=":negative_squared_cross_mark: c_runtime_cpu_setup"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> c_runtime_cpu_setup</h5><p><code>c_runtime_cpu_setup</code>位于 <code>arch/arm/cpu/armv7/start.S</code>，</p>
<p>配置协处理器CP15</p>
<p>加载程序起始地址到r0，设置<code>CP15 VBAR register</code> </p>
<p><strong>TODO：待补充</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(c_runtime_cpu_setup)</span><br><span class="line">/*</span><br><span class="line"> * If I-cache is enabled invalidate it</span><br><span class="line"> */</span><br><span class="line">#ifndef CONFIG_SYS_ICACHE_OFF</span><br><span class="line">	mcr	   p15, 0, r0, c7, c5, 0	@ invalidate icache</span><br><span class="line">	mcr     p15, 0, r0, c7, c10, 4	@ DSB</span><br><span class="line">	mcr     p15, 0, r0, c7, c5, 4	@ ISB</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * Move vector table</span><br><span class="line"> */</span><br><span class="line">	/* Set vector address in CP15 VBAR register */</span><br><span class="line">	ldr     r0, =_start</span><br><span class="line">	mcr     p15, 0, r0, c12, c0, 0  @Set VBAR</span><br><span class="line"></span><br><span class="line">	bx	lr</span><br><span class="line"></span><br><span class="line">ENDPROC(c_runtime_cpu_setup)</span><br></pre></td></tr></tbody></table></figure>



<p>继续执行<code>r0 = __bss_start</code>，<code>r1 = __bss_end</code>，<code>r2 = 0</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">here:</span><br><span class="line"></span><br><span class="line">/* Set up final (full) environment */</span><br><span class="line"></span><br><span class="line">	bl	c_runtime_cpu_setup	/* we still call old routine here */</span><br><span class="line"></span><br><span class="line">	ldr	r0, =__bss_start	/* this is auto-relocated! */</span><br><span class="line">	ldr	r1, =__bss_end		/* this is auto-relocated! */</span><br><span class="line"></span><br><span class="line">	mov	r2, #0x00000000		/* prepare zero to clear BSS */</span><br></pre></td></tr></tbody></table></figure>

<p>将<code>[__bss_start,__bss_end]</code>范围内的内存清零。</p>
<p>比较<code>r0</code>和<code>r1</code>的值，首先<code>r0=r0-r1</code>,当满足条件<code>r0&lt;r1</code>时，将<code>r2</code>中的值0复制给以将<code>r0</code>的值作为地址的内存中，当满足条件<code>r0&lt;r1</code>时，<code>r0=r0+4</code>，当满足条件<code>r0&lt;r1</code>时，跳转到<code>clbss_l</code>处。接着循环，直到二者相等时，不满足条件，继续执行<code>bl coloured_LED_init</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line"></span><br><span class="line">clbss_l:cmp	r0, r1			/* while not at end of BSS */</span><br><span class="line">	strlo	r2, [r0]		/* clear 32-bit BSS word */</span><br><span class="line">	addlo	r0, r0, #4		/* move to next */</span><br><span class="line">	blo	clbss_l</span><br></pre></td></tr></tbody></table></figure>



<p>跳转到coloured_LED_init，跳转到red_led_on，没啥内容。主要关注一下语法即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">    </span><br><span class="line">	bl coloured_LED_init</span><br><span class="line">	bl red_led_on</span><br><span class="line">------------------------------</span><br><span class="line">// common/board_f.c</span><br><span class="line">inline void __coloured_LED_init(void) {}</span><br><span class="line">void coloured_LED_init(void)</span><br><span class="line">        __attribute__((weak, alias("__coloured_LED_init")));</span><br><span class="line">inline void __red_led_on(void) {}</span><br><span class="line">void red_led_on(void) __attribute__((weak, alias("__red_led_on")));</span><br></pre></td></tr></tbody></table></figure>



<p><code>r0 = r9 = gd</code>，<code>r1 = [r9(gd) + GD_RELOCADDR]</code>，也就是说<code>r0</code>此时为<code>gd</code>,<code>r1</code>为相对于<code>gd</code>偏移<code>GD_RELOCADDR</code>的地址中的值。</p>
<p>将<code>pc</code>值更改为<code>board_init_r</code>，也就是跳转到<code>board_init_r</code>执行，此处不需要返回。因为要跳转到c代码，而c代码入口有两个参数，有APCS可知前四个整形实参被存入到a1-a4中，也即r0-r3中。此时r0为gd，r1为<code>gd-&gt;relocaddr</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	/* call board_init_r(gd_t *id, ulong dest_addr) */</span><br><span class="line">	mov     r0, r9                  /* gd_t */</span><br><span class="line">	ldr	r1, [r9, #GD_RELOCADDR]		/* dest_addr */</span><br><span class="line">	/* call board_init_r */</span><br><span class="line">	ldr	pc, =board_init_r	/* this is auto-relocated! */</span><br><span class="line"></span><br><span class="line">	/* we should not return here. */</span><br></pre></td></tr></tbody></table></figure>

<p>到此 <code>_main</code>就结束了。</p>
<h4 id="board-init-r"><a href="#board-init-r" class="headerlink" title="board_init_r"></a>board_init_r</h4><p><del><strong>board_init_r</strong>函数位于<code>common/board_r.c</code>中，位置分析错误</del>，可以看下<code>common/Makefile</code>，通过命令查找 <code>grep -nr CONFIG_SYS_GENERIC_BOARD</code>有关其定义，在我们的<code>smart210.h</code>中并没有定义这个宏，所以调用的<code>board_init_r</code>不在此处的<code>board_r.c</code>中。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> boards</span></span><br><span class="line"><span class="meta">obj-$</span><span class="bash">(CONFIG_SYS_GENERIC_BOARD) += board_f.o</span></span><br><span class="line"><span class="meta">obj-$</span><span class="bash">(CONFIG_SYS_GENERIC_BOARD) += board_r.o</span></span><br></pre></td></tr></tbody></table></figure>

<p>所以 <code>board_init_r</code>函数其实位于 <code>arch/arm/lib/board.c</code>，跟<code>board_init_f</code>函数位于同一个文件中。</p>
<p>代码如下，我滴个老天爷这也太多了吧。一点点来，先把没用到的宏开关去掉。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ulong malloc_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CONFIG_SYS_NO_FLASH)</span></span><br><span class="line">	ulong flash_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	gd-&gt;flags |= GD_FLG_RELOC;	<span class="comment">/* tell others: relocation done */</span></span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, <span class="string">"board_init_r"</span>);</span><br><span class="line"></span><br><span class="line">	monitor_flash_len = (ulong)&amp;__rel_dyn_end - (ulong)_start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Enable caches */</span></span><br><span class="line">	enable_caches();</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"monitor flash len: %08lX\n"</span>, monitor_flash_len);</span><br><span class="line">	board_init();	<span class="comment">/* Setup chipselects */</span></span><br><span class="line">    </span><br><span class="line">	serial_initialize();</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"Now running in RAM - U-Boot at: %08lx\n"</span>, dest_addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The Malloc area is immediately below the monitor copy in DRAM */</span></span><br><span class="line">	malloc_start = dest_addr - TOTAL_MALLOC_LEN;</span><br><span class="line">	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_EARLY_INIT_R</span></span><br><span class="line">	arch_early_init_r();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	power_init_board();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CONFIG_SYS_NO_FLASH)</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Flash: "</span>);</span><br><span class="line"></span><br><span class="line">	flash_size = flash_init();</span><br><span class="line">	<span class="keyword">if</span> (flash_size &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> CONFIG_SYS_FLASH_CHECKSUM</span></span><br><span class="line">		print_size(flash_size, <span class="string">""</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Compute and print flash CRC if flashchecksum is set to 'y'</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">NOTE:</span> Maybe we should add some WATCHDOG_RESET()? XXX</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (getenv_yesno(<span class="string">"flashchecksum"</span>) == <span class="number">1</span>) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"  CRC: %08X"</span>, crc32(<span class="number">0</span>,</span><br><span class="line">				(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) CONFIG_SYS_FLASH_BASE,</span><br><span class="line">				flash_size));</span><br><span class="line">		}</span><br><span class="line">		putc(<span class="string">'\n'</span>);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span>	<span class="comment">/* !CONFIG_SYS_FLASH_CHECKSUM */</span></span></span><br><span class="line">		print_size(flash_size, <span class="string">"\n"</span>);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SYS_FLASH_CHECKSUM */</span></span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="built_in">puts</span>(failed);</span><br><span class="line">		hang();</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CMD_NAND)</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"NAND:  "</span>);</span><br><span class="line">	nand_init();		<span class="comment">/* go init the NAND */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAS_DATAFLASH</span></span><br><span class="line">	AT91F_DataflashInit();</span><br><span class="line">	dataflash_print_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize environment */</span></span><br><span class="line">	<span class="keyword">if</span> (should_load_env())</span><br><span class="line">		env_relocate();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		set_default_env(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	stdio_init();	<span class="comment">/* get the devices list going. */</span></span><br><span class="line"></span><br><span class="line">	jumptable_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_API)</span></span><br><span class="line">	<span class="comment">/* Initialize API */</span></span><br><span class="line">	api_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	console_init_r();	<span class="comment">/* fully init console as a device */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DISPLAY_BOARDINFO_LATE</span></span><br><span class="line">	checkboard();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ARCH_MISC_INIT)</span></span><br><span class="line">	<span class="comment">/* miscellaneous arch dependent initialisations */</span></span><br><span class="line">	arch_misc_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MISC_INIT_R)</span></span><br><span class="line">	<span class="comment">/* miscellaneous platform dependent initialisations */</span></span><br><span class="line">	misc_init_r();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* set up exceptions */</span></span><br><span class="line">	interrupt_init();</span><br><span class="line">	<span class="comment">/* enable exceptions */</span></span><br><span class="line">	enable_interrupts();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize from environment */</span></span><br><span class="line">	load_addr = getenv_ulong(<span class="string">"loadaddr"</span>, <span class="number">16</span>, load_addr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOARD_LATE_INIT</span></span><br><span class="line">	board_late_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BITBANGMII</span></span><br><span class="line">	bb_miiphy_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CMD_NET)</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Net:   "</span>);</span><br><span class="line">	eth_initialize(gd-&gt;bd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_RESET_PHY_R)</span></span><br><span class="line">	debug(<span class="string">"Reset Ethernet PHY\n"</span>);</span><br><span class="line">	reset_phy();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_POST</span></span><br><span class="line">	post_run(<span class="literal">NULL</span>, POST_RAM | post_bootmode_get(<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Export available size of memory for Linux,</span></span><br><span class="line"><span class="comment">	 * taking into account the protected RAM at top of memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	{</span><br><span class="line">		ulong pram = <span class="number">0</span>;</span><br><span class="line">		uchar memsz[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PRAM</span></span><br><span class="line">		pram = getenv_ulong(<span class="string">"pram"</span>, <span class="number">10</span>, CONFIG_PRAM);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOGBUFFER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ALT_LB_ADDR</span></span><br><span class="line">		<span class="comment">/* Also take the logbuffer into account (pram is in kB) */</span></span><br><span class="line">		pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / <span class="number">1024</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="built_in">sprintf</span>((<span class="keyword">char</span> *)memsz, <span class="string">"%ldk"</span>, (gd-&gt;ram_size / <span class="number">1024</span>) - pram);</span><br><span class="line">		setenv(<span class="string">"mem"</span>, (<span class="keyword">char</span> *)memsz);</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* main_loop() can return to retry autoboot, if so just run it again. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		main_loop();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* NOTREACHED - no way out of command loop except booting */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>分析这个函数，这也太麻烦了。。。。。</p>
<p>先看一部分，首先设置gd中的 flags 告诉其它，我已经重定位完了。然后标记当前段为<code>board_init_r</code>，然后计算flash监控区的长度 从<code>_start</code>到<code>__rel_syn_end</code>包括了代码段、只读数据段、读写数据段、<code>.u_boot_list</code>(uboot的命令)和重定位地址表段。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ulong malloc_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CONFIG_SYS_NO_FLASH)</span></span><br><span class="line">	ulong flash_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	gd-&gt;flags |= GD_FLG_RELOC;	<span class="comment">/* tell others: relocation done */</span></span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, <span class="string">"board_init_r"</span>);</span><br><span class="line"></span><br><span class="line">	monitor_flash_len = (ulong)&amp;__rel_dyn_end - (ulong)_start;</span><br><span class="line">        ...</span><br><span class="line">	<span class="comment">/* NOTREACHED - no way out of command loop except booting */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="enable-caches"><a href="#enable-caches" class="headerlink" title="enable_caches"></a>enable_caches</h5><p>看下 enable_caches 函数的实现。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">        enable_caches();</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 <code>arch/arm/lib/cache.c</code>为默认实现，其也就是打印一下cache未开启。在此处，需注意下，<code>__attribute__</code>的高级用法，声明一个弱符号函数，如果外部没有实现enable_caches，就去调用默认的。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/cache.c</span></span><br><span class="line"><span class="keyword">void</span> __enable_caches(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"WARNING: Caches not enabled\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_caches</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	__<span class="title">attribute__</span><span class="params">((weak, alias(<span class="string">"__enable_caches"</span>)))</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h5 id="negative-squared-cross-mark-board-init"><a href="#negative-squared-cross-mark-board-init" class="headerlink" title=":negative_squared_cross_mark: board_init"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> board_init</h5><p>接着我们看下board_init，网卡的初始化</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">        board_init();</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>board_init是在对应的板卡文件中实现的，实现dm9000网卡的初始化，配置板卡的类型代号以及板卡中boot的参数区，起始地址为<code>PHYS_SDRAM_1 + 0x100</code>，也即<code>0x20000100</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// board/samsung/smart210/smart210.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">board_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//smc9115_pre_init();</span></span><br><span class="line">	dm9000_pre_init();</span><br><span class="line"></span><br><span class="line">	gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDKV210;</span><br><span class="line">	gd-&gt;bd-&gt;bi_boot_params = PHYS_SDRAM_1 + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着看一下网卡的预初始化。呃，定义两个参数，对两个参数赋值，然后在将两个参数写入到SROM中。<strong>这个值怎么来的呢？</strong></p>
<p>smc_bw_conf 和 smc_bc_conf的配置可查看<code>S5PV210_UM_REV1.1.pdf</code>中<code>2.4.1.1 SROM Bus Width</code>与<code>2.4.1.2 SROM Bank Control Register</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// board/samsung/smart210/smart210.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dm9000_pre_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	u32 smc_bw_conf, smc_bc_conf;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Ethernet needs bus width of 16 bits */</span></span><br><span class="line">	smc_bw_conf = SMC_DATA16_WIDTH(CONFIG_ENV_SROM_BANK)</span><br><span class="line">		| SMC_BYTE_ADDR_MODE(CONFIG_ENV_SROM_BANK);</span><br><span class="line">	smc_bc_conf = SMC_BC_TACS(<span class="number">0</span>) | SMC_BC_TCOS(<span class="number">1</span>) | SMC_BC_TACC(<span class="number">2</span>)</span><br><span class="line">		| SMC_BC_TCOH(<span class="number">1</span>) | SMC_BC_TAH(<span class="number">0</span>) | SMC_BC_TACP(<span class="number">0</span>) | SMC_BC_PMC(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Select and configure the SROMC bank */</span></span><br><span class="line">	s5p_config_sromc(CONFIG_ENV_SROM_BANK, smc_bw_conf, smc_bc_conf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段展开也太多了，先留着，后续仔细分析<strong>TODO</strong></p>
<p>首先我们了解一下板卡硬件是怎么连的，由于是百兆口，只有四根线</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网线 			   &lt;---&gt; RJ45(HR911105A) 		 	&lt;---&gt; phy(DM9000A)  &lt;---&gt; 芯片(s5pv210)</span><br><span class="line">4根线	      			   自带变压器转换信号也还是4根线 		</span><br><span class="line">两组差分信号 			两组差分信号</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204151450950.png"></p>
<h5 id="serial-initialize"><a href="#serial-initialize" class="headerlink" title="serial_initialize"></a>serial_initialize</h5><p>上面讲了，看 <a href="#serial_init">serial_init</a></p>
<h5 id="mem-malloc-init"><a href="#mem-malloc-init" class="headerlink" title="mem_malloc_init"></a>mem_malloc_init</h5><p>接着是计算malloc内存的起始地址和初始化</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">        malloc_start = dest_addr - TOTAL_MALLOC_LEN;</span><br><span class="line">	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>计算<code>malloc_start</code>的地址，由<a href="#c_runtime_cpu_setup">c_runtime_cpu_setup</a>可知<code>gd-&gt;relocaddr</code>为<code>board_init_r</code>函数的第二个参数，也即<code>dest_addr=gd-&gt;relocaddr</code>，</p>
<p>而 <code>TOTAL_MALLOC_LEN</code>被定义为<code>(CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)=（CONFIG_ENV_SIZE + (1&lt;&lt;20) + CONFIG_ENV_SIZE）= 128&lt;&lt;10 * 2 + 1&lt;&lt;20=256k+1024k=1280k</code>，所以通过<code>dest_addr-TOTAL_MALLOC_LEN</code>获得可分配的最低位置。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	TOTAL_MALLOC_LEN	(CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204151531408.png"></p>
<p>接着便是对这段范围内的内存初始化，设置malloc的开始、结束及brk的位置，并将内存内的数据清零。由于未定义<code>CONFIG_NEEDS_MANUAL_RELOC</code>宏，所以此处<code>malloc_bin_reloc</code>为空。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/dlmalloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_malloc_init</span><span class="params">(ulong start, ulong size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	mem_malloc_start = start;</span><br><span class="line">	mem_malloc_end = start + size;</span><br><span class="line">	mem_malloc_brk = start;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>((<span class="keyword">void</span> *)mem_malloc_start, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">	malloc_bin_reloc();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="power-init-board"><a href="#power-init-board" class="headerlink" title="power_init_board"></a>power_init_board</h5><p>电源初始化，由于未定义<code>CONFIG_POWER</code>宏，所以此处实现为空</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__weak <span class="keyword">int</span> <span class="title">power_init_board</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="nand-init"><a href="#nand-init" class="headerlink" title="nand_init"></a>nand_init</h5><p>此处开始初始化nand，跳转到nand_init看一下。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CMD_NAND)</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"NAND:  "</span>);</span><br><span class="line">	nand_init();		<span class="comment">/* go init the NAND */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于我们没有定义<code>CONFIG_SYS_NAND_SELF_INIT</code>，CONFIG_SYS_MAX_NAND_DEVICE大小为1，所以会进入下面的循环初始化中，<code>CONFIG_SYS_NAND_SELECT_DEVICE</code>没有定义，所以此函数中进有<code>nand_init_chip(0);</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/mtd/nand/nand.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nand_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_NAND_SELF_INIT</span></span><br><span class="line">	board_nand_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CONFIG_SYS_MAX_NAND_DEVICE; i++)</span><br><span class="line">		nand_init_chip(i);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lu MiB\n"</span>, total_nand_size / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_NAND_SELECT_DEVICE</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Select the chip in the board/cpu specific driver</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	board_nand_select_device(nand_info[nand_curr_device].priv, nand_curr_device);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着进入<code>nand_init_chip</code>，了解<code>mtd_info</code>、<code>nand_info</code>结构体，mtd指向全局变量nand_info，这个变量就是nand设备的信息；再看初始化：mtd-&gt;private=nand; mtd的私有数据就是一个指向<code>struct nand_chip</code>类型的结构体</p>
<blockquote>
<p>从编程的角度来说，一个硬件驱动应该有两个面，一个面向上层，提供接口；一个面向底层，提供硬件操作。</p>
<p>从广义上来看：</p>
<p><code>struct mtd_info</code> 就是面向上层，提供数据接口</p>
<p><code>struct nand_chip</code> 面向nand设备，提供硬件接口</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/mtd/nand/nand.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SYS_NAND_SELF_INIT</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nand_init_chip</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">mtd</span> =</span> &amp;nand_info[i];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">nand</span> =</span> &amp;nand_chip[i];</span><br><span class="line">	ulong base_addr = base_address[i];</span><br><span class="line">	<span class="keyword">int</span> maxchips = CONFIG_SYS_NAND_MAX_CHIPS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (maxchips &lt; <span class="number">1</span>)</span><br><span class="line">		maxchips = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	mtd-&gt;priv = nand;</span><br><span class="line">	nand-&gt;IO_ADDR_R = nand-&gt;IO_ADDR_W = (<span class="keyword">void</span>  __iomem *)base_addr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (board_nand_init(nand))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nand_scan(mtd, maxchips))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	nand_register(i);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>基于这个思路，看一下<code>struct mtd_info</code>，记住几个</p>
<blockquote>
<p><strong>mtd_info</strong>描述原始设备层的一个分区的结构, 描述一个设备或一个多分区设备中的一个分区</p>
<ul>
<li>type MTD设备类型，有MTD_RAM、MTD_ROM、MTD_NORFLASH、MTD_NAND_FLASH等</li>
<li>flags 读写及权限标志位，有MTD_WRITEABLE、MTD_BIT_WRITEABLE、MTD_NO_ERASE、MTD_UP_LOCK</li>
<li>size MTD设备的大小</li>
<li>erase 主要擦除块的大小，NandFlash 就是块的大小</li>
<li>writesize 最小可写字节数，NandFlash 对应着”页”</li>
<li>oobsize 一个blokc中可用的oob的字节数</li>
<li>oobavail 一个block中可用oob字节数</li>
<li>接着下面就是一些函数指针，用于上层调用</li>
<li>priv 私有数据指针</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> {</span></span><br><span class="line">	u_char type;		<span class="comment">/* 设备类型 */</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> flags;</span><br><span class="line">	<span class="keyword">uint64_t</span> size;	 <span class="comment">/* Total size of the MTD */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* "Major" erase size for the device. Naïve users may take this</span></span><br><span class="line"><span class="comment">	 * to be the only erase size available, or may use the more detailed</span></span><br><span class="line"><span class="comment">	 * information below if they desire</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> erasesize;</span><br><span class="line">	<span class="comment">/* Minimal writable flash unit size. In case of NOR flash it is 1 (even</span></span><br><span class="line"><span class="comment">	 * though individual bits can be cleared), in case of NAND flash it is</span></span><br><span class="line"><span class="comment">	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR</span></span><br><span class="line"><span class="comment">	 * it is of ECC block size, etc. It is illegal to have writesize = 0.</span></span><br><span class="line"><span class="comment">	 * Any driver registering a struct mtd_info must ensure a writesize of</span></span><br><span class="line"><span class="comment">	 * 1 or larger.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> writesize;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">u_int32_t</span> oobsize;   <span class="comment">/* Amount of OOB data per block (e.g. 16) */</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> oobavail;  <span class="comment">/* Available OOB bytes per block */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * read ops return -EUCLEAN if max number of bitflips corrected on any</span></span><br><span class="line"><span class="comment">	 * one region comprising an ecc step equals or exceeds this value.</span></span><br><span class="line"><span class="comment">	 * Settable by driver, else defaults to ecc_strength.  User can override</span></span><br><span class="line"><span class="comment">	 * in sysfs.  N.B. The meaning of the -EUCLEAN return code has changed;</span></span><br><span class="line"><span class="comment">	 * see Documentation/ABI/testing/sysfs-class-mtd for more detail.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bitflip_threshold;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Kernel-only stuff starts here. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ECC layout structure pointer - read only! */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nand_ecclayout</span> *<span class="title">ecclayout</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* max number of correctible bit errors per ecc step */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ecc_strength;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Data for variable erase regions. If numeraseregions is zero,</span></span><br><span class="line"><span class="comment">	 * it means that the whole device has erasesize as given above.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> numeraseregions;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_erase_region_info</span> *<span class="title">eraseregions</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do not call via these pointers, use corresponding mtd_*()</span></span><br><span class="line"><span class="comment">	 * wrappers instead.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*_erase) (struct mtd_info *mtd, struct erase_info *instr);</span><br><span class="line">	<span class="keyword">int</span> (*_point) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len,</span><br><span class="line">			<span class="keyword">size_t</span> *retlen, <span class="keyword">void</span> **virt, <span class="keyword">phys_addr_t</span> *phys);</span><br><span class="line">	<span class="keyword">void</span> (*_unpoint) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_read) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len,</span><br><span class="line">		     <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_write) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len,</span><br><span class="line">		      <span class="keyword">size_t</span> *retlen, <span class="keyword">const</span> u_char *buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In blackbox flight recorder like scenarios we want to make successful</span></span><br><span class="line"><span class="comment">	   writes in interrupt context. panic_write() is only intended to be</span></span><br><span class="line"><span class="comment">	   called when its known the kernel is about to panic and we need the</span></span><br><span class="line"><span class="comment">	   write to succeed. Since the kernel is not going to be running for much</span></span><br><span class="line"><span class="comment">	   longer, this function can break locks and delay to ensure the write</span></span><br><span class="line"><span class="comment">	   succeeds (but not sleep). */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*_panic_write) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, <span class="keyword">const</span> u_char *buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*_read_oob) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,</span><br><span class="line">			 struct mtd_oob_ops *ops);</span><br><span class="line">	<span class="keyword">int</span> (*_write_oob) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to,</span><br><span class="line">			 struct mtd_oob_ops *ops);</span><br><span class="line">	<span class="keyword">int</span> (*_get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf,</span><br><span class="line">				   <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_read_fact_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,</span><br><span class="line">				   <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf,</span><br><span class="line">				   <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_read_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,</span><br><span class="line">				   <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_write_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len,</span><br><span class="line">				    <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_lock_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,</span><br><span class="line">				   <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="keyword">void</span> (*_sync) (struct mtd_info *mtd);</span><br><span class="line">	<span class="keyword">int</span> (*_lock) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_unlock) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_block_isbad) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line">	<span class="keyword">int</span> (*_block_markbad) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the driver is something smart, like UBI, it may need to maintain</span></span><br><span class="line"><span class="comment">	 * its own reference counting. The below functions are only for driver.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*_get_device) (struct mtd_info *mtd);</span><br><span class="line">	<span class="keyword">void</span> (*_put_device) (struct mtd_info *mtd);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* ECC status information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_ecc_stats</span> <span class="title">ecc_stats</span>;</span></span><br><span class="line">	<span class="comment">/* Subpage shift (NAND) */</span></span><br><span class="line">	<span class="keyword">int</span> subpage_sft;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *priv;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">int</span> usecount;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>结构知道了，其值在哪定义的呢，在同文件下，定义了一个结构体数组，其大小为<code>CONFIG_SYS_MAX_NAND_DEVICE</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nand_info_t</span> nand_info[CONFIG_SYS_MAX_NAND_DEVICE];</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> <span class="comment">// include/configs/smart210.h</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MAX_NAND_DEVICE  1</span></span><br></pre></td></tr></tbody></table></figure>

<p>接着看<code>mtd-&gt;priv = nand</code>也就是将nand的结构体指针给了mtd的私有变量，说明mtd的下层操作的设备为nand。接着往下走，<code>board_nand_init(nand)</code>初始化nand，配置nand一些参数及操作（代码可见<code>drivers/mtd/nand/s5pv210_nand.c</code>中的<code>board_nand_init</code>）。</p>
<p><code>nand_scan_ident</code>扫描设备，获取当前mtd中的私有变量<code>priv</code>中的数据结构（刚刚我们在<code>nand_init_chip</code>函数中赋值priv为nand，实际是全局变量，并经<code>board_nand_init</code>初始化），获取buswidth并设置、获取chip数量和大小。</p>
<p><code>nand_scan_tail</code>用默认值填充所有未初始化的函数指针</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nand_scan(mtd, maxchips)</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment">// drivers/mtd/nand/nand_base.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nand_scan</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> maxchips)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	ret = nand_scan_ident(mtd, maxchips, <span class="literal">NULL</span>); <span class="comment">// 获取当前mtd下</span></span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		ret = nand_scan_tail(mtd);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还有一个注册函数，其实就是配置设备名称，形如<code>nand0</code>，然后计算总的<code>total_nand_size</code>大小，并将上面的<code>&amp;nand_info[devnum]</code>添加到<code>mtd_table</code>中，over。这个地方就结束了，其实想要更深层次的了解最好去看下<a href="#%E5%8F%82%E8%80%83">参考22</a>。</p>
<p>总结一下，其实就是定义了2个结构体数组，分别为<code>nand_info</code>、<code>nand_chip</code>，分别初始化，然后赋值，<code>&amp;nand_info[0]-&gt;prvi=&amp;nand_chip[0]</code>，并在<code>nand_chip</code>中实现对应的操作函数。之后呢，在将<code>&amp;nand_info[0]</code>放到<code>mtd_table</code>中，后续在使用时应该就是上层直接使用<code>mtd_table</code>来完成相应的操作。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nand_register</span><span class="params">(<span class="keyword">int</span> devnum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">mtd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (devnum &gt;= CONFIG_SYS_MAX_NAND_DEVICE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	mtd = &amp;nand_info[devnum];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(dev_name[devnum], <span class="string">"nand%d"</span>, devnum);</span><br><span class="line">	mtd-&gt;name = dev_name[devnum];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MTD_DEVICE</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Add MTD device so that we can reference it later</span></span><br><span class="line"><span class="comment">	 * via the mtdcore infrastructure (e.g. ubi).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	add_mtd_device(mtd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	total_nand_size += mtd-&gt;size / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nand_curr_device == <span class="number">-1</span>)</span><br><span class="line">		nand_curr_device = devnum;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="should-load-env"><a href="#should-load-env" class="headerlink" title="should_load_env"></a>should_load_env</h5><p>发现 <code>CONFIG_OF_CONTROL</code>、<code>CONFIG_DELAY_ENVIRONMENT</code>均没有定义，返回1。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* initialize environment */</span></span><br><span class="line">	<span class="keyword">if</span> (should_load_env())</span><br><span class="line">		env_relocate();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		set_default_env(<span class="literal">NULL</span>);</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>也就是<code>env_relocate()</code>，由于<code>CONFIG_NEEDS_MANUAL_RELOC</code>、<code>CONFIG_ENV_IS_NOWHERE</code>没有定义</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_relocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;env_valid == <span class="number">0</span>) {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)</span></span><br><span class="line">		<span class="comment">/* Environment not changable */</span></span><br><span class="line">		set_default_env(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);</span><br><span class="line">		set_default_env(<span class="string">"!bad CRC"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		env_relocate_spec();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以代码可精简为如下, 由于在<a href="#env_init">env_init</a>中配置为1，所以此处走<code>else</code>分支。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_relocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;env_valid == <span class="number">0</span>) {</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);</span><br><span class="line">		set_default_env(<span class="string">"!bad CRC"</span>);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		env_relocate_spec();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 由于上述我们使用的为nand，所以此处env_relocate_spec位置在<code>common/env_nand.c</code>中，先看下这个又臭又长的宏定义。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/env_nand.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_relocate_spec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	ALLOC_CACHE_ALIGN_BUFFER(<span class="keyword">char</span>, buf, CONFIG_ENV_SIZE);</span><br><span class="line">	ret = readenv(CONFIG_ENV_OFFSET, (u_char *)buf);</span><br><span class="line">	<span class="keyword">if</span> (ret) {</span><br><span class="line">		set_default_env(<span class="string">"!readenv() failed"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	env_import(buf, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看下下面的分析，其实也就是定义了一个数组，然后返回一个数组指针，只不过其中保证了内存对齐，</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/env_nand.c</span></span><br><span class="line">ALLOC_CACHE_ALIGN_BUFFER(<span class="keyword">char</span>, buf, CONFIG_ENV_SIZE);</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// include/common.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOC_CACHE_ALIGN_BUFFER(type, name, size)	ALLOC_ALIGN_BUFFER(type, name, size, ARCH_DMA_MINALIGN)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOC_ALIGN_BUFFER(type, name, size, align)	       ALLOC_ALIGN_BUFFER_PAD(type, name, size, align, 1)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOC_ALIGN_BUFFER_PAD(type, name, size, align, pad)		\</span></span><br><span class="line"><span class="meta">	char __##name[ROUND(PAD_SIZE((size) * sizeof(type), pad), align)  \</span></span><br><span class="line"><span class="meta">		      + (align - 1)];					\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	type *name = (type *) ALIGN((uintptr_t)__##name, align)</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOC_CACHE_ALIGN_BUFFER(type, name, size)  \</span></span><br><span class="line"><span class="meta">	char __##name[ROUND(PAD_SIZE((size) * sizeof(type), 1), ARCH_DMA_MINALIGN)  \</span></span><br><span class="line"><span class="meta">		      + (ARCH_DMA_MINALIGN - 1)];					\</span></span><br><span class="line"><span class="meta">	type *name = (type *) ALIGN((uintptr_t)__##name, ARCH_DMA_MINALIGN)</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------------</span></span><br><span class="line">ALLOC_CACHE_ALIGN_BUFFER(<span class="keyword">char</span>, buf, CONFIG_ENV_SIZE);</span><br><span class="line"><span class="keyword">char</span> __buf[CONFIG_ENV_SIZE];</span><br><span class="line"><span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)ALIGN((<span class="keyword">uintptr_t</span>)__buf,ARCH_DMA_MINALIGN);</span><br></pre></td></tr></tbody></table></figure>

<p>接着看readenv函数，在实际中打印</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readenv</span><br><span class="line">end of readenv,amount_loaded=131072 CONFIG_ENV_SIZE:131072</span><br></pre></td></tr></tbody></table></figure>

<p><code>nand_info[0].erasesize</code>又是在哪赋值的呢？</p>
<p>在<code>nand_init_chip</code>中，没有与<code>mtd-&gt;erasesize</code>相关的，而<code>board_nand_init</code>仅与<code>nand_chip</code>有关，<code>nand_register</code>中也没有与之有关的。</p>
<p>所以一路找下去，最终是在<code>nand_get_flash_type</code>中的<code>nand_decode_id</code>（或者<code>nand_decode_ext_id</code>）获取类型中给<code>mtd-&gt;erasesize</code>赋值的，具体值的大小与nand的厂商有关。 </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--&gt; nand_init</span><br><span class="line">          |</span><br><span class="line">	 --&gt; nand_init_chip</span><br><span class="line">	 		|</span><br><span class="line">	 		--&gt; nand_scan</span><br><span class="line">	 			|</span><br><span class="line">	 			--&gt; nand_scan_ident</span><br><span class="line">	 				|</span><br><span class="line">	 				--&gt; nand_get_flash_type</span><br><span class="line">	 					|</span><br><span class="line">	 					--&gt; nand_decode_ext_id</span><br><span class="line">					        --&gt; nand_decode_id</span><br></pre></td></tr></tbody></table></figure>

<p>从<code>blocksize</code>或者<code>CONFIG_ENV_SIZE</code>中获取最小值，接着一个循环 条件呢？就是总共加载的大小与配置的环境大小相比且当前的偏移小于配置的环境的大小。</p>
<p>先判断当前块是否是坏的，如果是，则跳过，<code>offset += blocksize</code></p>
<p>否则，在里面接着以跳过坏块的方式读，并将读取的环境变量写入<code>buf</code>中，二者相等返回0。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readenv</span><span class="params">(<span class="keyword">size_t</span> offset, u_char *buf)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">size_t</span> end = offset + CONFIG_ENV_RANGE;</span><br><span class="line">	<span class="keyword">size_t</span> amount_loaded = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span> blocksize, len;</span><br><span class="line">	u_char *char_ptr;</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"readenv\r\n"</span>);</span><br><span class="line">	blocksize = nand_info[<span class="number">0</span>].erasesize;</span><br><span class="line">	<span class="keyword">if</span> (!blocksize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	len = min(blocksize, CONFIG_ENV_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (amount_loaded &lt; CONFIG_ENV_SIZE &amp;&amp; offset &lt; end) {</span><br><span class="line">		<span class="keyword">if</span> (nand_block_isbad(&amp;nand_info[<span class="number">0</span>], offset)) {</span><br><span class="line">			offset += blocksize;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			char_ptr = &amp;buf[amount_loaded];</span><br><span class="line">			<span class="keyword">if</span> (nand_read_skip_bad(&amp;nand_info[<span class="number">0</span>], offset,</span><br><span class="line">					       &amp;len, <span class="literal">NULL</span>,</span><br><span class="line">					       nand_info[<span class="number">0</span>].size, char_ptr))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			offset += blocksize;</span><br><span class="line">			amount_loaded += len;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	debug(<span class="string">"end of readenv,amount_loaded=%d CONFIG_ENV_SIZE:%d\r\n"</span>,amount_loaded,CONFIG_ENV_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (amount_loaded != CONFIG_ENV_SIZE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>返回到<code>env_relocate_spec</code>中，执行<code>env_import(buf,1)</code>这个函数是个难点，也是个重点，涉及到对哈希表的操作。</p>
<p>这个函数有两个操作，一个是crc校验；另一个是创建哈希表，并将环境变量中的数据提取出来插入表中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_import</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> check)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">env_t</span> *ep = (<span class="keyword">env_t</span> *)buf;</span><br><span class="line">	debug(<span class="string">"env_import\r\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (check) {</span><br><span class="line">		<span class="keyword">uint32_t</span> crc;</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;crc, &amp;ep-&gt;crc, <span class="keyword">sizeof</span>(crc));</span><br><span class="line">		<span class="keyword">if</span> (crc32(<span class="number">0</span>, ep-&gt;data, ENV_SIZE) != crc) {</span><br><span class="line">			debug(<span class="string">"env_import --&gt; crc32\r\n"</span>);</span><br><span class="line">			set_default_env(<span class="string">"!bad CRC"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (himport_r(&amp;env_htab, (<span class="keyword">char</span> *)ep-&gt;data, ENV_SIZE, <span class="string">'\0'</span>, <span class="number">0</span>,<span class="number">0</span>, <span class="literal">NULL</span>)) {</span><br><span class="line">		debug(<span class="string">"env_import --&gt; himport_r\r\n"</span>);</span><br><span class="line">		gd-&gt;flags |= GD_FLG_ENV_READY;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	error(<span class="string">"Cannot import environment: errno = %d\n"</span>, errno);</span><br><span class="line">	set_default_env(<span class="string">"!import failed"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>主要是分析下创建哈希表和哈希表的插入操作。<strong>TODO：明天挑一段长的时间分析吧！</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/env_common.c</span></span><br><span class="line">himport_r(&amp;env_htab, (<span class="keyword">char</span> *)ep-&gt;data, ENV_SIZE, <span class="string">'\0'</span>, <span class="number">0</span>,<span class="number">0</span>, <span class="literal">NULL</span>) </span><br><span class="line"><span class="comment">// lib/hashtable.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">himport_r</span><span class="params">(struct hsearch_data *htab,<span class="keyword">const</span> <span class="keyword">char</span> *env, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> sep, <span class="keyword">int</span> flag,<span class="keyword">int</span> nvars, <span class="keyword">char</span> * <span class="keyword">const</span> vars[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> *data, *sp, *dp, *name, *value;</span><br><span class="line">	<span class="keyword">char</span> *localvars[nvars];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Test for correct arguments.  */</span></span><br><span class="line">	<span class="keyword">if</span> (htab == <span class="literal">NULL</span>) {</span><br><span class="line">		__set_errno(EINVAL);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we allocate new space to make sure we can write to the array */</span></span><br><span class="line">	<span class="keyword">if</span> ((data = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>) {</span><br><span class="line">		debug(<span class="string">"himport_r: can't malloc %zu bytes\n"</span>, size);</span><br><span class="line">		__set_errno(ENOMEM);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">memcpy</span>(data, env, size);</span><br><span class="line">	dp = data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make a local copy of the list of variables */</span></span><br><span class="line">	<span class="keyword">if</span> (nvars)</span><br><span class="line">		<span class="built_in">memcpy</span>(localvars, vars, <span class="keyword">sizeof</span>(vars[<span class="number">0</span>]) * nvars);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; H_NOCLEAR) == <span class="number">0</span>) {</span><br><span class="line">		<span class="comment">/* Destroy old hash table if one exists */</span></span><br><span class="line">		debug(<span class="string">"Destroy Hash Table: %p table = %p\n"</span>, htab, htab-&gt;table);</span><br><span class="line">		<span class="keyword">if</span> (htab-&gt;table) hdestroy_r(htab);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!htab-&gt;table) {</span><br><span class="line">		<span class="keyword">int</span> nent = CONFIG_ENV_MIN_ENTRIES + size / <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">if</span> (nent &gt; CONFIG_ENV_MAX_ENTRIES) nent = CONFIG_ENV_MAX_ENTRIES;</span><br><span class="line">		debug(<span class="string">"Create Hash Table: N=%d\n"</span>, nent);</span><br><span class="line">		<span class="keyword">if</span> (hcreate_r(nent, htab) == <span class="number">0</span>) {</span><br><span class="line">			<span class="built_in">free</span>(data);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Parse environment; allow for '\0' and 'sep' as separators */</span></span><br><span class="line">	<span class="keyword">do</span> {</span><br><span class="line">		ENTRY e, *rv;</span><br><span class="line">		<span class="comment">/* skip leading white space */</span></span><br><span class="line">		<span class="keyword">while</span> (isblank(*dp))</span><br><span class="line">			++dp;</span><br><span class="line">		<span class="comment">/* skip comment lines */</span></span><br><span class="line">		<span class="keyword">if</span> (*dp == <span class="string">'#'</span>) {</span><br><span class="line">			<span class="keyword">while</span> (*dp &amp;&amp; (*dp != sep))</span><br><span class="line">				++dp;</span><br><span class="line">			++dp;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* parse name */</span></span><br><span class="line">		<span class="keyword">for</span> (name = dp; *dp != <span class="string">'='</span> &amp;&amp; *dp &amp;&amp; *dp != sep; ++dp)</span><br><span class="line">			;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* deal with "name" and "name=" entries (delete var) */</span></span><br><span class="line">		<span class="keyword">if</span> (*dp == <span class="string">'\0'</span> || *(dp + <span class="number">1</span>) == <span class="string">'\0'</span> ||</span><br><span class="line">		    *dp == sep || *(dp + <span class="number">1</span>) == sep) {</span><br><span class="line">			<span class="keyword">if</span> (*dp == <span class="string">'='</span>)</span><br><span class="line">				*dp++ = <span class="string">'\0'</span>;</span><br><span class="line">			*dp++ = <span class="string">'\0'</span>;	<span class="comment">/* terminate name */</span></span><br><span class="line"></span><br><span class="line">			debug(<span class="string">"DELETE CANDIDATE: \"%s\"\n"</span>, name);</span><br><span class="line">			<span class="keyword">if</span> (!drop_var_from_set(name, nvars, localvars))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (hdelete_r(name, htab, flag) == <span class="number">0</span>)</span><br><span class="line">				debug(<span class="string">"DELETE ERROR ##############################\n"</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		*dp++ = <span class="string">'\0'</span>;	<span class="comment">/* terminate name */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* parse value; deal with escapes */</span></span><br><span class="line">		<span class="keyword">for</span> (value = sp = dp; *dp &amp;&amp; (*dp != sep); ++dp) {</span><br><span class="line">			<span class="keyword">if</span> ((*dp == <span class="string">'\\'</span>) &amp;&amp; *(dp + <span class="number">1</span>))</span><br><span class="line">				++dp;</span><br><span class="line">			*sp++ = *dp;</span><br><span class="line">		}</span><br><span class="line">		*sp++ = <span class="string">'\0'</span>;	<span class="comment">/* terminate value */</span></span><br><span class="line">		++dp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*name == <span class="number">0</span>) {</span><br><span class="line">			debug(<span class="string">"INSERT: unable to use an empty key\n"</span>);</span><br><span class="line">			__set_errno(EINVAL);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Skip variables which are not supposed to be processed */</span></span><br><span class="line">		<span class="keyword">if</span> (!drop_var_from_set(name, nvars, localvars))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* enter into hash table */</span></span><br><span class="line">		e.key = name;</span><br><span class="line">		e.data = value;</span><br><span class="line"></span><br><span class="line">		hsearch_r(e, ENTER, &amp;rv, htab, flag);</span><br><span class="line">		<span class="keyword">if</span> (rv == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"himport_r: can't insert \"%s=%s\" into hash table\n"</span>,name, value);</span><br><span class="line">		debug(<span class="string">"INSERT: table %p, filled %d/%d rv %p ==&gt; name=\"%s\" value=\"%s\"\n"</span>,htab, htab-&gt;filled, htab-&gt;size,rv, name, value);</span><br><span class="line">	} <span class="keyword">while</span> ((dp &lt; data + size) &amp;&amp; *dp);	<span class="comment">/* size check needed for text */</span></span><br><span class="line">						<span class="comment">/* without '\0' termination */</span></span><br><span class="line">	debug(<span class="string">"INSERT: free(data = %p)\n"</span>, data);</span><br><span class="line">	<span class="built_in">free</span>(data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nvars; i++) {</span><br><span class="line">		<span class="keyword">if</span> (localvars[i] == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (hdelete_r(localvars[i], htab, flag) == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"WARNING: '%s' neither in running nor in imported env!\n"</span>, localvars[i]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"WARNING: '%s' not in imported env, deleting it!\n"</span>, localvars[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"INSERT: done\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;		<span class="comment">/* everything OK */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先把打印的日志摆这，对着分析还容易点。。。。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Destroy Hash Table: 3ffb4f0c table = 00000000</span><br><span class="line">Create Hash Table: N=512</span><br><span class="line">INSERT: table 3ffb4f0c, filled 1/521 rv 3fe62868 ==&gt; name="baudrate" value="115200"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 2/521 rv 3fe643fc ==&gt; name="bootargs" value="root=/dev/nfs rw nfsroot=10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs ip=10.0.0.98:10.0.0.97:10.0.0.1:255.0.0.0::eth0:off init=/linuxrc console=ttySAC0，115200"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 3/521 rv 3fe62c8c ==&gt; name="bootcmd" value="nfs 20000000 10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs/uImage;nfs 21000000 10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs/s5pv210-smart210.dtb;bootm 20000000 - 21000000"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 4/521 rv 3fe634e8 ==&gt; name="bootdelay" value="1"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 5/521 rv 3fe62bb0 ==&gt; name="ethact" value="dm9000"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 6/521 rv 3fe625fc ==&gt; name="ethaddr" value="1a:2a:3a:4a:5a:6a"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 7/521 rv 3fe64320 ==&gt; name="ipaddr" value="10.0.0.98"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 8/521 rv 3fe6232c ==&gt; name="machid" value="0xffffffff"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 9/521 rv 3fe63e48 ==&gt; name="qqqqq" value="1111"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 10/521 rv 3fe62a84 ==&gt; name="serverip" value="10.0.0.20"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 11/521 rv 3fe62fac ==&gt; name="stderr" value="serial"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 12/521 rv 3fe627c8 ==&gt; name="stdin" value="serial"</span><br><span class="line">INSERT: table 3ffb4f0c, filled 13/521 rv 3fe638f8 ==&gt; name="stdout" value="serial"</span><br><span class="line">INSERT: free(data = 3fe41bd0)</span><br><span class="line">INSERT: done</span><br></pre></td></tr></tbody></table></figure>



<h5 id="negative-squared-cross-mark-stdio-init"><a href="#negative-squared-cross-mark-stdio-init" class="headerlink" title=":negative_squared_cross_mark: stdio_init"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> stdio_init</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	stdio_init();	<span class="comment">/* get the devices list going. */</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为一些宏在smart210.h中未定义，所以 此处留下会执行的代码。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/stdio.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stdio_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* Initialize the list */</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;(devs.<span class="built_in">list</span>));</span><br><span class="line">	drv_system_init ();</span><br><span class="line">	serial_stdio_init ();</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先初始化列表，双向列表的头初始化时 其下一个和前一个节点均指向自身。此处尽管<code>INIT_LIST_HEAD</code>为static函数，但是其在common.h实现，在c中展开相当于仅在当前c中使用。再看下<code>devs.list</code>是什么东西？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此处又引出一个结构体<code>stdio_dev</code>，其中包括标志位、支持的扩展、设备名称、设备操作函数、私有扩展和一个双向列表。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/stdio.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">stdio_dev</span> <span class="title">devs</span>;</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/stdio_dev.h</span></span><br><span class="line"><span class="comment">/* Device information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stdio_dev</span> {</span></span><br><span class="line">	<span class="keyword">int</span>		flags;			 <span class="comment">/* Device flags: input/output/system	*/</span></span><br><span class="line">	<span class="keyword">int</span>		ext;			<span class="comment">/* Supported extensions			*/</span></span><br><span class="line">        <span class="keyword">char</span>	name[<span class="number">16</span>];		<span class="comment">/* Device name				*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GENERAL functions */</span></span><br><span class="line">	<span class="keyword">int</span> (*start) (<span class="keyword">void</span>);		 <span class="comment">/* To start the device			*/</span></span><br><span class="line">	<span class="keyword">int</span> (*stop) (<span class="keyword">void</span>);		       <span class="comment">/* To stop the device			*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* OUTPUT functions */</span></span><br><span class="line">	<span class="keyword">void</span> (*putc) (<span class="keyword">const</span> <span class="keyword">char</span> c);	<span class="comment">/* To put a char			*/</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">puts</span>) (<span class="keyword">const</span> <span class="keyword">char</span> *s);	<span class="comment">/* To put a string (accelerator)	*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* INPUT functions */</span></span><br><span class="line">	<span class="keyword">int</span> (*tstc) (<span class="keyword">void</span>);		<span class="comment">/* To test if a char is ready...	*/</span></span><br><span class="line">	<span class="keyword">int</span> (*getc) (<span class="keyword">void</span>);		<span class="comment">/* To get that char			*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Other functions */</span></span><br><span class="line">	<span class="keyword">void</span> *priv;			<span class="comment">/* Private extensions			*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着看下<strong>drv_system_init</strong>，其中定义了<code>struct stdio_dev dev</code>，然后初始化。最后注册这个结构。直接看下是如何注册的？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/stdio.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drv_system_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stdio_dev</span> <span class="title">dev</span>;</span></span><br><span class="line">	<span class="built_in">memset</span> (&amp;dev, <span class="number">0</span>, <span class="keyword">sizeof</span> (dev));</span><br><span class="line">	<span class="built_in">strcpy</span> (dev.name, <span class="string">"serial"</span>);</span><br><span class="line">	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;</span><br><span class="line">	dev.putc = serial_putc;</span><br><span class="line">	dev.<span class="built_in">puts</span> = serial_puts;</span><br><span class="line">	dev.getc = serial_getc;</span><br><span class="line">	dev.tstc = serial_tstc;</span><br><span class="line">	stdio_register (&amp;dev);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在注册函数中，首先克隆一个当前的结构（先分配空间，在拷贝数据），然后把克隆出的结构体在挂到<code>devs.list</code>上（<code>TODO：此处待理解双向列表添加后在分析</code>）。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/stdio.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stdio_register</span> <span class="params">(struct stdio_dev * dev)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stdio_dev</span> *_<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	_dev = stdio_clone(dev);</span><br><span class="line">	<span class="keyword">if</span>(!_dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	list_add_tail(&amp;(_dev-&gt;<span class="built_in">list</span>), &amp;(devs.<span class="built_in">list</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再看下 <code>serial_stdio_init</code>，<code>serial_devices</code>不知各位看官姥爷还有没有印象，反正笔者是没有印象了。。。。好了，话说回来，在<a href="#serial_init">serial_init</a>中我们分析了串口的初始化，其节点都挂到 <code>serial_devices</code>列表中，<code>serial_current</code>中保存着当前串口的指针。</p>
<p>这段代码的意思是 遍历<code>serial_devices</code>中的所有节点，将其添加到<code>devs</code>中去。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_stdio_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stdio_dev</span> <span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> *<span class="title">s</span> =</span> serial_devices;</span><br><span class="line">	<span class="keyword">while</span> (s) {</span><br><span class="line">		<span class="built_in">memset</span>(&amp;dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev));</span><br><span class="line">		<span class="built_in">strcpy</span>(dev.name, s-&gt;name);</span><br><span class="line">		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;</span><br><span class="line">		dev.start = s-&gt;start;</span><br><span class="line">		dev.stop = s-&gt;stop;</span><br><span class="line">		dev.putc = s-&gt;putc;</span><br><span class="line">		dev.<span class="built_in">puts</span> = s-&gt;<span class="built_in">puts</span>;</span><br><span class="line">		dev.getc = s-&gt;getc;</span><br><span class="line">		dev.tstc = s-&gt;tstc;</span><br><span class="line">		stdio_register(&amp;dev);</span><br><span class="line">		s = s-&gt;next;	<span class="comment">// 移到下一个节点</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="jumptable-init"><a href="#jumptable-init" class="headerlink" title="jumptable_init"></a>jumptable_init</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	jumptable_init();</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>common/exports.c</code>中实现</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/exports.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jumptable_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;jt = <span class="built_in">malloc</span>(XF_MAX * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;_exports.h&gt;</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>手动模拟编译器展开（滑稽）看一下，此处只需要记住，宏直接展开。注意下在<code>exports.c</code>中包含<code>exports.h</code>，而<code>exports.h</code>定义了一个enum，那个enum展开后对应的恰是<code>_exports.h</code>中的所有函数的索引（<code>0</code>开始，<code>XF_MAX</code>结束，所以前面分配内存时可直接<code>XF_MAX</code>）。所以在<code>exports.c</code>就可以直接使用索引访问数组并给每个数组变量赋值。至于这些个函数就不一一分析了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/exports.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT_FUNC(sym) gd-&gt;jt[XF_##sym] = (void *)sym;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jumptable_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;jt = <span class="built_in">malloc</span>(XF_MAX * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">        EXPORT_FUNC(get_version)</span><br><span class="line">        EXPORT_FUNC(getc)</span><br><span class="line">        EXPORT_FUNC(tstc)</span><br><span class="line">        EXPORT_FUNC(putc)</span><br><span class="line">        EXPORT_FUNC(<span class="built_in">puts</span>)</span><br><span class="line">        EXPORT_FUNC(<span class="built_in">printf</span>)</span><br><span class="line">        EXPORT_FUNC(install_hdlr)</span><br><span class="line">        EXPORT_FUNC(free_hdlr)</span><br><span class="line">        ...</span><br><span class="line">        EXPORT_FUNC(spi_xfer)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jumptable_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;jt = <span class="built_in">malloc</span>(XF_MAX * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">         gd-&gt;jt[XF_getc] = (<span class="keyword">void</span> *)get_c;</span><br><span class="line">	gd-&gt;jt[XF_get_version] = (<span class="keyword">void</span> *)get_version;</span><br><span class="line">	gd-&gt;jt[XF_tstc] = (<span class="keyword">void</span> *)tstc;</span><br><span class="line">	gd-&gt;jt[XF_putc] = (<span class="keyword">void</span> *)putc;</span><br><span class="line">	gd-&gt;jt[XF_puts] = (<span class="keyword">void</span> *)<span class="built_in">puts</span>;</span><br><span class="line">	gd-&gt;jt[XF_printf] = (<span class="keyword">void</span> *)<span class="built_in">printf</span>;</span><br><span class="line">	gd-&gt;jt[XF_install_hdlr] = (<span class="keyword">void</span> *)install_hdlr;</span><br><span class="line">	gd-&gt;jt[XF_free_hdlr] = (<span class="keyword">void</span> *)free_hdlr;</span><br><span class="line">	...</span><br><span class="line">         gd-&gt;jt[XF_spi_xfer] = (<span class="keyword">void</span> *)spi_xfer;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于头文件一般都在函数之前，所以此处定义<code>EXPORT_FUNC(x)</code>不会出错，待使用结束后<code>undef</code>，所以后面使用时也没有问题。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT_FUNC(x) XF_ ## x ,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;_exports.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EXPORT_FUNC</span></span><br><span class="line"></span><br><span class="line">	XF_MAX</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h5 id="console-init-r"><a href="#console-init-r" class="headerlink" title="console_init_r"></a>console_init_r</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	console_init_r();	<span class="comment">/* fully init console as a device */</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看下<code>CONFIG_SYS_CONSOLE_IS_IN_ENV</code>宏是否定义，没有定义，那么代码就是下面这一段。</p>
<p><code>list_for_each(pos, list)</code>是一个迭代器，好吧，也就是一个<code>for</code>循环，但是注意里面有一个<code>prefetch</code>，此处需分析一下。<code>TODO：待分析</code></p>
<p>然后<code>list_entry</code>也需要分析一下。<code>TODO：待分析</code></p>
<p>这个循环的目的，根据标志位判断输入输出节点，并将其赋值给<code>inputdev</code>、<code>outputdev</code>，如果这两者都有的话，结束这个循环。</p>
<p>一个<code>console_setfile</code>将dev设置到<code>stdio_devices[i]</code>，同时也设给<code>console_devices[i][0]</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/console.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">console_init_r</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stdio_dev</span> *<span class="title">inputdev</span> =</span> <span class="literal">NULL</span>, *outputdev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span> =</span> stdio_get_list();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">pos</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stdio_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Scan devices looking for input and output devices */</span></span><br><span class="line">	list_for_each(pos, <span class="built_in">list</span>) {</span><br><span class="line">		dev = list_entry(pos, struct stdio_dev, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((dev-&gt;flags &amp; DEV_FLAGS_INPUT) &amp;&amp; (inputdev == <span class="literal">NULL</span>)) {</span><br><span class="line">			inputdev = dev;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> ((dev-&gt;flags &amp; DEV_FLAGS_OUTPUT) &amp;&amp; (outputdev == <span class="literal">NULL</span>)) {</span><br><span class="line">			outputdev = dev;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(inputdev &amp;&amp; outputdev)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initializes output console first */</span></span><br><span class="line">	<span class="keyword">if</span> (outputdev != <span class="literal">NULL</span>) {</span><br><span class="line">		console_setfile(<span class="built_in">stdout</span>, outputdev);</span><br><span class="line">		console_setfile(<span class="built_in">stderr</span>, outputdev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_MUX</span></span><br><span class="line">		console_devices[<span class="built_in">stdout</span>][<span class="number">0</span>] = outputdev;</span><br><span class="line">		console_devices[<span class="built_in">stderr</span>][<span class="number">0</span>] = outputdev;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initializes input console */</span></span><br><span class="line">	<span class="keyword">if</span> (inputdev != <span class="literal">NULL</span>) {</span><br><span class="line">		console_setfile(<span class="built_in">stdin</span>, inputdev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_MUX</span></span><br><span class="line">		console_devices[<span class="built_in">stdin</span>][<span class="number">0</span>] = inputdev;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SYS_CONSOLE_INFO_QUIET</span></span><br><span class="line">	stdio_print_current_devices();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SYS_CONSOLE_INFO_QUIET */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setting environment variables */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">		setenv(stdio_names[i], stdio_devices[i]-&gt;name);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	gd-&gt;flags |= GD_FLG_DEVINIT;	<span class="comment">/* device initialization completed */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后调用<code>stdio_print_current_devices</code>打印，debug输出如下。并设置环境变量<code>stderr</code>、<code>stdin</code>、<code>stdout</code>为<code>serial</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In:    serial</span><br><span class="line">Out:   serial</span><br><span class="line">Err:   serial</span><br></pre></td></tr></tbody></table></figure>

<p>最后一个设置标志位<code>GD_FLG_DEVINIT</code>表示dev初始化完成。</p>
<h5 id="checkboard-1"><a href="#checkboard-1" class="headerlink" title="checkboard"></a>checkboard</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	 checkboard();	<span class="comment">/* fully init console as a device */</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// board/samsung/smart210/smart210.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkboard</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Board:\tSMART210\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="negative-squared-cross-mark-interrupt-init"><a href="#negative-squared-cross-mark-interrupt-init" class="headerlink" title=":negative_squared_cross_mark: interrupt_init"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> interrupt_init</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* set up exceptions */</span></span><br><span class="line">	interrupt_init();</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>没有定义宏<code>CONFIG_USE_IRQ</code>，走这个分支，这个代码也只是设置<code>IRQ_STACK_START_IN</code>中断栈起始地址为<code>gd-&gt;irq_sp + 8</code>？不应该是<code>-8</code>吗？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/interrupts.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">interrupt_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	IRQ_STACK_START_IN = gd-&gt;irq_sp + <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204151531408.png"></p>
<h5 id="enable-interrupts"><a href="#enable-interrupts" class="headerlink" title="enable_interrupts"></a>enable_interrupts</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* enable exceptions */</span></span><br><span class="line">	enable_interrupts();</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>空实现</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/interrupts.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_interrupts</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="eth-initialize"><a href="#eth-initialize" class="headerlink" title="eth_initialize"></a>eth_initialize</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Net:   "</span>);</span><br><span class="line">	eth_initialize(gd-&gt;bd);</span><br><span class="line">        ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>类似串口，这个地方又有个数据结构<code>struct eth_device</code>，定义了网络设备的基本操作。其中从面向对象的角度来说，在驱动层面只需要把对应的init、send、recv、halt、weite_hwaddr这几种方法实现，就可以正常收发数据了，至于数据收回来要怎么办，那是上层决定的，我们并不需要关心。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eth_device</span> {</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> enetaddr[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">int</span> iobase;</span><br><span class="line">	<span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>  (*init) (struct eth_device *, <span class="keyword">bd_t</span> *);</span><br><span class="line">	<span class="keyword">int</span>  (*send) (struct eth_device *, <span class="keyword">void</span> *packet, <span class="keyword">int</span> length);</span><br><span class="line">	<span class="keyword">int</span>  (*recv) (struct eth_device *);</span><br><span class="line">	<span class="keyword">void</span> (*halt) (struct eth_device *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MCAST_TFTP</span></span><br><span class="line">	<span class="keyword">int</span> (*mcast) (struct eth_device *, <span class="keyword">const</span> u8 *enetaddr, u8 <span class="built_in">set</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>  (*write_hwaddr) (struct eth_device *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eth_device</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">void</span> *priv;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>接着看<code>eth_initialize</code>函数，上来首先将<code>eth_devices</code>（网卡设备链表）、<code>eth_current</code>（当前网卡设备）置空，然后标记当前阶段为<code>BOOTSTAGE_ID_NET_ETH_START</code>，从环境变量查找<code>"bootfile"</code>，如果有，则拷贝至<code>BootFile</code>中。</p>
<p>接着往下走，实际上是一个初始化函数，只不过分了几种情况，如果<code>board-specific</code>存在的话，就调用它；如果没有，调用<code>CPU-specific</code>那个。</p>
<p>本文中走的是第一个分支，调用的<code>board_eth_init(bis)</code> 为<code>board/samsung/smart210/smart210.c</code>中的，我们分析一下。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/eth.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eth_initialize</span><span class="params">(<span class="keyword">bd_t</span> *bis)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> num_devices = <span class="number">0</span>;</span><br><span class="line">	eth_devices = <span class="literal">NULL</span>;</span><br><span class="line">	eth_current = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_NET_ETH_START);</span><br><span class="line"></span><br><span class="line">	eth_env_init(bis);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If board-specific initialization exists, call it.</span></span><br><span class="line"><span class="comment">	 * If not, call a CPU-specific one</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (board_eth_init != __def_eth_init) {</span><br><span class="line">		<span class="keyword">if</span> (board_eth_init(bis) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Board Net Initialization Failed\n"</span>);</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (cpu_eth_init != __def_eth_init) {</span><br><span class="line">		<span class="keyword">if</span> (cpu_eth_init(bis) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"CPU Net Initialization Failed\n"</span>);</span><br><span class="line">	} <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Net Initialization Skipped\n"</span>);</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先是调用的<code>board_eth_init</code>，接着调用<code>dm9000_initialize</code>，在这个函数里，就是将<code>dm9000_info.netdev</code>结构给初始化，并且从EEPROM中获取MAC地址，初始化函数，然后注册（在注册中，如果<code>eth_devices</code>网卡设备链表为空，则使<code>eth_devices</code>、<code>eth_devices</code>指向当前设备dev，并且如果当前网卡存在则设置环境变量中<code>ethact</code>的名称为当前网卡名，也就是说如果手动更改环境变量中<code>ethact</code>的value，即使保存后，下次重启后<code>ethact</code>为前面设置的<code>dm9000</code>。接着就是将网卡状态置位，将<code>next</code>指针指向自己，索引自加）。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// board/samsung/smart210/smart210.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">board_eth_init</span><span class="params">(<span class="keyword">bd_t</span> *bis)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">	rc = dm9000_initialize(bis);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// drivers/net/dm9000x.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dm9000_initialize</span><span class="params">(<span class="keyword">bd_t</span> *bis)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eth_device</span> *<span class="title">dev</span> =</span> &amp;(dm9000_info.netdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Load MAC address from EEPROM */</span></span><br><span class="line">	dm9000_get_enetaddr(dev);</span><br><span class="line"></span><br><span class="line">	dev-&gt;init = dm9000_init;</span><br><span class="line">	dev-&gt;halt = dm9000_halt;</span><br><span class="line">	dev-&gt;send = dm9000_send;</span><br><span class="line">	dev-&gt;recv = dm9000_rx;</span><br><span class="line">	<span class="built_in">sprintf</span>(dev-&gt;name, <span class="string">"dm9000"</span>);</span><br><span class="line"></span><br><span class="line">	eth_register(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>接着我们返回到<code>eth_initialize</code>，看一下剩下的部分。从<code>eth_devices</code>中取出，从环境变量中取出<code>ethprime</code>的value（应该为空，因为环境变量中没有此项），标记一下当前阶段。接着就是如果有多个网卡，则在显示的时候中间用<code>,</code>分开，比如：<code>Net:   dm9000,dm9001</code>。然后<code>eth_write_hwaddr</code>写网卡的MAC地址到dev中，接着更新下一个，但是我们刚刚设置dev-&gt;next指向自己，所以条件不满足，退出循环，返回网卡的个数。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/eth.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eth_initialize</span><span class="params">(<span class="keyword">bd_t</span> *bis)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">if</span> (!eth_devices) {</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"No ethernet found.\n"</span>);</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_NET_ETH_START);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		struct eth_device *dev = eth_devices;</span><br><span class="line">		<span class="keyword">char</span> *ethprime = getenv(<span class="string">"ethprime"</span>);</span><br><span class="line"></span><br><span class="line">		bootstage_mark(BOOTSTAGE_ID_NET_ETH_INIT);</span><br><span class="line">		<span class="keyword">do</span> {</span><br><span class="line">			<span class="keyword">if</span> (dev-&gt;index)</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">", "</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s"</span>, dev-&gt;name);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ethprime &amp;&amp; <span class="built_in">strcmp</span>(dev-&gt;name, ethprime) == <span class="number">0</span>) {</span><br><span class="line">				eth_current = dev;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">" [PRIME]"</span>);</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strchr</span>(dev-&gt;name, <span class="string">' '</span>))</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"\nWarning: eth device name has a space!"</span> <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (eth_write_hwaddr(dev, <span class="string">"eth"</span>, dev-&gt;index))</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"\nWarning: failed to set MAC address\n"</span>);</span><br><span class="line"></span><br><span class="line">			dev = dev-&gt;next;</span><br><span class="line">			num_devices++;</span><br><span class="line">		} <span class="keyword">while</span> (dev != eth_devices);</span><br><span class="line"></span><br><span class="line">		eth_current_changed();</span><br><span class="line">		putc(<span class="string">'\n'</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> num_devices;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="main-loop"><a href="#main-loop" class="headerlink" title="main_loop"></a>main_loop</h5><p>终于到最后一个函数了，</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/lib/board.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *id, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        ...</span><br><span class="line">	<span class="comment">/* main_loop() can return to retry autoboot, if so just run it again. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		main_loop();</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* NOTREACHED - no way out of command loop except booting */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>已定义宏 <code>CONFIG_SYS_HUSH_PARSER</code>、<code>CONFIG_BOOTDELAY</code>精简后代码如下，首先标记当前阶段<code>BOOTSTAGE_ID_MAIN_LOOP</code>，接着看一下这几个函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_loop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, <span class="string">"main_loop"</span>);</span><br><span class="line">	u_boot_hush_start();</span><br><span class="line">	process_boot_delay();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Main Loop for Monitor Command Processing</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	parse_file_outer();</span><br><span class="line">	<span class="comment">/* This point is never reached */</span></span><br><span class="line">	<span class="keyword">for</span> (;;);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="u-boot-hush-start"><a href="#u-boot-hush-start" class="headerlink" title="u_boot_hush_start"></a>u_boot_hush_start</h6><p> <code>u_boot_hush_start</code>在<code>common/hush.c</code>中，给<code>top_vars</code>分配空间，然后初始化</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/hush.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">u_boot_hush_start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (top_vars == <span class="literal">NULL</span>) {</span><br><span class="line">		top_vars = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct variables));</span><br><span class="line">		top_vars-&gt;name = <span class="string">"HUSH_VERSION"</span>;</span><br><span class="line">		top_vars-&gt;value = <span class="string">"0.01"</span>;</span><br><span class="line">		top_vars-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		top_vars-&gt;flg_export = <span class="number">0</span>;</span><br><span class="line">		top_vars-&gt;flg_read_only = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="process-boot-delay"><a href="#process-boot-delay" class="headerlink" title="process_boot_delay"></a>process_boot_delay</h6><p><code>process_boot_delay</code> 在<code>common/main.c</code>中，从环境变量中获取<code>bootdelay</code>对应的value，获取<code>bootcmd</code>对应的value，然后进入<code>abortboot(bootdelay)</code>函数，</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_boot_delay</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> *s;</span><br><span class="line">	<span class="keyword">int</span> bootdelay;</span><br><span class="line">	s = getenv (<span class="string">"bootdelay"</span>);</span><br><span class="line">	bootdelay = s ? (<span class="keyword">int</span>)simple_strtol(s, <span class="literal">NULL</span>, <span class="number">10</span>) : CONFIG_BOOTDELAY;</span><br><span class="line">	debug (<span class="string">"### main_loop entered: bootdelay=%d\n"</span>, bootdelay);</span><br><span class="line">	s = getenv (<span class="string">"bootcmd"</span>);</span><br><span class="line">	debug (<span class="string">"### main_loop: bootcmd=\"%s\"\n"</span>, s ? s : <span class="string">"&lt;UNDEFINED&gt;"</span>);</span><br><span class="line">	<span class="keyword">if</span> (bootdelay != <span class="number">-1</span> &amp;&amp; s &amp;&amp; !abortboot(bootdelay)) {</span><br><span class="line">		run_command_list(s, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>abortboot</code>处理延迟逻辑</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abortboot</span><span class="params">(<span class="keyword">int</span> bootdelay)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> abortboot_normal(bootdelay);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果获取到字符，就停止计时，否则一直在此空转，<code>bootdelay</code>秒后，函数返回。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abortboot_normal</span><span class="params">(<span class="keyword">int</span> bootdelay)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">abort</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bootdelay &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Hit any key to stop autoboot: %2d "</span>, bootdelay);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check if key already pressed</span></span><br><span class="line"><span class="comment">	 * Don't check if bootdelay &lt; 0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bootdelay &gt;= <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">if</span> (tstc()) {	<span class="comment">/* we got a key press	*/</span></span><br><span class="line">			(<span class="keyword">void</span>) getc();  <span class="comment">/* consume input	*/</span></span><br><span class="line">			<span class="built_in">puts</span> (<span class="string">"\b\b\b 0"</span>);</span><br><span class="line">			<span class="built_in">abort</span> = <span class="number">1</span>;	<span class="comment">/* don't auto boot	*/</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((bootdelay &gt; <span class="number">0</span>) &amp;&amp; (!<span class="built_in">abort</span>)) {</span><br><span class="line">		--bootdelay;</span><br><span class="line">		<span class="comment">/* delay 1000 ms */</span></span><br><span class="line">		ts = get_timer(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">do</span> {</span><br><span class="line">			<span class="keyword">if</span> (tstc()) {	<span class="comment">/* we got a key press	*/</span></span><br><span class="line">				<span class="built_in">abort</span>  = <span class="number">1</span>;	<span class="comment">/* don't auto boot	*/</span></span><br><span class="line">				bootdelay = <span class="number">0</span>;	<span class="comment">/* no more delay	*/</span></span><br><span class="line">				(<span class="keyword">void</span>) getc();  <span class="comment">/* consume input	*/</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			udelay(<span class="number">10000</span>);</span><br><span class="line">		} <span class="keyword">while</span> (!<span class="built_in">abort</span> &amp;&amp; get_timer(ts) &lt; <span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\b\b\b%2d "</span>, bootdelay);</span><br><span class="line">	}</span><br><span class="line">	putc(<span class="string">'\n'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">abort</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后运行 <code>run_command_list(s, -1, 0);</code>，此时s中数据为<code>bootcmd="nfs 20000000 10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs/uImage;nfs 21000000 10.0.0.97:/home/acoollib/workspace/git/smart210-SDK/rootfs/s5pv210-smart210.dtb;bootm 20000000 - 21000000"</code></p>
<h6 id="run-command-list"><a href="#run-command-list" class="headerlink" title="run_command_list"></a>run_command_list</h6><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_command_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd, <span class="keyword">int</span> len, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> need_buff = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> *buff = (<span class="keyword">char</span> *)cmd;	<span class="comment">/* cast away const */</span></span><br><span class="line">	<span class="keyword">int</span> rcode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">-1</span>) {</span><br><span class="line">		len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">		<span class="comment">/* hush will never change our string */</span></span><br><span class="line">		need_buff = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);<span class="comment">// 1&lt;&lt;1</span></span><br><span class="line">	<span class="keyword">return</span> rcode;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>run_command_list</code>只是对<code>hush shell</code>中的函数<code>parse_string_outer</code>进行了一层封装。<code>parse_string_outer</code>函数调用了<code>hush shell</code>的命令解释器<code>parse_stream_outer</code>函数来解释bootcmd的命令。</p>
<h6 id="parse-string-outer"><a href="#parse-string-outer" class="headerlink" title="parse_string_outer"></a>parse_string_outer</h6><p>我们看下<code>parse_stream_outer</code>这个执行过程实在太复杂了。从这开始整个执行流程是这样的，最后就跳转到调用的地方了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--&gt; parse_string_outer</span><br><span class="line">    |</span><br><span class="line">    --&gt; parse_stream_outer</span><br><span class="line">    	|</span><br><span class="line">    	--&gt; parse_stream</span><br><span class="line">    	--&gt; run_list</span><br><span class="line">    		|</span><br><span class="line">    		--&gt; run_list_real</span><br><span class="line">    			|</span><br><span class="line">    			--&gt; run_pipe_real</span><br><span class="line">    				|</span><br><span class="line">    				--&gt; cmd_process</span><br><span class="line">    					|</span><br><span class="line">    					--&gt; cmd_call</span><br></pre></td></tr></tbody></table></figure>

<p><del>这个过程需要理解一系列的代码以及各种神奇操作，让我们先省略这一段继续往后吧。</del></p>
<p>最后调用<code>parse_string_outer</code>，在源码中，我们定义了<code>__U_BOOT__</code>宏，所以<code>parse_string_outer</code>源码如下</p>
<p>首先进入代码后先判空，然后搜索<code>\n</code>，如果以<code>\n</code>结尾，<del>会走if分支，否则走else分支</del>，其区别就是是否需要分配空间，拷贝一下，添加<code>\n</code>到尾部。</p>
<p>然后转换一下格式，在<code>setup_string_in_str</code>中将其转为结构体<code>struct in_str</code>，然后进入<code>parse_stream_outer</code>，<del>此处hush解析器不在分析。</del>还是得分析。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/hush.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_string_outer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_str</span> <span class="title">input</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> rcode;</span><br><span class="line">	<span class="keyword">if</span> ( !s || !*s)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(p = <span class="built_in">strchr</span>(s, <span class="string">'\n'</span>)) || *++p) {</span><br><span class="line">		p = xmalloc(<span class="built_in">strlen</span>(s) + <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(p, s);</span><br><span class="line">		<span class="built_in">strcat</span>(p, <span class="string">"\n"</span>);</span><br><span class="line">		setup_string_in_str(&amp;input, p);</span><br><span class="line">		rcode = parse_stream_outer(&amp;input, flag);</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">return</span> rcode;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		setup_string_in_str(&amp;input, s);</span><br><span class="line">		<span class="keyword">return</span> parse_stream_outer(&amp;input, flag);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h6 id="parse-stream-outer"><a href="#parse-stream-outer" class="headerlink" title="parse_stream_outer"></a>parse_stream_outer</h6><p>先进入<code>parse_stream</code>函数对数据进行处理，识别到执行命令后，最后进入<code>run_list</code>函数，<code>parse_stream</code>和<code>run_list</code>中间的数据是怎么衔接的呢？借助<code>ctx</code>，一会看一下<code>ctx</code>（<code>p_context</code>）的结构。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/hush.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parse_stream_outer</span><span class="params">(struct in_str *inp, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">p_context</span> <span class="title">ctx</span>;</span></span><br><span class="line">	o_string temp=NULL_O_STRING;</span><br><span class="line">	<span class="keyword">int</span> rcode;</span><br><span class="line">	<span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span> {</span><br><span class="line">		ctx.type = flag;</span><br><span class="line">		initialize_context(&amp;ctx);</span><br><span class="line">		update_ifs_map();</span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; FLAG_PARSE_SEMICOLON) || (flag &amp; FLAG_REPARSING)) mapset((uchar *)<span class="string">";$&amp;|"</span>, <span class="number">0</span>);</span><br><span class="line">		inp-&gt;promptmode=<span class="number">1</span>;</span><br><span class="line">		rcode = parse_stream(&amp;temp, &amp;ctx, inp, <span class="string">'\n'</span>);</span><br><span class="line">		<span class="keyword">if</span> (rcode == <span class="number">1</span>) flag_repeat = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (rcode != <span class="number">1</span> &amp;&amp; ctx.old_flag != <span class="number">0</span>) {</span><br><span class="line">			syntax();</span><br><span class="line">			flag_repeat = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (rcode != <span class="number">1</span> &amp;&amp; ctx.old_flag == <span class="number">0</span>) {</span><br><span class="line">			done_word(&amp;temp, &amp;ctx);</span><br><span class="line">			done_pipe(&amp;ctx,PIPE_SEQ);</span><br><span class="line">			code = run_list(ctx.list_head);</span><br><span class="line">			<span class="keyword">if</span> (code == <span class="number">-2</span>) {	<span class="comment">/* exit */</span></span><br><span class="line">				b_free(&amp;temp);</span><br><span class="line">				code = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">/* XXX hackish way to not allow exit from main loop */</span></span><br><span class="line">				<span class="keyword">if</span> (inp-&gt;peek == file_peek) {</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"exit not allowed from main input shell.\n"</span>);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (code == <span class="number">-1</span>)</span><br><span class="line">			    flag_repeat = <span class="number">0</span>;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span> (ctx.old_flag != <span class="number">0</span>) {</span><br><span class="line">				<span class="built_in">free</span>(ctx.<span class="built_in">stack</span>);</span><br><span class="line">				b_reset(&amp;temp);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (inp-&gt;__promptme == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"&lt;INTERRUPT&gt;\n"</span>);</span><br><span class="line">			inp-&gt;__promptme = <span class="number">1</span>;</span><br><span class="line">			temp.nonnull = <span class="number">0</span>;</span><br><span class="line">			temp.quote = <span class="number">0</span>;</span><br><span class="line">			inp-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">			free_pipe_list(ctx.list_head,<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">		b_free(&amp;temp);</span><br><span class="line">	} <span class="keyword">while</span> (rcode != <span class="number">-1</span> &amp;&amp; !(flag &amp; FLAG_EXIT_FROM_LOOP));   <span class="comment">/* loop on syntax errors, return on EOF */</span></span><br><span class="line">	<span class="keyword">return</span> (code != <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h6 id="negative-squared-cross-mark-p-context"><a href="#negative-squared-cross-mark-p-context" class="headerlink" title=":negative_squared_cross_mark: p_context"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> p_context</h6><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This holds pointers to the various results of parsing */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p_context</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">child_prog</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">list_head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __U_BOOT__</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">redir_struct</span> *<span class="title">pending_redirect</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	reserved_style w;</span><br><span class="line">	<span class="keyword">int</span> old_flag;				<span class="comment">/* for figuring out valid reserved words */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">p_context</span> *<span class="title">stack</span>;</span></span><br><span class="line">	<span class="keyword">int</span> type;			<span class="comment">/* define type of parser : ";$" common or special symbol */</span></span><br><span class="line">	<span class="comment">/* How about quoting status? */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h6 id="run-list"><a href="#run-list" class="headerlink" title="run_list"></a>run_list</h6><p>由于定义了<code>__U_BOOT__</code>，所以此处会直接运行<code>rcode = run_list_real(pi);</code>，进入到<code>run_list_real</code>函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_list</span><span class="params">(struct pipe *pi)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> rcode=<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __U_BOOT__</span></span><br><span class="line">	<span class="keyword">if</span> (fake_mode==<span class="number">0</span>) {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		rcode = run_list_real(pi);</span><br><span class="line">		debug(<span class="string">"rcode:%d\n"</span>,rcode);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __U_BOOT__</span></span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* free_pipe_list has the side effect of clearing memory</span></span><br><span class="line"><span class="comment">	 * In the long run that function can be merged with run_list_real,</span></span><br><span class="line"><span class="comment">	 * but doing that now would hobble the debugging effort. */</span></span><br><span class="line">	free_pipe_list(pi,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> rcode;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h6 id="negative-squared-cross-mark-run-list-real"><a href="#negative-squared-cross-mark-run-list-real" class="headerlink" title=":negative_squared_cross_mark: run_list_real"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> run_list_real</h6><p><strong>TODO：待分析</strong></p>
<p>只会运行一次，且不会返回。</p>
<p>跳转到<code>rcode = run_pipe_real(pi);</code></p>
<h6 id="negative-squared-cross-mark-run-pipe-real"><a href="#negative-squared-cross-mark-run-pipe-real" class="headerlink" title=":negative_squared_cross_mark: run_pipe_real"></a><span class="github-emoji"><span>❎</span><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.githubassets.com/images/icons/emoji/unicode/274e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> run_pipe_real</h6><p>先看一下<code>struct pipe</code>是什么东西，在u-boot中有<code>__U_BOOT__</code>宏，去掉了相关无用的代码。</p>
<p>此处看一下busybox中的<a target="_blank" rel="noopener" href="https://git.busybox.net/busybox/tree/shell/hush_doc.txt">hush_doc.txt</a>中的示例就明白了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> {</span></span><br><span class="line">	<span class="keyword">int</span> num_progs;				<span class="comment">/* 在当前任务流中的命令总数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">child_prog</span> *<span class="title">progs</span>;</span>		<span class="comment">/* 在管道中的命令数组 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">next</span>;</span>			     <span class="comment">/* 下一个命令的指针 */</span></span><br><span class="line">	pipe_style followup;		    <span class="comment">/* 表示这一截管道的类型 PIPE_BG, PIPE_SEQ, PIPE_OR, PIPE_AND；比如a &amp;&amp; b，则此处应为PIPE_AND */</span></span><br><span class="line">	reserved_style r_mode;		  <span class="comment">/* 表示控制流 比如if,for, while, until这种 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>解析管道中的命令，处理条件语句，比如IF、THEN、ELSE等。</p>
<h6 id="cmd-process"><a href="#cmd-process" class="headerlink" title="cmd_process"></a>cmd_process</h6><p>此处函数在重启时会执行三次，因为在bootcmd 启动命令中有三段。</p>
<p><code>nfs 20000000 10.0.0.97:/home/glj0/worksapce/os/smart210/rootfs/uImage;</code></p>
<p><code>nfs 21000000 10.0.0.97:/home/glj0/worksapce/os/smart210/rootfs/s5pv210-smart210.dtb;</code></p>
<p><code>bootm 20000000 - 21000000</code></p>
<p>这个函数会在之前定义的boot_list中找命令对应的函数，比如nfs、bootm等，找到后将其填充到 <code>cmd_tbl_t *cmdtp</code>中，然后跳入<code>cmd_call</code>中</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> <span class="keyword">command_ret_t</span> <span class="title">cmd_process</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">int</span> *repeatable, ulong *ticks)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">command_ret_t</span> <span class="title">rc</span> =</span> CMD_RET_SUCCESS;</span><br><span class="line">	<span class="keyword">cmd_tbl_t</span> *cmdtp;</span><br><span class="line">	debug(<span class="string">"flag:%d argc:%d\r\n"</span>,flag,argc);</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;argc;i++){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"argv[%d]:%s\r\n"</span>,i,argv[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* Look up command in command table */</span></span><br><span class="line">	cmdtp = find_cmd(argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> (cmdtp == <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Unknown command '%s' - try 'help'\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* found - check max args */</span></span><br><span class="line">	<span class="keyword">if</span> (argc &gt; cmdtp-&gt;maxargs)</span><br><span class="line">		rc = CMD_RET_USAGE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CMD_BOOTD)</span></span><br><span class="line">	<span class="comment">/* avoid "bootd" recursion */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cmdtp-&gt;cmd == do_bootd) {</span><br><span class="line">		<span class="keyword">if</span> (flag &amp; CMD_FLAG_BOOTD) {</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"'bootd' recursion detected\n"</span>);</span><br><span class="line">			rc = CMD_RET_FAILURE;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			flag |= CMD_FLAG_BOOTD;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If OK so far, then do the command */</span></span><br><span class="line">	<span class="keyword">if</span> (!rc) {</span><br><span class="line">		<span class="keyword">if</span> (ticks)</span><br><span class="line">			*ticks = get_timer(<span class="number">0</span>);</span><br><span class="line">		debug(<span class="string">"cmd_call cmdtp-&gt;name:%s\r\n"</span>,cmdtp-&gt;name);</span><br><span class="line">		rc = cmd_call(cmdtp, flag, argc, argv);</span><br><span class="line">		<span class="keyword">if</span> (ticks)</span><br><span class="line">			*ticks = get_timer(*ticks);</span><br><span class="line">		*repeatable &amp;= cmdtp-&gt;repeatable;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (rc == CMD_RET_USAGE)</span><br><span class="line">		rc = cmd_usage(cmdtp);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h6 id="cmd-call"><a href="#cmd-call" class="headerlink" title="cmd_call"></a>cmd_call</h6><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_call</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line">	debug(<span class="string">"cmdtp:%p flag:%d argc:%d\r\n"</span>,cmdtp,flag,argc);</span><br><span class="line">	debug(<span class="string">"cmdtp-&gt;name:%s maxargs:%d cmd:%p usage:%s \r\n"</span>,cmdtp-&gt;name,cmdtp-&gt;maxargs,cmdtp-&gt;cmd,cmdtp-&gt;usage);</span><br><span class="line">	result = (cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		debug(<span class="string">"Command failed, result=%d"</span>, result);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先看下是怎么调用的，最终在cmd_call中完成调用，最关键的一句<code>result = (cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);</code>此时并不能发现什么猫腻，无法就是<code>cmdtp-&gt;cmd</code>是一个函数地址，后面这一堆是参数，那么，这个地址指向的是什么呢？肯定是一个<code>函数</code>。由于我们DEBUG模式下加了许多打印，所以可以轻松得到这个地址值为<code>3ff8b590</code>，前面我们有个重定位还有印象吗？没有印象去查看一下<a href="#relocate_code">relocate_code</a>，<code>代码的地址：编译后函数的地址+重定位偏移量</code> 接着查日志中，发现relocate偏移量为<code>1ff7b000</code>，那么这个函数偏移前地址也就是<code>3ff8b590-1ff7b000=20010590</code>，看一下u-boot.map文件下该地址对应的是什么，对应的是<code>do_nfs</code>。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204211947823.png"></p>
<p>查一下该符号<code>grep -nr do_nfs</code>，发现存在该函数。那么我们就可以理解了，在<code>cmd_call</code>之前通过一系列的骚操作，得到<code>某指令</code>对应的<code>do_某指令</code>函数地址，然后跳转到这个函数地址就可以进行后面的操作了。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204211950205.png"></p>
<p>在do_nfs附近有一个<code>U_BOOT_CMD ...</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_nfs</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> netboot_common(NFS, cmdtp, argc, argv);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">	nfs,	<span class="number">3</span>,	<span class="number">1</span>,	do_nfs,</span><br><span class="line">	<span class="string">"boot image via network using NFS protocol"</span>,</span><br><span class="line">	<span class="string">"[loadAddress] [[hostIPaddr:]bootfilename]"</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>该宏在<code>include/command.h</code>定义</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/command.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    　各个参数的意义如下：</span></span><br><span class="line"><span class="comment">       _name：命令名，非字符串，但在U_BOOT_CMD中用“#”符号转化为字符串</span></span><br><span class="line"><span class="comment">       _maxargs：命令的最大参数个数</span></span><br><span class="line"><span class="comment">       _rep：是否自动重复（按Enter键是否会重复执行）</span></span><br><span class="line"><span class="comment">       _cmd：该命令对应的响应函数指针</span></span><br><span class="line"><span class="comment">       _usage：简短的使用说明（字符串）</span></span><br><span class="line"><span class="comment">       _help：较详细的使用说明（字符串）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)	U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \</span></span><br><span class="line"><span class="meta">	ll_entry_declare(cmd_tbl_t, _name, cmd) =			\</span></span><br><span class="line"><span class="meta">		U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,_usage, _help, _comp);</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,_usage, _help, _comp)			\</span></span><br><span class="line"><span class="meta">		{ #_name, _maxargs, _rep, _cmd, _usage,	_CMD_HELP(_help) _CMD_COMPLETE(_comp) }</span></span><br><span class="line">--------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 手动替换 U_BOOT_CMD_COMPLETE 以及 U_BOOT_CMD_MKENT_COMPLETE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)	\</span></span><br><span class="line"><span class="meta">	ll_entry_declare(cmd_tbl_t, _name, cmd) = { #_name, _maxargs, _rep, _cmd, _usage,_help ,NULL }</span></span><br><span class="line">--------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// include/linker_lists.h</span></span><br><span class="line"><span class="comment">// ll_entry_declare 在 include/linker_lists.h 定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll_entry_declare(_type, _name, _list)				\</span></span><br><span class="line"><span class="meta">	_type _u_boot_list_2_##_list##_2_##_name __aligned(4) __attribute__((unused,section(<span class="meta-string">".u_boot_list_2_"</span>#_list<span class="meta-string">"_2_"</span>#_name)))</span></span><br><span class="line">--------------------------------------------------------------------------------------------------------------------    </span><br><span class="line"><span class="comment">// 示例 -- 手动解释这段宏</span></span><br><span class="line"> U_BOOT_CMD(</span><br><span class="line">	nfs,	<span class="number">3</span>,	<span class="number">1</span>,	do_nfs,</span><br><span class="line">	<span class="string">"boot image via network using NFS protocol"</span>,</span><br><span class="line">	<span class="string">"[loadAddress] [[hostIPaddr:]bootfilename]"</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 替换后也就是</span></span><br><span class="line"><span class="keyword">cmd_tbl_t</span>  _u_boot_list_2_cmd_2_nfs __aligned(<span class="number">4</span>) __attribute__((unused,section(<span class="string">".u_boot_list_2_cmd_2_nfs"</span>))) = \</span><br><span class="line">	{nfs,<span class="number">3</span>,<span class="number">1</span>,do_nfs,<span class="string">"boot image via network using NFS protocol"</span>,<span class="string">"[loadAddress] [[hostIPaddr:]bootfilename]"</span>}</span><br></pre></td></tr></tbody></table></figure>

<p><code>cmdtp-&gt;cmd</code>我们知道是什么了，<code>cmdtp</code>呢？看下地址：<code>3ffb8f64</code>（通过日志查看）在减去重定位偏移<code>1ff7b000</code>，也就是<code>2003DF64</code>，通过在<code>u-boot.map</code>中查看对应地址<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204220931044.png"></p>
<p>发现其也就是我们上面使用<code>U_BOOT_CMD</code>定义的这一串，而这一串的格式也恰恰与<code>struct cmd_tbl_s</code>一致。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204220934517.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span> {</span></span><br><span class="line">	<span class="keyword">char</span>	*name;		<span class="comment">/* 指令名称 */</span></span><br><span class="line">	<span class="keyword">int</span>		maxargs;	 <span class="comment">/* 命令的最大参数个数*/</span></span><br><span class="line">	<span class="keyword">int</span>		repeatable;	    <span class="comment">/* 是否自动重复		*/</span></span><br><span class="line">					    <span class="comment">/* Implementation function	*/</span></span><br><span class="line">	<span class="keyword">int</span>		(*cmd)(struct cmd_tbl_s *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">char</span> * <span class="keyword">const</span> []);</span><br><span class="line">	<span class="keyword">char</span>		*usage;		<span class="comment">/* 简短的使用说明 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_SYS_LONGHELP</span></span><br><span class="line">	<span class="keyword">char</span>		*help;		<span class="comment">/* 较详细的使用说明 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AUTO_COMPLETE</span></span><br><span class="line">	<span class="comment">/* do auto completion on the arguments */</span></span><br><span class="line">	<span class="keyword">int</span>		(*complete)(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">char</span> last_char, <span class="keyword">int</span> maxv, <span class="keyword">char</span> *cmdv[]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h6 id="do-nfs"><a href="#do-nfs" class="headerlink" title="do_nfs"></a>do_nfs</h6><p>前面我们知道了在<code>cmd_call</code>中会调用<code>do_nfs</code>函数，接下来就分析一下该函数。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">do_nfs</span><br><span class="line">|</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> netboot_common</span></span><br><span class="line">	|</span><br><span class="line"><span class="meta">	--&gt;</span><span class="bash"> NetLoop</span></span><br><span class="line">		|</span><br><span class="line"><span class="meta">		--&gt;</span><span class="bash"> eth_halt</span>	</span><br><span class="line">			|</span><br><span class="line"><span class="meta">			--&gt;</span><span class="bash">  dm9000_halt</span></span><br><span class="line">			|</span><br><span class="line">	     	   eth_set_current</span><br><span class="line">             		     eth_init </span><br><span class="line">			|</span><br><span class="line"><span class="meta">			--&gt;</span><span class="bash"> dm9000_init</span></span><br><span class="line">             				|</span><br><span class="line">             				 --&gt; NfsStart</span><br><span class="line">             			      		|</span><br><span class="line">             			      		--&gt;  Nfs_Send</span><br><span class="line">             			      	--&gt; eth_rx</span><br><span class="line">					|</span><br><span class="line">					--&gt; dm9000_rx</span><br></pre></td></tr></tbody></table></figure>

<p>根据日志，我们接着分析。先分析这一段<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204221402853.png"></p>
<p>通过上面调用关系，直接看<code>netboot_common</code>，在这个函数中，上面首先是各种初始化，根据参数的不同设定对应的<code>load_addr</code>，这部分我们先不看，在函数的中间有一个<code>NetLoop</code>函数，其中参数为协议类型，此处也就是nfs</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/cmd_net.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netboot_common</span><span class="params">(<span class="keyword">enum</span> <span class="keyword">proto_t</span> proto, <span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> ((size = NetLoop(proto)) &lt; <span class="number">0</span>) {</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_NET_NETLOOP_OK);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于<code>eth_is_on_demand_init</code>返回值为1，所以会进入if分支下，然后 <code>eth_halt</code>也就是调用 <code>eth_current-&gt;halt(eth_current)</code></p>
<p>接着<code>eth_set_current</code>：在环境变量中找到ethact的名字，在<code>eth_current</code>链表中查找该设备，找到就退出</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/net.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NetLoop</span><span class="params">(<span class="keyword">enum</span> <span class="keyword">proto_t</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">bd_t</span> *bd = gd-&gt;bd;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	NetRestarted = <span class="number">0</span>;</span><br><span class="line">	NetDevExists = <span class="number">0</span>;</span><br><span class="line">	NetTryCount = <span class="number">1</span>;</span><br><span class="line">	debug_cond(DEBUG_INT_STATE, <span class="string">"--- NetLoop Entry\n"</span>);</span><br><span class="line"></span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_ETH_START, <span class="string">"eth_start"</span>);</span><br><span class="line">	net_init();</span><br><span class="line">	<span class="keyword">if</span> (eth_is_on_demand_init() || protocol != NETCONS) {</span><br><span class="line">		eth_halt();</span><br><span class="line">		eth_set_current();</span><br><span class="line">		<span class="keyword">if</span> (eth_init(bd) &lt; <span class="number">0</span>) {</span><br><span class="line">			eth_halt();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">else</span></span><br><span class="line">		eth_init_state_only(bd);</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>eth_init</code>中，先是打印<code>Trying ...</code>，然后调用<code>eth_current-&gt;init(eth_current, bis)</code> ，这个init函数调到什么地方去了呢？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eth_init</span><span class="params">(<span class="keyword">bd_t</span> *bis)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   	 ...</span><br><span class="line">	<span class="keyword">do</span> {</span><br><span class="line">		debug(<span class="string">"Trying %s\n"</span>, eth_current-&gt;name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (eth_current-&gt;init(eth_current, bis) &gt;= <span class="number">0</span>) {</span><br><span class="line">			eth_current-&gt;state = ETH_STATE_ACTIVE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">		debug(<span class="string">"FAIL\n"</span>);</span><br><span class="line">		eth_try_another(<span class="number">0</span>);</span><br><span class="line">	} <span class="keyword">while</span> (old_current != eth_current);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不知各位看官还有印象没，我们在前面 board_init_r 中的<a href="#eth_initialize">eth_initialize</a>初始化的时候，会调用到</p>
<p><code>int dm9000_initialize(bd_t *bis)</code>，在此函数中，绑定了针对dm9000芯片的操作，然后注册到了<code>eth_devices</code>，所以我们刚刚调用<code>eth_current-&gt;init(eth_current, bis)</code>就是直接执行 <code>dm9000_init(struct eth_device *dev, bd_t *bd)</code>，所以日志中也就会这些输出了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dm9000_init</span><span class="params">(struct eth_device *dev, <span class="keyword">bd_t</span> *bd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i, oft, lnk;</span><br><span class="line">	u8 io_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">board_info</span> *<span class="title">db</span> =</span> &amp;dm9000_info;</span><br><span class="line"></span><br><span class="line">	DM9000_DBG(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RESET device */</span></span><br><span class="line">	dm9000_reset();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dm9000_probe() &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Auto-detect 8/16/32 bit mode, ISR Bit 6+7 indicate bus width */</span></span><br><span class="line">	io_mode = DM9000_ior(DM9000_ISR) &gt;&gt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (io_mode) {</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x0</span>:  <span class="comment">/* 16-bit mode */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"DM9000: running in 16 bit mode\n"</span>);</span><br><span class="line">		db-&gt;outblk    = dm9000_outblk_16bit;</span><br><span class="line">		db-&gt;inblk     = dm9000_inblk_16bit;</span><br><span class="line">		db-&gt;rx_status = dm9000_rx_status_16bit;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x01</span>:  <span class="comment">/* 32-bit mode */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"DM9000: running in 32 bit mode\n"</span>);</span><br><span class="line">		db-&gt;outblk    = dm9000_outblk_32bit;</span><br><span class="line">		db-&gt;inblk     = dm9000_inblk_32bit;</span><br><span class="line">		db-&gt;rx_status = dm9000_rx_status_32bit;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x02</span>: <span class="comment">/* 8 bit mode */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"DM9000: running in 8 bit mode\n"</span>);</span><br><span class="line">		db-&gt;outblk    = dm9000_outblk_8bit;</span><br><span class="line">		db-&gt;inblk     = dm9000_inblk_8bit;</span><br><span class="line">		db-&gt;rx_status = dm9000_rx_status_8bit;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* Assume 8 bit mode, will probably not work anyway */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"DM9000: Undefined IO-mode:0x%x\n"</span>, io_mode);</span><br><span class="line">		db-&gt;outblk    = dm9000_outblk_8bit;</span><br><span class="line">		db-&gt;inblk     = dm9000_inblk_8bit;</span><br><span class="line">		db-&gt;rx_status = dm9000_rx_status_8bit;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Program operating register, only internal phy supported */</span></span><br><span class="line">	DM9000_iow(DM9000_NCR, <span class="number">0x0</span>);</span><br><span class="line">	<span class="comment">/* TX Polling clear */</span></span><br><span class="line">	DM9000_iow(DM9000_TCR, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* Less 3Kb, 200us */</span></span><br><span class="line">	DM9000_iow(DM9000_BPTR, BPTR_BPHW(<span class="number">3</span>) | BPTR_JPT_600US);</span><br><span class="line">	<span class="comment">/* Flow Control : High/Low Water */</span></span><br><span class="line">	DM9000_iow(DM9000_FCTR, FCTR_HWOT(<span class="number">3</span>) | FCTR_LWOT(<span class="number">8</span>));</span><br><span class="line">	<span class="comment">/* SH <span class="doctag">FIXME:</span> This looks strange! Flow Control */</span></span><br><span class="line">	DM9000_iow(DM9000_FCR, <span class="number">0x0</span>);</span><br><span class="line">	<span class="comment">/* Special Mode */</span></span><br><span class="line">	DM9000_iow(DM9000_SMCR, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* clear TX status */</span></span><br><span class="line">	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);</span><br><span class="line">	<span class="comment">/* Clear interrupt status */</span></span><br><span class="line">	DM9000_iow(DM9000_ISR, ISR_ROOS | ISR_ROS | ISR_PTS | ISR_PRS);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"MAC: %pM\n"</span>, dev-&gt;enetaddr);</span><br><span class="line">	<span class="keyword">if</span> (!is_valid_ether_addr(dev-&gt;enetaddr)) {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RANDOM_MACADDR</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Bad MAC address (uninitialized EEPROM?), randomizing\n"</span>);</span><br><span class="line">		eth_random_enetaddr(dev-&gt;enetaddr);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"MAC: %pM\n"</span>, dev-&gt;enetaddr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"WARNING: Bad MAC address (uninitialized EEPROM?)\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill device MAC address registers */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, oft = DM9000_PAR; i &lt; <span class="number">6</span>; i++, oft++)</span><br><span class="line">		DM9000_iow(oft, dev-&gt;enetaddr[i]);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, oft = <span class="number">0x16</span>; i &lt; <span class="number">8</span>; i++, oft++)</span><br><span class="line">		DM9000_iow(oft, <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read back mac, just to be sure */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, oft = <span class="number">0x10</span>; i &lt; <span class="number">6</span>; i++, oft++)</span><br><span class="line">		DM9000_DBG(<span class="string">"%02x:"</span>, DM9000_ior(oft));</span><br><span class="line">	DM9000_DBG(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Activate DM9000 */</span></span><br><span class="line">	<span class="comment">/* RX enable */</span></span><br><span class="line">	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);</span><br><span class="line">	<span class="comment">/* Enable TX/RX interrupt mask */</span></span><br><span class="line">	DM9000_iow(DM9000_IMR, IMR_PAR);</span><br><span class="line"></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!(dm9000_phy_read(<span class="number">1</span>) &amp; <span class="number">0x20</span>)) {	<span class="comment">/* autonegation complete bit */</span></span><br><span class="line">		udelay(<span class="number">1000</span>);</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">10000</span>) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"could not establish link\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* see what we've got */</span></span><br><span class="line">	lnk = dm9000_phy_read(<span class="number">17</span>) &gt;&gt; <span class="number">12</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"operating at "</span>);</span><br><span class="line">	<span class="keyword">switch</span> (lnk) {</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"10M half duplex "</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"10M full duplex "</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"100M half duplex "</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"100M full duplex "</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"unknown: %d "</span>, lnk);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"mode\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着看下<code>NfsStart</code>，首先是获取一些关键参数并打印。设置nfs的一些关键参数，比如要传输的地址，超时等等，设置回调函数<code>NfsHandler</code>，然后<code>NfsSend</code>发送请求。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/nfs.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NfsStart</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	debug(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">	nfs_download_state = NETLOOP_FAIL;</span><br><span class="line"></span><br><span class="line">	NfsServerIP = NetServerIP;</span><br><span class="line">	nfs_path = (<span class="keyword">char</span> *)nfs_path_buff;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nfs_path == <span class="literal">NULL</span>) {</span><br><span class="line">		net_set_state(NETLOOP_FAIL);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"*** ERROR: Fail allocate memory\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BootFile[<span class="number">0</span>] == <span class="string">'\0'</span>) {</span><br><span class="line">		<span class="built_in">sprintf</span>(default_filename, <span class="string">"/nfsroot/%02X%02X%02X%02X.img"</span>,NetOurIP &amp; <span class="number">0xFF</span>,(NetOurIP &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xFF</span>,(NetOurIP &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>,(NetOurIP &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(nfs_path, default_filename);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"*** Warning: no boot file name; using '%s'\n"</span>,nfs_path);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">char</span> *p = BootFile;</span><br><span class="line">		p = <span class="built_in">strchr</span>(p, <span class="string">':'</span>);</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>) {</span><br><span class="line">			NfsServerIP = string_to_ip(BootFile);</span><br><span class="line">			++p;</span><br><span class="line">			<span class="built_in">strcpy</span>(nfs_path, p);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">strcpy</span>(nfs_path, BootFile);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	nfs_filename = basename(nfs_path);</span><br><span class="line">	nfs_path     = dirname(nfs_path);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Using %s device\n"</span>, eth_get_name());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"File transfer via NFS from server %pI4"</span> <span class="string">"; our IP address is %pI4"</span>, &amp;NfsServerIP, &amp;NetOurIP);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if we need to send across this subnet */</span></span><br><span class="line">	<span class="keyword">if</span> (NetOurGatewayIP &amp;&amp; NetOurSubnetMask) {</span><br><span class="line">		IPaddr_t OurNet	    = NetOurIP	  &amp; NetOurSubnetMask;</span><br><span class="line">		IPaddr_t ServerNet  = NetServerIP &amp; NetOurSubnetMask;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (OurNet != ServerNet)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"; sending through gateway %pI4"</span>,&amp;NetOurGatewayIP);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nFilename '%s/%s'."</span>, nfs_path, nfs_filename);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NetBootFileSize) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" Size is 0x%x Bytes = "</span>, NetBootFileSize&lt;&lt;<span class="number">9</span>);</span><br><span class="line">		print_size(NetBootFileSize&lt;&lt;<span class="number">9</span>, <span class="string">""</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nLoad address: 0x%lx\n"</span> <span class="string">"Loading: *\b"</span>, load_addr);</span><br><span class="line"></span><br><span class="line">	NetSetTimeout(nfs_timeout, NfsTimeout);</span><br><span class="line">	net_set_udp_handler(NfsHandler);</span><br><span class="line"></span><br><span class="line">	NfsTimeoutCount = <span class="number">0</span>;</span><br><span class="line">	NfsState = STATE_PRCLOOKUP_PROG_MOUNT_REQ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*NfsOurPort = 4096 + (get_ticks() % 3072);*/</span></span><br><span class="line">	<span class="comment">/*FIX ME !!!*/</span></span><br><span class="line">	NfsOurPort = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zero out server ether in case the server ip has changed */</span></span><br><span class="line">	<span class="built_in">memset</span>(NetServerEther, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">	NfsSend();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着就是<code>eth_rx</code>，由于我们前面已经初始化过<code>dev-&gt;recv = dm9000_rx;</code>所以这个函数中返回也就是调用我们前面初始化的网卡，DM9000的<code>dm9000_rx</code>函数。</p>
<p>也就是下面那一块，在这个里面完成数据的接收。如要查看接收的数据，可以打开 <code>CONFIG_DM9000_DEBUG</code>开关。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/eth.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eth_rx</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (!eth_current)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> eth_current-&gt;recv(eth_current);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/net/dm9000x.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dm9000_rx</span><span class="params">(struct eth_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[<span class="number">0</span>];</span><br><span class="line">	u16 RxStatus, RxLen = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">board_info</span> *<span class="title">db</span> =</span> &amp;dm9000_info;</span><br><span class="line">	<span class="comment">/* Check packet ready or not, we must check</span></span><br><span class="line"><span class="comment">	   the ISR status first for DM9000A */</span></span><br><span class="line">	<span class="keyword">if</span> (!(DM9000_ior(DM9000_ISR) &amp; <span class="number">0x01</span>)) <span class="comment">/* Rx-ISR bit must be set. */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	DM9000_iow(DM9000_ISR, <span class="number">0x01</span>); <span class="comment">/* clear PR status latched in bit 0 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There is _at least_ 1 package in the fifo, read them all */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		DM9000_ior(DM9000_MRCMDX);	<span class="comment">/* Dummy read */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Get most updated data,</span></span><br><span class="line"><span class="comment">		   only look at bits 0:1, See application notes DM9000 */</span></span><br><span class="line">		rxbyte = DM9000_inb(DM9000_DATA) &amp; <span class="number">0x03</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Status check: this byte must be 0 or 1 */</span></span><br><span class="line">		<span class="keyword">if</span> (rxbyte &gt; DM9000_PKT_RDY) {</span><br><span class="line">			DM9000_iow(DM9000_RCR, <span class="number">0x00</span>);	<span class="comment">/* Stop Device */</span></span><br><span class="line">			DM9000_iow(DM9000_ISR, <span class="number">0x80</span>);	<span class="comment">/* Stop INT request */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"DM9000 error: status check fail: 0x%x\n"</span>,rxbyte);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rxbyte != DM9000_PKT_RDY)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No packet received, ignore */</span></span><br><span class="line"></span><br><span class="line">		DM9000_DBG(<span class="string">"receiving packet\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* A packet ready now  &amp; Get status/length */</span></span><br><span class="line">		(db-&gt;rx_status)(&amp;RxStatus, &amp;RxLen);</span><br><span class="line"></span><br><span class="line">		DM9000_DBG(<span class="string">"rx status: 0x%04x rx len: %d\n"</span>, RxStatus, RxLen);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Move data from DM9000 */</span></span><br><span class="line">		<span class="comment">/* Read received packet from RX SRAM */</span></span><br><span class="line">		(db-&gt;inblk)(rdptr, RxLen);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((RxStatus &amp; <span class="number">0xbf00</span>) || (RxLen &lt; <span class="number">0x40</span>)</span><br><span class="line">			|| (RxLen &gt; DM9000_PKT_MAX)) {</span><br><span class="line">			<span class="keyword">if</span> (RxStatus &amp; <span class="number">0x100</span>) {</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"rx fifo error\n"</span>);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (RxStatus &amp; <span class="number">0x200</span>) {</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"rx crc error\n"</span>);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (RxStatus &amp; <span class="number">0x8000</span>) {</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"rx length error\n"</span>);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (RxLen &gt; DM9000_PKT_MAX) {</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"rx length too big\n"</span>);</span><br><span class="line">				dm9000_reset();</span><br><span class="line">			}</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			DM9000_DMP_PACKET(__func__ , rdptr, RxLen);</span><br><span class="line"></span><br><span class="line">			DM9000_DBG(<span class="string">"passing packet to upper layer\n"</span>);</span><br><span class="line">			NetReceive(NetRxPackets[<span class="number">0</span>], RxLen);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>我们接着看下，接收完成呢？又该去干什么了？别忘了，接收只是其中一步，我们在<code>bootcmd</code>中一共有三部分，传送内核到内存20000000处，传送设备树到21000000处，使用bootm启动。现在就当已经接收完成，接着看看后面做了什么。清除接收函数，如果接收的数据大小大于0，设置<code>filesize</code>为接收的数字大小，<code>fileaddr</code>为接收的地址。然后跳转到done处，done处又是清除udp、icmp句柄，然后函数就退出了。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/net.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NetLoop</span><span class="params">(<span class="keyword">enum</span> <span class="keyword">proto_t</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">			...			</span><br><span class="line">			net_cleanup_loop();</span><br><span class="line">			<span class="keyword">if</span> (NetBootFileXferSize &gt; <span class="number">0</span>) {</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Bytes transferred = %ld (%lx hex)\n"</span>,</span><br><span class="line">					NetBootFileXferSize,</span><br><span class="line">					NetBootFileXferSize);</span><br><span class="line">				setenv_hex(<span class="string">"filesize"</span>, NetBootFileXferSize);</span><br><span class="line">				setenv_hex(<span class="string">"fileaddr"</span>, load_addr);</span><br><span class="line">			}</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">done:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_USB_KEYBOARD</span></span><br><span class="line">	net_busy_flag = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMD_TFTPPUT</span></span><br><span class="line">	<span class="comment">/* Clear out the handlers */</span></span><br><span class="line">	net_set_udp_handler(<span class="literal">NULL</span>);</span><br><span class="line">	net_set_icmp_handler(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>返回到<code>netboot_common</code>中去继续执行，设置参数，刷新缓存，查看是否要自动开始，也就是环境变量中的<code>autostart</code>为<code>yes</code>时，然后跳转到<code>do_bootm</code>中，此处就不再分析了。</p>
<p>下面接着分析do_bootm。</p>
<h6 id="do-bootm"><a href="#do-bootm" class="headerlink" title="do_bootm"></a>do_bootm</h6><p>首先了解一下uImage 和 zImage的区别。</p>
<blockquote>
<p>编译kernel之后，会生成Image或者压缩过的zImage。但是这两种镜像的格式并没有办法提供给uboot的足够的信息来进行load、jump或者验证操作等等。因此，uboot提供了mkimage工具，来将kernel制作为uboot可以识别的格式，将生成的文件称之为uImage。<br>uboot支持两种类型的uImage，如下</p>
<ul>
<li><p>Legacy-uImage<br>  在kernel镜像的基础上，加上64Byte的信息提供给uboot使用。</p>
</li>
<li><p>FIT-uImage<br>  以类似FDT的方式，将kernel、fdt、ramdisk等等镜像打包到一个image file中，并且加上一些需要的信息（属性）。uboot只要获得了这个image file，就可以得到kernel、fdt、ramdisk等等镜像的具体信息和内容。</p>
</li>
</ul>
<p>Legacy-uImage实现较为简单，并且长度较小。但是实际上使用较为麻烦，需要在启动kernel的命令中额外添加fdt、ramdisk的加载信息。<br>而FIT-uImage实现较为复杂，但是使用起来较为简单，兼容性较好,（可以兼容多种配置）。但是需要的额外信息也较长。</p>
<p>uImage 相较于 zImage 其在头部添加了64bytes <code>image_header</code>用来表示Legacy-uImage的头部</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">image_header</span> {</span></span><br><span class="line">    __be32      ih_magic;   <span class="comment">/* Image Header Magic Number    */</span>   <span class="comment">// 幻数头，用来校验是否是一个Legacy-uImage</span></span><br><span class="line">    __be32      ih_hcrc;    <span class="comment">/* Image Header CRC Checksum    */</span> <span class="comment">// 头部的CRC校验值</span></span><br><span class="line">    __be32      ih_time;    <span class="comment">/* Image Creation Timestamp */</span> <span class="comment">// 镜像创建的时间戳</span></span><br><span class="line">    __be32      ih_size;    <span class="comment">/* Image Data Size      */</span> <span class="comment">// 镜像数据长度</span></span><br><span class="line">    __be32      ih_load;    <span class="comment">/* Data  Load  Address      */</span> <span class="comment">// 加载地址</span></span><br><span class="line">    __be32      ih_ep;      <span class="comment">/* Entry Point Address      */</span> <span class="comment">// 入口地址</span></span><br><span class="line">    __be32      ih_dcrc;    <span class="comment">/* Image Data CRC Checksum  */</span> <span class="comment">// 镜像的CRC校验</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     ih_os;      <span class="comment">/* Operating System     */</span> <span class="comment">// 操作系统类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     ih_arch;    <span class="comment">/* CPU architecture     */</span> <span class="comment">// 体系 </span></span><br><span class="line">    <span class="keyword">uint8_t</span>     ih_type;    <span class="comment">/* Image Type           */</span> <span class="comment">// 镜像类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     ih_comp;    <span class="comment">/* Compression Type     */</span> <span class="comment">// 压缩类型</span></span><br><span class="line">    <span class="keyword">uint8_t</span>     ih_name[IH_NMLEN];  <span class="comment">/* Image Name       */</span> <span class="comment">// 镜像名</span></span><br><span class="line">} <span class="keyword">image_header_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IH_NMLEN        32  <span class="comment">/* Image Name Length        */</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>通过比较编译出的uImage和zImage，其大小符合上述我们说的，并且可以通过这64字节得到</p>
<ul>
<li><p>ih_magic 0x27051956 幻术头</p>
</li>
<li><p>ih_size 003fe868 4188264 zImage大小</p>
</li>
<li><p>ih_load 0x20008000 数据加载地址</p>
</li>
<li><p>ih_ep 0x20008000 入口地址</p>
</li>
<li><p>etc</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204241433964.png"></p>
</li>
</ul>
</blockquote>
<p>bootm 格式如下</p>
<p><code>bootm Legacy-uImage加载地址 ramdisk加载地址 dtb加载地址</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设Legacy-uImage的加载地址是0x20008000，ramdisk的加载地址是0x21000000，fdt的加载地址是0x22000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.只加载kernel的情况下</span></span><br><span class="line">bootm <span class="number">0x20008000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 加载kernel和ramdisk</span></span><br><span class="line">bootm <span class="number">0x20008000</span> <span class="number">0x21000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载kernel和fdt</span></span><br><span class="line">bootm <span class="number">0x20008000</span> - <span class="number">0x22000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.加载kernel、ramdisk、fdt</span></span><br><span class="line">bootm <span class="number">0x20008000</span> <span class="number">0x21000000</span> <span class="number">0x22000000</span></span><br></pre></td></tr></tbody></table></figure>

<p>看一下do_bootm的代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_bootm</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	debug(<span class="string">"argc:%d\r\n"</span>,argc);</span><br><span class="line">	<span class="keyword">int</span> idx=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(;idx&lt;argc;idx++){</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"argv[%d]:%s\r\n"</span>,idx,argv[idx]);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//  在这里，bootm的第一个参数会被去掉。</span></span><br><span class="line">        <span class="comment">//  也就是当"bootm 0x20000000 - 0x21000000 "时，</span></span><br><span class="line">        <span class="comment">//  argc = 3，argv[0] = "0x20000000"，argv[1]= "-"，argv[2]="0x21000000"</span></span><br><span class="line">        <span class="comment">//  当"bootm 0x20000000"时，argc=1，argv[0]="0x20000000"</span></span><br><span class="line">	argc--; argv++;</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">char</span> *endp;</span><br><span class="line">		simple_strtoul(argv[<span class="number">0</span>], &amp;endp, <span class="number">16</span>);</span><br><span class="line">		<span class="keyword">if</span> ((*endp != <span class="number">0</span>) &amp;&amp; (*endp != <span class="string">':'</span>) &amp;&amp; (*endp != <span class="string">'#'</span>)) <span class="comment">// 判断是否有子命令，这里我们不管。</span></span><br><span class="line">			<span class="keyword">return</span> do_bootm_subcommand(cmdtp, flag, argc, argv);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |</span><br><span class="line">		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |</span><br><span class="line">		BOOTM_STATE_LOADOS |</span><br><span class="line">		BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |</span><br><span class="line">		BOOTM_STATE_OS_GO, &amp;images, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过日志可得，其传入的参数也就是我们在bootcmd中配置的bootm及其参数，也就是加载在0x20000000处的kernel和0x21000000处的设备树。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[File:common/cmd_bootm.c, Line:797, Function:do_bootm] argc:4</span><br><span class="line">argv[0]:bootm</span><br><span class="line">argv[1]:20000000</span><br><span class="line">argv[2]:-</span><br><span class="line">argv[3]:21000000</span><br></pre></td></tr></tbody></table></figure>

<p>最后，跳转到 <code>do_bootm_states</code>中，此时标志有 </p>
<ul>
<li>BOOTM_STATE_START</li>
<li>BOOTM_STATE_FINDOS</li>
<li>BOOTM_STATE_FINDOTHER</li>
<li>BOOTM_STATE_LOADOS</li>
<li>BOOTM_STATE_OS_PREP</li>
<li>BOOTM_STATE_OS_FAKE_GO</li>
<li>BOOTM_STATE_OS_GO</li>
</ul>
<p>还有一个全局参数 <code>images</code>的地址，而<code>images</code>的格式是<code>struct bootm_headers</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do_bootm</span><br><span class="line">    |</span><br><span class="line">    --&gt; do_bootm_states</span><br></pre></td></tr></tbody></table></figure>



<p><code>struct bootm_headers</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> {</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Legacy os image header, if it is a multi component image</span></span><br><span class="line"><span class="comment">	 * then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class="line"><span class="comment">	 * data from second and third component accordingly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">image_header_t</span>	*legacy_hdr_os;		<span class="comment">/* image header pointer */</span> <span class="comment">//Legacy-uImage的镜像头</span></span><br><span class="line">	<span class="keyword">image_header_t</span>	legacy_hdr_os_copy;	<span class="comment">/* header copy */</span>		<span class="comment">//Legacy-uImage的镜像头备份</span></span><br><span class="line">	ulong		legacy_hdr_valid;		<span class="comment">// Legacy-uImage的镜像头是否存在的标记</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_FIT)</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>	*fit_uname_cfg;	<span class="comment">/* configuration node unit name */</span>     <span class="comment">// 配置节点名</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		*fit_hdr_os;	<span class="comment">/* os FIT image header */</span>		<span class="comment">// FIT-uImage中kernel镜像头</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>	*fit_uname_os;	<span class="comment">/* os subimage node unit name */</span>   <span class="comment">// FIT-uImage中kernel的节点名</span></span><br><span class="line">	<span class="keyword">int</span>		fit_noffset_os;	<span class="comment">/* os subimage node offset */</span>	             <span class="comment">//  FIT-uImage中kernel的节点偏移</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		*fit_hdr_rd;	<span class="comment">/* init ramdisk FIT image header */</span> <span class="comment">// FIT-uImage中ramdisk的镜像头</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>	*fit_uname_rd;	<span class="comment">/* init ramdisk subimage node unit name */</span> <span class="comment">// FIT-uImage中ramdisk的节点名</span></span><br><span class="line">	<span class="keyword">int</span>		fit_noffset_rd;	<span class="comment">/* init ramdisk subimage node offset */</span>		       <span class="comment">// FIT-uImage中ramdisk的节点偏移</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>		*fit_hdr_fdt;	<span class="comment">/* FDT blob FIT image header */</span>		      <span class="comment">// FIT-uImage中FDT的镜像头</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>	*fit_uname_fdt;	<span class="comment">/* FDT blob subimage node unit name */</span>	<span class="comment">// FIT-uImage中FDT的节点名</span></span><br><span class="line">	<span class="keyword">int</span>		fit_noffset_fdt;<span class="comment">/* FDT blob subimage node offset */</span>			  <span class="comment">// FIT-uImage中ramdisk的节点偏移</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USE_HOSTCC</span></span><br><span class="line">	<span class="keyword">image_info_t</span>	os;		<span class="comment">/* os image info */</span>				<span class="comment">// 操作系统信息的结构体</span></span><br><span class="line">	ulong		ep;		<span class="comment">/* entry point of OS */</span>				<span class="comment">// 操作系统的入口地址</span></span><br><span class="line"></span><br><span class="line">	ulong		rd_start, rd_end;<span class="comment">/* ramdisk start/end */</span>		<span class="comment">// ramdisk在内存上的起始地址和结束地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>		*ft_addr;	<span class="comment">/* flat dev tree address */</span>			<span class="comment">// fdt在内存上的地址</span></span><br><span class="line">	ulong		ft_len;		<span class="comment">/* length of flat device tree */</span>	     <span class="comment">// fdt在内存上的长度</span></span><br><span class="line"></span><br><span class="line">	ulong		initrd_start;</span><br><span class="line">	ulong		initrd_end;</span><br><span class="line">	ulong		cmdline_start;</span><br><span class="line">	ulong		cmdline_end;</span><br><span class="line">	<span class="keyword">bd_t</span>		*kbd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		verify;		<span class="comment">/* getenv("verify")[0] != 'n' */</span> 	  <span class="comment">// 是否需要验证</span></span><br><span class="line">	<span class="keyword">int</span>		state;								<span class="comment">// 状态标识，用于标识对应的bootm需要做什么操作，具体看下面宏</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LMB</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lmb</span>	<span class="title">lmb</span>;</span>		<span class="comment">/* for memory mgmt */</span>	   <span class="comment">// 内存管理 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">} <span class="keyword">bootm_headers_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_START	(0x00000001) 		<span class="comment">//开始执行bootm的准备动作</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_FINDOS	(0x00000002) 		<span class="comment">// 查找操作系统镜像</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_FINDOTHER	(0x00000004)       <span class="comment">// 查找操作系统镜像外的其他镜像，比如FDT/ramdisk等</span></span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_LOADOS	(0x00000008) 		<span class="comment">// 加载操作系统</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_RAMDISK	(0x00000010)		<span class="comment">// 操作ramdisk</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_FDT		(0x00000020) 		  <span class="comment">// 操作FDT</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_OS_CMDLINE	(0x00000040)	<span class="comment">// 操作commandline</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_OS_BD_T	(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_OS_PREP	(0x00000100)		<span class="comment">// 跳转到操作系统前的准备动作</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_OS_FAKE_GO	(0x00000200)	<span class="comment">// 伪跳转，一般都能直接跳转到kernel中去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	BOOTM_STATE_OS_GO	(0x00000400) 		 <span class="comment">// 跳转到kernel中去</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">bootm_headers_t</span> images;</span><br></pre></td></tr></tbody></table></figure>



<p><code>do_bootm_states</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_bootm_states</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">char</span> * <span class="keyword">const</span> argv[], <span class="keyword">int</span> states, <span class="keyword">bootm_headers_t</span> *images,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> boot_progress)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	boot_os_fn *boot_fn;</span><br><span class="line">	ulong iflag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>, need_boot_fn;</span><br><span class="line">	<span class="comment">// 更新images-&gt;state中的状态标志</span></span><br><span class="line">	images-&gt;state |= states;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Work through the states and see how far we get. We stop on</span></span><br><span class="line"><span class="comment">	 * any error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">         <span class="comment">// 判断当前状态是否有BOOTM_STATE_START，也就是是否需要执行前的准备动作，如果需要则调用bootm_start</span></span><br><span class="line">	<span class="keyword">if</span> (states &amp; BOOTM_STATE_START)</span><br><span class="line">		ret = bootm_start(cmdtp, flag, argc, argv);</span><br><span class="line">	<span class="comment">// 判断当前状态是否有BOOTM_STATE_FINDOS，也就是是否需要执行查找OS，如果需要则调用 bootm_find_os，注意此步是紧接着上一步的</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOS))</span><br><span class="line">		ret = bootm_find_os(cmdtp, flag, argc, argv);</span><br><span class="line">	<span class="comment">// 判断当前状态是否有BOOTM_STATE_FINDOTHER，也就是是否需要执行查找其它FDT/ramdisk等，如果需要则调用bootm_find_other，注意此步是紧接着上一步的</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FINDOTHER)) {</span><br><span class="line">		ret = bootm_find_other(cmdtp, flag, argc, argv);</span><br><span class="line">		argc = <span class="number">0</span>;	<span class="comment">/* consume the args */</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：之前都是查找os，查找fdt等填充images中的结构，下面则是利用images中的结构数据。</span></span><br><span class="line">	<span class="comment">/* Load the OS */</span></span><br><span class="line">         <span class="comment">// 判断当前状态是否有BOOTM_STATE_LOADOS，也就是是否需要执行加载OS，如果需要则调用bootm_load_os，注意此步是紧接着上一步的</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_LOADOS)) {</span><br><span class="line">		ulong load_end;</span><br><span class="line"></span><br><span class="line">		iflag = bootm_disable_interrupts();</span><br><span class="line">		ret = bootm_load_os(images, &amp;load_end, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			lmb_reserve(&amp;images-&gt;lmb, images-&gt;os.load,</span><br><span class="line">				    (load_end - images-&gt;os.load));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret &amp;&amp; ret != BOOTM_ERR_OVERLAP)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_OVERLAP)</span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SILENT_CONSOLE) &amp;&amp; !defined(CONFIG_SILENT_U_BOOT_ONLY)</span></span><br><span class="line">		<span class="keyword">if</span> (images-&gt;os.os == IH_OS_LINUX)</span><br><span class="line">			fixup_silent_linux();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Relocate the ramdisk */</span> <span class="comment">// 是否需要重定向ramdinsk，do_bootm流程的话是不需要的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_BOOT_RAMDISK_HIGH</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_RAMDISK)) {</span><br><span class="line">		ulong rd_len = images-&gt;rd_end - images-&gt;rd_start;</span><br><span class="line"></span><br><span class="line">		ret = boot_ramdisk_high(&amp;images-&gt;lmb, images-&gt;rd_start,</span><br><span class="line">			rd_len, &amp;images-&gt;initrd_start, &amp;images-&gt;initrd_end);</span><br><span class="line">		<span class="keyword">if</span> (!ret) {</span><br><span class="line">			setenv_hex(<span class="string">"initrd_start"</span>, images-&gt;initrd_start);</span><br><span class="line">			setenv_hex(<span class="string">"initrd_end"</span>, images-&gt;initrd_end);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_LIBFDT) &amp;&amp; defined(CONFIG_LMB)</span></span><br><span class="line">         <span class="comment">// 是否需要重定向fdt，do_bootm流程的话是不需要的</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_FDT)) {</span><br><span class="line">		boot_fdt_add_mem_rsv_regions(&amp;images-&gt;lmb, images-&gt;ft_addr);</span><br><span class="line">		ret = boot_relocate_fdt(&amp;images-&gt;lmb, &amp;images-&gt;ft_addr,</span><br><span class="line">					&amp;images-&gt;ft_len);</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* From now on, we need the OS boot function */</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">        <span class="comment">// 获取对应操作系统的启动函数，存放到boot_fn中</span></span><br><span class="line">	boot_fn = boot_os[images-&gt;os.os];</span><br><span class="line">	need_boot_fn = states &amp; (BOOTM_STATE_OS_CMDLINE |</span><br><span class="line">			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |</span><br><span class="line">			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);</span><br><span class="line">	<span class="keyword">if</span> (boot_fn == <span class="literal">NULL</span> &amp;&amp; need_boot_fn) {</span><br><span class="line">		<span class="keyword">if</span> (iflag)</span><br><span class="line">			enable_interrupts();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"ERROR: booting os '%s' (%d) is not supported\n"</span>,</span><br><span class="line">		       genimg_get_os_name(images-&gt;os.os), images-&gt;os.os);</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Call various other states that are not generally used */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_CMDLINE))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, images);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_BD_T))</span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, images);</span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_PREP))<span class="comment">// 判断当前状态是否有BOOTM_STATE_OS_PREP，也就是跳转前的最后准备动作，如果需要则调用boot_fn</span></span><br><span class="line">		ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">	 <span class="comment">// 判断当前状态是否有BOOTM_STATE_OS_FAKE_GO，伪跳转到操作系统。</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_FAKE_GO)) {</span><br><span class="line">		<span class="keyword">char</span> *cmd_list = getenv(<span class="string">"fakegocmd"</span>);</span><br><span class="line"></span><br><span class="line">		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,</span><br><span class="line">				images, boot_fn);</span><br><span class="line">		<span class="keyword">if</span> (!ret &amp;&amp; cmd_list)</span><br><span class="line">			ret = run_command_list(cmd_list, <span class="number">-1</span>, flag);</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for unsupported subcommand. */</span></span><br><span class="line">	<span class="keyword">if</span> (ret) {</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"subcommand not supported\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now run the OS! We hope this doesn't return */</span> <span class="comment">// 判断当前状态是否有BOOTM_STATE_OS_GO，也就是现在直接跳转到SO，并且不需要返回</span></span><br><span class="line">	<span class="keyword">if</span> (!ret &amp;&amp; (states &amp; BOOTM_STATE_OS_GO))</span><br><span class="line">		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,</span><br><span class="line">				images, boot_fn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Deal with any fallout */</span></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (iflag)</span><br><span class="line">		enable_interrupts();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == BOOTM_ERR_UNIMPLEMENTED)</span><br><span class="line">		bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret == BOOTM_ERR_RESET)</span><br><span class="line">		do_reset(cmdtp, flag, argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>BOOTM_STATE_START</strong></p>
<p>bootm_start，简单看一下，其实也就是初始化<code>bootm_headers_t images</code>，也就是从环境变量中获取 <code>verify</code>对应的value，然后返回0或1，赋值给<code>images.verify</code>。配置images中的内存保留区域，标记images中的当前状态。</p>
<p><strong>实现verify和lmb</strong></p>
<blockquote>
<p>LMB是指logical memory blocks，主要是用于表示内存的保留区域，主要有fdt的区域，ramdisk的区域等等。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/cmd_bootm.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bootm_start</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">memset</span>((<span class="keyword">void</span> *)&amp;images, <span class="number">0</span>, <span class="keyword">sizeof</span>(images));</span><br><span class="line">	images.verify = getenv_yesno(<span class="string">"verify"</span>);</span><br><span class="line"></span><br><span class="line">	boot_start_lmb(&amp;images);</span><br><span class="line"></span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, <span class="string">"bootm_start"</span>);</span><br><span class="line">	images.state = BOOTM_STATE_START;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// common/cmd_bootm.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">boot_start_lmb</span><span class="params">(<span class="keyword">bootm_headers_t</span> *images)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ulong		mem_start;</span><br><span class="line">	<span class="keyword">phys_size_t</span>	mem_size;</span><br><span class="line">	<span class="comment">// 先初始化images的lmb内存管理，注意cnt为1</span></span><br><span class="line">	lmb_init(&amp;images-&gt;lmb);</span><br><span class="line">	<span class="comment">// 然后从环境变量中获取bootm_low，我们的板子上没有但是定义了CONFIG_SYS_SDRAM_BASE，所以此处返回 CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line">	mem_start = getenv_bootm_low();</span><br><span class="line">	mem_size = getenv_bootm_size(); <span class="comment">// 从环境变量中获取 bootm_size，但是我们的板子上又没有，所以此函数中tmp为0，然后CONFIG_ARM有定义，所以此处的值为 gd-&gt;bd-&gt;bi_dram[0].size - tmp，也就是 gd-&gt;bd-&gt;bi_dram[0].size，也就是 PHYS_SDRAM_1_SIZE</span></span><br><span class="line">	<span class="comment">// 此处也就是将 mem_start, mem_size，配置到images-&gt;lmb中，在此处会用到cnt=1</span></span><br><span class="line">	lmb_add(&amp;images-&gt;lmb, (<span class="keyword">phys_addr_t</span>)mem_start, mem_size);</span><br><span class="line">	<span class="comment">// 这两个函数的作用暂时不理解</span></span><br><span class="line">	arch_lmb_reserve(&amp;images-&gt;lmb);</span><br><span class="line">	board_lmb_reserve(&amp;images-&gt;lmb);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>BOOTM_STATE_FINDOS</strong></p>
<p>bootm_find_os，主要是验证内核，从<code>bootm</code>命令及<code>image_header</code>中获取内核信息并更新到<code>images</code>。</p>
<p>实现os和ep。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bootm_find_os</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *os_hdr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get kernel image header, start address and length */</span></span><br><span class="line">	<span class="comment">// 验证内核，获取kernel起始地址和长度</span></span><br><span class="line">	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,</span><br><span class="line">			&amp;images, &amp;images.os.image_start, &amp;images.os.image_len);</span><br><span class="line">	<span class="keyword">if</span> (images.os.image_len == <span class="number">0</span>) {</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"ERROR: can't get kernel image!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get image parameters */</span> </span><br><span class="line">	<span class="comment">// 更新images中的参数</span></span><br><span class="line">	<span class="keyword">switch</span> (genimg_get_format(os_hdr)) {</span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_LEGACY:</span><br><span class="line">		images.os.type = image_get_type(os_hdr);</span><br><span class="line">		images.os.comp = image_get_comp(os_hdr);</span><br><span class="line">		images.os.os = image_get_os(os_hdr);</span><br><span class="line"></span><br><span class="line">		images.os.end = image_get_image_end(os_hdr);</span><br><span class="line">		images.os.load = image_get_load(os_hdr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_FIT)</span></span><br><span class="line">	<span class="keyword">case</span> IMAGE_FORMAT_FIT:</span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_type(images.fit_hdr_os,</span><br><span class="line">					images.fit_noffset_os, &amp;images.os.type)) {</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"Can't get image type!\n"</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_TYPE);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_comp(images.fit_hdr_os,</span><br><span class="line">					images.fit_noffset_os, &amp;images.os.comp)) {</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"Can't get image compression!\n"</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_COMPRESSION);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_os(images.fit_hdr_os,</span><br><span class="line">					images.fit_noffset_os, &amp;images.os.os)) {</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"Can't get image OS!\n"</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_OS);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		images.os.end = fit_get_end(images.fit_hdr_os);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fit_image_get_load(images.fit_hdr_os, images.fit_noffset_os,</span><br><span class="line">					&amp;images.os.load)) {</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"Can't get image load address!\n"</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_FIT_LOADADDR);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"ERROR: unknown image format type!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find kernel entry point */</span> </span><br><span class="line">	<span class="comment">// 获取内核的entry point</span></span><br><span class="line">	<span class="keyword">if</span> (images.legacy_hdr_valid) {</span><br><span class="line">		images.ep = image_get_ep(&amp;images.legacy_hdr_os_copy);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_FIT)</span></span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (images.fit_uname_os) {</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		ret = fit_image_get_entry(images.fit_hdr_os,</span><br><span class="line">					  images.fit_noffset_os, &amp;images.ep);</span><br><span class="line">		<span class="keyword">if</span> (ret) {</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"Can't get entry point property!\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Could not find kernel entry point!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (images.os.type == IH_TYPE_KERNEL_NOLOAD) {</span><br><span class="line">		images.os.load = images.os.image_start;</span><br><span class="line">		images.ep += images.os.load;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	images.os.start = (ulong)os_hdr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>BOOTM_STATE_FINDOTHER</strong></p>
<p>bootm_find_other</p>
<p>实现rd_start，rd_end，ft_addr和initrd_end。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bootm_find_other</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="params"><span class="function">			    <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (((images.os.type == IH_TYPE_KERNEL) ||</span><br><span class="line">	     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||</span><br><span class="line">	     (images.os.type == IH_TYPE_MULTI)) &amp;&amp;</span><br><span class="line">	    (images.os.os == IH_OS_LINUX ||</span><br><span class="line">		 images.os.os == IH_OS_VXWORKS)) {</span><br><span class="line">		<span class="keyword">if</span> (bootm_find_ramdisk(flag, argc, argv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_LIBFDT)</span></span><br><span class="line">		<span class="keyword">if</span> (bootm_find_fdt(flag, argc, argv))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先看<code>bootm_find_ramdisk</code>，由于我们在bootm中传递的ramfs值为<code>-</code>，也就是忽略ramfs的意思，所以会直接跳过，详见下面的日志。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[File:common/image.c, Line:814, Function:boot_get_ramdisk] ## Skipping init Ramdisk</span><br><span class="line">[File:common/image.c, Line:944, Function:boot_get_ramdisk] ## No init Ramdisk</span><br><span class="line">[File:common/image.c, Line:950, Function:boot_get_ramdisk]    ramdisk start = 0x00000000, ramdisk end = 0x00000000</span><br></pre></td></tr></tbody></table></figure>

<p>接着看一下<code>bootm_find_fdt</code>，无非就是验证bootm中的第三个参数以及是否可用，并确认设备树的类型，根据日志对应着代码看就可，此处不在展开说。</p>
<p>另外，此处会把</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[File:common/image-fdt.c, Line:<span class="number">271</span>, Function:boot_get_fdt] *  fdt: cmdline image address = <span class="number">0x21000000</span></span><br><span class="line">[File:common/image-fdt.c, Line:<span class="number">289</span>, Function:boot_get_fdt] ## Checking <span class="keyword">for</span> <span class="string">'FDT'</span>/<span class="string">'FDT Image'</span> at <span class="number">21000000</span></span><br><span class="line">[File:common/image-fdt.c, Line:<span class="number">370</span>, Function:boot_get_fdt] *  fdt: raw FDT blob</span><br><span class="line">## Flattened Device Tree blob at <span class="number">21000000</span></span><br><span class="line">   Booting <span class="keyword">using</span> the fdt blob at <span class="number">0x21000000</span></span><br></pre></td></tr></tbody></table></figure>



<p><strong>BOOTM_STATE_LOADOS</strong></p>
<p>bootm_load_os</p>
<p>在<a href="#do_bootm">do_bootm</a>中可知uImage header的定义，所以我们可以得出镜像压缩类型值为0，此处也即走<code>IH_COMP_NONE</code>分支，所以会有如下打印</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   Loading Kernel Image ... OK</span><br><span class="line">[File:common/cmd_bootm.c, Line:481, Function:bootm_load_os]    kernel loaded at 0x20008000, end = 0x20406868</span><br><span class="line">[File:common/cmd_bootm.c, Line:486, Function:bootm_load_os] images.os.start = 0x20000000, images.os.end = 0x203fe8a8</span><br><span class="line">[File:common/cmd_bootm.c, Line:488, Function:bootm_load_os] images.os.load = 0x20008000, load_end = 0x20406868</span><br></pre></td></tr></tbody></table></figure>

<p>精简一下代码，去掉不走的分支，如下，此处功能就是通过<code>images</code>获得镜像信息，看是否需要解压镜像，验证类型等。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/cmd_bootm.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bootm_load_os</span><span class="params">(<span class="keyword">bootm_headers_t</span> *images, <span class="keyword">unsigned</span> <span class="keyword">long</span> *load_end,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> boot_progress)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">image_info_t</span> os = images-&gt;os;</span><br><span class="line">	<span class="keyword">uint8_t</span> comp = os.comp;</span><br><span class="line">	ulong load = os.load;</span><br><span class="line">	ulong blob_start = os.start;</span><br><span class="line">	ulong blob_end = os.end;</span><br><span class="line">	ulong image_start = os.image_start;</span><br><span class="line">	ulong image_len = os.image_len;</span><br><span class="line">	__maybe_unused uint unc_len = CONFIG_SYS_BOOTM_LEN;</span><br><span class="line">	<span class="keyword">int</span> no_overlap = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span> *load_buf, *image_buf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_LZMA) || defined(CONFIG_LZO)</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *type_name = genimg_get_type_name(os.type);</span><br><span class="line"></span><br><span class="line">	load_buf = map_sysmem(load, unc_len);</span><br><span class="line">	image_buf = map_sysmem(image_start, image_len);</span><br><span class="line">	<span class="keyword">switch</span> (comp) {</span><br><span class="line">	<span class="keyword">case</span> IH_COMP_NONE:</span><br><span class="line">		<span class="keyword">if</span> (load == blob_start || load == image_start) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"   XIP %s ... "</span>, type_name);</span><br><span class="line">			no_overlap = <span class="number">1</span>;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"   Loading %s ... "</span>, type_name);</span><br><span class="line">			memmove_wd(load_buf, image_buf, image_len, CHUNKSZ);</span><br><span class="line">		}</span><br><span class="line">		*load_end = load + image_len;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GZIP</span></span><br><span class="line">	<span class="keyword">case</span> IH_COMP_GZIP:</span><br><span class="line">		...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_GZIP */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BZIP2</span></span><br><span class="line">	<span class="keyword">case</span> IH_COMP_BZIP2:</span><br><span class="line">		...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_BZIP2 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LZMA</span></span><br><span class="line">	<span class="keyword">case</span> IH_COMP_LZMA: </span><br><span class="line">		...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_LZMA */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LZO</span></span><br><span class="line">	<span class="keyword">case</span> IH_COMP_LZO: </span><br><span class="line">		...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_LZO */</span></span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Unimplemented compression type %d\n"</span>, comp);</span><br><span class="line">		<span class="keyword">return</span> BOOTM_ERR_UNIMPLEMENTED;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	flush_cache(load, (*load_end - load) * <span class="keyword">sizeof</span>(ulong));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">	debug(<span class="string">"   kernel loaded at 0x%08lx, end = 0x%08lx\n"</span>, load, *load_end);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!no_overlap &amp;&amp; (load &lt; blob_end) &amp;&amp; (*load_end &gt; blob_start)) {</span><br><span class="line">		debug(<span class="string">"images.os.start = 0x%lX, images.os.end = 0x%lx\n"</span>,blob_start, blob_end);</span><br><span class="line">		debug(<span class="string">"images.os.load = 0x%lx, load_end = 0x%lx\n"</span>, load,*load_end);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check what type of image this is. */</span></span><br><span class="line">		<span class="keyword">if</span> (images-&gt;legacy_hdr_valid) {</span><br><span class="line">			<span class="keyword">if</span> (image_get_type(&amp;images-&gt;legacy_hdr_os_copy)== IH_TYPE_MULTI)</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"WARNING: legacy format multi component image overwritten\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> BOOTM_ERR_OVERLAP;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"ERROR: new format image overwritten - must RESET the board to recover\n"</span>);</span><br><span class="line">			bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);</span><br><span class="line">			<span class="keyword">return</span> BOOTM_ERR_RESET;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>回到 do_bootm_states函数，调用<code>lmb_reserve</code>对剩余的内存进行管理。</p>
<p><code>BOOTM_STATE_RAMDISK</code></p>
<p>接着调用<code>boot_ramdisk_high</code>，然而其中的rd_data为0，所以整个函数退出。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[File:common/image.c, Line:1003, Function:boot_ramdisk_high] ## initrd_high = 0xffffffff, copy_to_ram = 1</span><br><span class="line">[File:common/image.c, Line:1047, Function:boot_ramdisk_high]    ramdisk load start = 0x00000000, ramdisk load end = 0x00000000</span><br></pre></td></tr></tbody></table></figure>



<p><code>BOOTM_STATE_FDT</code> </p>
<p>验证FDT，将代码从<code>21000000</code>重定位到<code>3fe30000</code>处。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[File:common/image-fdt.c, Line:175, Function:boot_relocate_fdt] ## device tree at 21000000 ... 210063a5 (len=37798 [0x93A6])</span><br><span class="line">   Loading Device Tree to 3fe30000, end 3fe393a5 ... OK</span><br></pre></td></tr></tbody></table></figure>



<p>接着配置<code>boot_fn</code>，由于是<code>images-&gt;os.os</code>为1，也就是linux，所以 <code>boot_fn=do_bootm_linux</code></p>
<p>由于上面 states 中含有这几个标志，</p>
<ul>
<li>BOOTM_STATE_START</li>
<li>BOOTM_STATE_FINDOS</li>
<li>BOOTM_STATE_FINDOTHER</li>
<li>BOOTM_STATE_LOADOS</li>
<li>BOOTM_STATE_OS_PREP</li>
<li>BOOTM_STATE_OS_FAKE_GO</li>
<li>BOOTM_STATE_OS_GO</li>
</ul>
<p>当前要配置的状态有</p>
<ul>
<li>BOOTM_STATE_OS_CMDLINE</li>
<li>BOOTM_STATE_OS_BD_T</li>
<li>BOOTM_STATE_OS_PREP</li>
<li>BOOTM_STATE_OS_FAKE_GO</li>
<li>BOOTM_STATE_OS_GO</li>
</ul>
<p><code>need_boot_fn</code>状态为二者共有的，也即BOOTM_STATE_OS_PREP、BOOTM_STATE_OS_FAKE_GO、BOOTM_STATE_OS_GO</p>
<p>所以，接着会调用 <code>do_bootm_linux(BOOTM_STATE_OS_PREP, argc, argv, images);</code></p>
<p>也就是会调用 <code>boot_jump_linux</code></p>
<p>看下 <code>boot_jump_linux</code>，我们是32位的ARM，所以删掉64位的代码。直接看剩下的，获取设备id，并从环境变量中获取<code>machid</code>对应的value，打印。</p>
<p>然后定义一个函数指针，有三个参数，其类型分别为 <code>int, int, uint</code>，</p>
<blockquote>
<p>内核启动之前要求r0为0，r1为machid，r2为atags或设备树地址。</p>
</blockquote>
<p>所以对应的为r0，r1，r2。</p>
<p>然后<code>kernel_entry(0, machid, r2)</code>也就是直接执行内核entry point处的代码，换句话说也就是跳转到了kernel中。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">boot_jump_linux</span><span class="params">(<span class="keyword">bootm_headers_t</span> *images, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARM64</span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> machid = gd-&gt;bd-&gt;bi_arch_number;</span><br><span class="line">	<span class="keyword">char</span> *s;</span><br><span class="line">	<span class="keyword">void</span> (*kernel_entry)(<span class="keyword">int</span> zero, <span class="keyword">int</span> arch, uint params);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r2;</span><br><span class="line">	<span class="keyword">int</span> fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);</span><br><span class="line"></span><br><span class="line">	kernel_entry = (<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>, uint))images-&gt;ep;</span><br><span class="line"></span><br><span class="line">	s = getenv(<span class="string">"machid"</span>);</span><br><span class="line">	<span class="keyword">if</span> (s) {</span><br><span class="line">		strict_strtoul(s, <span class="number">16</span>, &amp;machid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Using machid 0x%lx from environment\n"</span>, machid);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"## Transferring control to Linux (at address %08lx)"</span> <span class="string">"...\n"</span>, (ulong) kernel_entry);</span><br><span class="line">	bootstage_mark(BOOTSTAGE_ID_RUN_OS);</span><br><span class="line">	announce_and_cleanup(fake);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len)</span><br><span class="line">		r2 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)images-&gt;ft_addr;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		r2 = gd-&gt;bd-&gt;bi_boot_params;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fake)</span><br><span class="line">		kernel_entry(<span class="number">0</span>, machid, r2);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/u-boot/boot_flow_1.html">wowo的u-boot启动流程分析（1）平台相关部分_</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ooonebook/category_6471981.html">ooonebook大佬的project-X系列</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ooonebook/category_6484145.html">ooonebook大佬的u-boot系列</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/limingth/ARM-Resources/blob/master/tiny210/Datasheet/S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf">S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/limingth/ARM-Resources/blob/master/tiny210/Datasheet/S5PV210_UM_REV1.1.pdf">S5PV210_UM_REV1.1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://re-eject.gbadev.org/files/GasARMRef.pdf">https://re-eject.gbadev.org/files/GasARMRef.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_55796564/article/details/119949722">第三十二章 U-Boot启动流程详解 -摘自【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.0</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012176730/article/details/54670569">嵌入式Linux学习：u-boot源码分析（1）–AM335X系列的2014.10版</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40531974/article/details/83897559">ARM汇编指令集汇总</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouqt/article/details/78172332">ARM指令CMP详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zackary/p/9343253.html"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zackary/p/9343253.html">ARM 汇编指令 ADR 与 LDR 使用 </a></li>
<li><a target="_blank" rel="noopener" href="https://0uyangsheng.github.io/2018/04/25/Deep-into-Rk3399-uboot/">谈谈 U-boot 启动流程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzxb1995/article/details/103458589">u-boot-2019.10源码分析——init_sequence_f中的函数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/skyflying2012/article/details/39005705">uboot环境变量实现分析</a></li>
<li><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/Scripts.html">LD脚本</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ec39403db315">u-boot.lds链接文件详解</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-23193900-id-3251565.html">Arm汇编指令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0c6192da2fd0">ARM汇编之解惑条件标志，条件码，条件执行</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16777851/article/details/81749077">从零开始之uboot、移植uboot2017.01 @奔跑的小刺猬</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lifexy/p/7203786.html">协处理器CP15介绍—MCR/MRC指令</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/374941834">网卡DM9000裸机驱动详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.crifan.com/files/doc/docbook/linux_nand_driver/release/html/linux_nand_driver.html">【详解】如何编写Linux下Nand Flash驱动</a></li>
<li><a target="_blank" rel="noopener" href="https://wushifu-notes.readthedocs.io/zh/latest/u-boot%20%E4%B8%AD%E7%9A%84%20shell/">u-boot 中的 shell</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33894122/article/details/86129765">Uboot命令U_BOOT_CMD分析</a></li>
<li><a target="_blank" rel="noopener" href="https://oska874.github.io/%E6%BA%90%E7%A0%81/uboot%E7%9A%84%E7%BD%91%E7%BB%9C.html">u-boot的网络</a></li>
<li><a target="_blank" rel="noopener" href="https://git.busybox.net/busybox/tree/shell/hush_doc.txt">busybox中hush_doc的说明</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2f4a5f74ac7a">ARM64 汇编——寄存器和指令</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://gonglja.github.io">lj gong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gonglja.github.io/posts/f88e6d17/">http://gonglja.github.io/posts/f88e6d17/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gonglja.github.io" target="_blank">Gong's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/eeea93b8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TEST</div></div></a></div><div class="next-post pull-right"><a href="/posts/d78cdbc6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://archlinux.org/static/logos/archlinux-logo-dark-1200dpi.b42bd35d5916.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Archlinux从安装到使用（持续更新中）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111228921.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lj gong</div><div class="author-info__description">蓬生麻中，不扶而直，白沙在涅，与之俱黑。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Gonglja"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/gonglja" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:glj0@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">2022重新出发！加油加油</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#u-boot-2014-04-%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">u-boot-2014.04 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#s5pv210"><span class="toc-number">1.1.</span> <span class="toc-text">s5pv210</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">芯片启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BL0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">BL0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BL1"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">BL1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BL2"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">BL2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">地址映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u-boot"><span class="toc-number">1.2.</span> <span class="toc-text">u-boot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">编译问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">错误1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#negative-squared-cross-mark-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">❎指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x-2022%E4%B8%AD%E7%9A%84-start%E4%B8%8D%E7%9C%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">❌2022中的_start不看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9B%BE"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">代码函数调用图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">_start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-init-cp15"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">cpu_init_cp15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-init-crit"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">cpu_init_crit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x-lowlevel-init-%E5%88%86%E6%9E%90%E9%94%99%E8%AF%AF"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">❌lowlevel_init(分析错误)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lowlevel-init"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">lowlevel_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main"><span class="toc-number">1.3.4.8.</span> <span class="toc-text">_main</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-bl2-to-ram"><span class="toc-number">1.3.4.9.</span> <span class="toc-text">copy_bl2_to_ram</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#board-init-f"><span class="toc-number">1.3.4.10.</span> <span class="toc-text">board_init_f</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#global-data"><span class="toc-number">1.3.4.10.1.</span> <span class="toc-text">global_data</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arch-cpu-init"><span class="toc-number">1.3.4.10.2.</span> <span class="toc-text">arch_cpu_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mark-bootstage"><span class="toc-number">1.3.4.10.3.</span> <span class="toc-text">mark_bootstage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fdtdec-check-fdt"><span class="toc-number">1.3.4.10.4.</span> <span class="toc-text">fdtdec_check_fdt</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#board-early-init-f"><span class="toc-number">1.3.4.10.5.</span> <span class="toc-text">board_early_init_f</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#timer-init"><span class="toc-number">1.3.4.10.6.</span> <span class="toc-text">timer_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#board-postclk-init"><span class="toc-number">1.3.4.10.7.</span> <span class="toc-text">board_postclk_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get-clocks"><span class="toc-number">1.3.4.10.8.</span> <span class="toc-text">get_clocks</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#env-init"><span class="toc-number">1.3.4.10.9.</span> <span class="toc-text">env_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#init-baudrate"><span class="toc-number">1.3.4.10.10.</span> <span class="toc-text">init_baudrate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#serial-init"><span class="toc-number">1.3.4.10.11.</span> <span class="toc-text">serial_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#console-init-f"><span class="toc-number">1.3.4.10.12.</span> <span class="toc-text">console_init_f</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#display-banner"><span class="toc-number">1.3.4.10.13.</span> <span class="toc-text">display_banner</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#print-cpuinfo"><span class="toc-number">1.3.4.10.14.</span> <span class="toc-text">print_cpuinfo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#checkboard"><span class="toc-number">1.3.4.10.15.</span> <span class="toc-text">checkboard</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#init-func-i2c"><span class="toc-number">1.3.4.10.16.</span> <span class="toc-text">init_func_i2c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#negative-squared-cross-mark-dram-init"><span class="toc-number">1.3.4.10.17.</span> <span class="toc-text">❎ dram_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">1.3.4.10.18.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E7%BB%A7%E7%BB%AD%EF%BC%8C%E6%8E%A5%E4%B8%8A%E6%96%87"><span class="toc-number">1.3.4.11.</span> <span class="toc-text">_main 继续，接上文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#relocate-code"><span class="toc-number">1.3.4.12.</span> <span class="toc-text">relocate_code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E7%BB%A7%E7%BB%AD%EF%BC%8C%E6%8E%A5%E4%B8%8A%E6%96%87%EF%BC%9Ahere"><span class="toc-number">1.3.4.13.</span> <span class="toc-text">_main 继续，接上文：here</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#negative-squared-cross-mark-c-runtime-cpu-setup"><span class="toc-number">1.3.4.13.1.</span> <span class="toc-text">❎ c_runtime_cpu_setup</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#board-init-r"><span class="toc-number">1.3.4.14.</span> <span class="toc-text">board_init_r</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#enable-caches"><span class="toc-number">1.3.4.14.1.</span> <span class="toc-text">enable_caches</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#negative-squared-cross-mark-board-init"><span class="toc-number">1.3.4.14.2.</span> <span class="toc-text">❎ board_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#serial-initialize"><span class="toc-number">1.3.4.14.3.</span> <span class="toc-text">serial_initialize</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mem-malloc-init"><span class="toc-number">1.3.4.14.4.</span> <span class="toc-text">mem_malloc_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#power-init-board"><span class="toc-number">1.3.4.14.5.</span> <span class="toc-text">power_init_board</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nand-init"><span class="toc-number">1.3.4.14.6.</span> <span class="toc-text">nand_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#should-load-env"><span class="toc-number">1.3.4.14.7.</span> <span class="toc-text">should_load_env</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#negative-squared-cross-mark-stdio-init"><span class="toc-number">1.3.4.14.8.</span> <span class="toc-text">❎ stdio_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jumptable-init"><span class="toc-number">1.3.4.14.9.</span> <span class="toc-text">jumptable_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#console-init-r"><span class="toc-number">1.3.4.14.10.</span> <span class="toc-text">console_init_r</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#checkboard-1"><span class="toc-number">1.3.4.14.11.</span> <span class="toc-text">checkboard</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#negative-squared-cross-mark-interrupt-init"><span class="toc-number">1.3.4.14.12.</span> <span class="toc-text">❎ interrupt_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#enable-interrupts"><span class="toc-number">1.3.4.14.13.</span> <span class="toc-text">enable_interrupts</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#eth-initialize"><span class="toc-number">1.3.4.14.14.</span> <span class="toc-text">eth_initialize</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#main-loop"><span class="toc-number">1.3.4.14.15.</span> <span class="toc-text">main_loop</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#u-boot-hush-start"><span class="toc-number">1.3.4.14.15.1.</span> <span class="toc-text">u_boot_hush_start</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#process-boot-delay"><span class="toc-number">1.3.4.14.15.2.</span> <span class="toc-text">process_boot_delay</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#run-command-list"><span class="toc-number">1.3.4.14.15.3.</span> <span class="toc-text">run_command_list</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#parse-string-outer"><span class="toc-number">1.3.4.14.15.4.</span> <span class="toc-text">parse_string_outer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#parse-stream-outer"><span class="toc-number">1.3.4.14.15.5.</span> <span class="toc-text">parse_stream_outer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#negative-squared-cross-mark-p-context"><span class="toc-number">1.3.4.14.15.6.</span> <span class="toc-text">❎ p_context</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#run-list"><span class="toc-number">1.3.4.14.15.7.</span> <span class="toc-text">run_list</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#negative-squared-cross-mark-run-list-real"><span class="toc-number">1.3.4.14.15.8.</span> <span class="toc-text">❎ run_list_real</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#negative-squared-cross-mark-run-pipe-real"><span class="toc-number">1.3.4.14.15.9.</span> <span class="toc-text">❎ run_pipe_real</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cmd-process"><span class="toc-number">1.3.4.14.15.10.</span> <span class="toc-text">cmd_process</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cmd-call"><span class="toc-number">1.3.4.14.15.11.</span> <span class="toc-text">cmd_call</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#do-nfs"><span class="toc-number">1.3.4.14.15.12.</span> <span class="toc-text">do_nfs</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#do-bootm"><span class="toc-number">1.3.4.14.15.13.</span> <span class="toc-text">do_bootm</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4a17b156/" title="Hello World"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/posts/4a17b156/" title="Hello World">Hello World</a><time datetime="2022-06-08T14:13:43.721Z" title="发表于 2022-06-08 22:13:43">2022-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/42edd7ca/" title="docker下使用Dokerfile创建image"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202206081114268.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker下使用Dokerfile创建image"/></a><div class="content"><a class="title" href="/posts/42edd7ca/" title="docker下使用Dokerfile创建image">docker下使用Dokerfile创建image</a><time datetime="2022-06-08T02:52:40.000Z" title="发表于 2022-06-08 10:52:40">2022-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b6db5676/" title="c语言运算符优先级"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言运算符优先级"/></a><div class="content"><a class="title" href="/posts/b6db5676/" title="c语言运算符优先级">c语言运算符优先级</a><time datetime="2022-05-23T09:50:02.000Z" title="发表于 2022-05-23 17:50:02">2022-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6c58185/" title="ubuntu下docker的使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ubuntu下docker的使用"/></a><div class="content"><a class="title" href="/posts/6c58185/" title="ubuntu下docker的使用">ubuntu下docker的使用</a><time datetime="2022-05-11T10:38:23.000Z" title="发表于 2022-05-11 18:38:23">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ca3a0e2a/" title="linux0.11环境搭建与阅读"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux0.11环境搭建与阅读"/></a><div class="content"><a class="title" href="/posts/ca3a0e2a/" title="linux0.11环境搭建与阅读">linux0.11环境搭建与阅读</a><time datetime="2022-05-11T01:08:09.000Z" title="发表于 2022-05-11 09:08:09">2022-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By lj gong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'cf6d7d2674b768ef1bf7',
      clientSecret: 'a8254412e77947a4ff26d08ce7af7b5853efbb44',
      repo: 'gonglja.github.io',
      owner: 'Gonglja',
      admin: ['Gonglja'],
      id: '927bcc1d0a6a057c311dda4e328110e5',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>