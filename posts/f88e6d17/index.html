<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>u-boot-2014.04 分析（未完待续） | Gong's Blog</title><meta name="author" content="lj gong"><meta name="copyright" content="lj gong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="u-boot-2014.04 分析​    由于要移植一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。 本文使用的版本是 u-boot-2022.04-rc4.tar.bz2 u-boot-2014.04（因作者能力不够，遂从2014.04开始） s5pv210芯片启动流程由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iRO">
<meta property="og:type" content="article">
<meta property="og:title" content="u-boot-2014.04 分析（未完待续）">
<meta property="og:url" content="http://gonglja.github.io/posts/f88e6d17/index.html">
<meta property="og:site_name" content="Gong&#39;s Blog">
<meta property="og:description" content="u-boot-2014.04 分析​    由于要移植一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。 本文使用的版本是 u-boot-2022.04-rc4.tar.bz2 u-boot-2014.04（因作者能力不够，遂从2014.04开始） s5pv210芯片启动流程由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iRO">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png">
<meta property="article:published_time" content="2022-03-29T01:33:08.000Z">
<meta property="article:modified_time" content="2022-04-13T12:24:35.337Z">
<meta property="article:author" content="lj gong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gonglja.github.io/posts/f88e6d17/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'u-boot-2014.04 分析（未完待续）',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-04-13 20:24:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111228921.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://gonglja.github.io/Notes"><i class="fa-fw fas fa-link"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Gong's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="https://gonglja.github.io/Notes"><i class="fa-fw fas fa-link"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">u-boot-2014.04 分析（未完待续）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-29T01:33:08.000Z" title="发表于 2022-03-29 09:33:08">2022-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-13T12:24:35.337Z" title="更新于 2022-04-13 20:24:35">2022-04-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>65分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="u-boot-2014.04 分析（未完待续）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="u-boot-2014-04-分析"><a href="#u-boot-2014-04-分析" class="headerlink" title="u-boot-2014.04 分析"></a>u-boot-2014.04 分析</h1><p>​    由于要移植一个 kernel 和 u-boot 到 smart210 平台，所以就有了该篇记录。</p>
<p>本文使用的版本是 <del><a href="ttps://ftp.denx.de/pub/u-boot/u-boot-2022.04-rc4.tar.bz2">u-boot-2022.04-rc4.tar.bz2</a></del> <a target="_blank" rel="noopener" href="https://github.com/Gonglja/u-boot-smart210">u-boot-2014.04</a>（因作者能力不够，遂从2014.04开始）</p>
<h2 id="s5pv210"><a href="#s5pv210" class="headerlink" title="s5pv210"></a>s5pv210</h2><h3 id="芯片启动流程"><a href="#芯片启动流程" class="headerlink" title="芯片启动流程"></a>芯片启动流程</h3><p>由三星官方手册可知，整个启动分为三阶段，BL0、BL1、BL2，其中BL0运行内部iROM中，BL1和BL2运行在SRAM中，但在实际项目中使用的比较通用的启动流程与官方流程有较大差异，为什么呢？因为编译的u-boot过大，超过最大80k限制。所以BL2在SDRAM中运行，而三星官方是放在内部SRAM中运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png"></p>
<h4 id="BL0"><a href="#BL0" class="headerlink" title="BL0"></a>BL0</h4><ul>
<li>运行在iROM上</li>
<li>代码固定在s5pv210的IROM中，无法修改。上电后直接从IROM中开始执行</li>
<li>主要工作<ul>
<li>初始化系统时钟、特殊设备控制器、启动设备、看门狗、SRAM等</li>
<li>验证BL1镜像</li>
<li>从存储介质上（比如SD/eMMC/nand flash）等加载BL1镜像到内部SRAM中</li>
<li>跳转到BL1镜像所在地址</li>
</ul>
</li>
</ul>
<h4 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h4><ul>
<li>运行在SRAM上</li>
<li>BL1代码在BL0段被加载到SRAM中</li>
<li>主要工作<ul>
<li>初始化部分时钟（SDRAM相关）</li>
<li>初始化DDR（外部SDRAM）</li>
<li>从存储介质上将BL2镜像加载到SDRAM中</li>
<li>验证BL2镜像合法性</li>
<li>跳转到BL2镜像所在的地址上</li>
</ul>
</li>
</ul>
<h4 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h4><ul>
<li>运行在SDRAM上</li>
<li>BL2代码在BL1段被加载到SDRAM中</li>
<li>BL2就是传统意义上的bootloader，主要负责加载OS和启动OS</li>
</ul>
<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082025672.png"></p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>0x0000_0000</strong></td>
<td><strong>0x1FFF_FFFF</strong></td>
<td><strong>512MB</strong></td>
<td><strong>Boot area（取决于启动模式）</strong></td>
</tr>
<tr>
<td><strong>0x2000_0000</strong></td>
<td><strong>0x3FFF_FFFF</strong></td>
<td><strong>512MB</strong></td>
<td><strong>DRAM 0</strong></td>
</tr>
<tr>
<td><strong>0x4000_0000</strong></td>
<td><strong>0x7FFF_FFFF</strong></td>
<td><strong>1024MB</strong></td>
<td><strong>DRAM 1</strong></td>
</tr>
<tr>
<td>0x8000_0000</td>
<td>0x87FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 0</td>
</tr>
<tr>
<td>0x8800_0000</td>
<td>0x8FFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 1</td>
</tr>
<tr>
<td>0x9000_0000</td>
<td>0x97FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 2</td>
</tr>
<tr>
<td>0x9800_0000</td>
<td>0x9FFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 3</td>
</tr>
<tr>
<td>0xA000_0000</td>
<td>0xA7FF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 4</td>
</tr>
<tr>
<td>0xA800_0000</td>
<td>0xAFFF_FFFF</td>
<td>128MB</td>
<td>SROM Bank 5</td>
</tr>
<tr>
<td>0xB000_0000</td>
<td>0xBFFF_FFFF</td>
<td>256MB</td>
<td>OneNAND/NAND Controller and SFR</td>
</tr>
<tr>
<td>0xC000_0000</td>
<td>0xCFFF_FFFF</td>
<td>256MB</td>
<td>MP3_SRAM output buffer</td>
</tr>
<tr>
<td><strong>0xD000_0000</strong></td>
<td><strong>0xD000_FFFF</strong></td>
<td><strong>64KB</strong></td>
<td><strong>IROM</strong></td>
</tr>
<tr>
<td>0xD001_0000</td>
<td>0xD001_FFFF</td>
<td>64KB</td>
<td>Reserved</td>
</tr>
<tr>
<td><strong>0xD002_0000</strong></td>
<td><strong>0xD003_7FFF</strong></td>
<td><strong>96KB</strong></td>
<td><strong>IRAM</strong></td>
</tr>
<tr>
<td>0xD800_0000</td>
<td>0xDFFF_FFFF</td>
<td>128MB</td>
<td>DMZ ROM</td>
</tr>
<tr>
<td>0xE000_0000</td>
<td>0xFFFF_FFFF</td>
<td>512MB</td>
<td>SFR region</td>
</tr>
</tbody></table>
<p>s5pv210芯片上电之后，CPU会直接从0x0地址取指令，也就是直接运行BL0。</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x0000_0000</td>
<td>0x0000_FFFF</td>
<td>64KB</td>
<td>Internal ROM</td>
</tr>
</tbody></table>
<p>BL1运行在IRAM中，IRAM空间如下</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0xD002_0000</td>
<td>0xD003_7FFF</td>
<td>96KB</td>
<td>IRAM</td>
</tr>
</tbody></table>
<p>但需注意：BL1运行在IRAM上，但并不意味着就从0xD002_0000开始。其实0xD002_0000开头的16B被用做BL1的header，BL1真正是从<strong>0xD002_0010</strong>开始运行的。前16字节被用来验证BL1镜像的完整性，其格式如下：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0xD002_0000</td>
<td>BL1镜像包括header的长度</td>
</tr>
<tr>
<td>0xD002_0004</td>
<td>保留，设置为0</td>
</tr>
<tr>
<td>0xD002_0008</td>
<td>BL1镜像除去header的校验和</td>
</tr>
<tr>
<td>0xD002_000c</td>
<td>保留，设置为0</td>
</tr>
</tbody></table>
<p>BL2运行地址在SDRAM中， smart210使用的是DRAM0，所以地址为</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>长度</th>
<th>映射区域描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x2000_0000</td>
<td>0x3FFF_FFFF</td>
<td>512MB</td>
<td>DRAM 0</td>
</tr>
</tbody></table>
<h2 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h2><p>由以上可知，上电后首先运行BL0阶段（BL0段代码起始地址为<code>0</code>）。</p>
<p>BL0 阶段运行的代码为IROM中自带的，其主要功能为 初始化系统时钟、特殊设备控制器、启动设备、看门狗、SRAM等，验证BL1镜像是否完整（<code>0xD002_0000</code>处存在长度和校验）然后跳转到BL1处（<code>0xD002_0010</code>）执行。</p>
<p>BL1 阶段运行在IRAM中，其主要功能是初始化部分时钟和DDR，拷贝BL2段代码到SDRAM中，验证BL2并跳转执行。</p>
<blockquote>
<p>那么，BL1段代码是怎么被拷贝到SRAM中的？</p>
<p>答：在BL0段将BL1的代码拷贝到SRAM中（参考<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code> 中 <code>2.2 iROM(BL0) boot-up sequence (Refer 2.3 V210 boot-up diagram)</code>），由于BL0三星不开源，所以我我们只能按照三星的要求存放BL1的位置（参考<code>S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</code> 中<code>2.8 Boot Block Assignment Guide</code>），如果从SD卡启动，也即从SD卡的第<code>1</code>个块开始；如果从NAND Flash启动，就放到Flash中的<code>0</code>块处。拷贝多少呢？这个不知道，有人说是<code>16k</code>也有人说是<code>8k</code>，尽可能将BL1的代码控制在<code>8K</code>以内。</p>
</blockquote>
<p>BL2 阶段运行在SDRAM中，就是传统意义上的bootloader，主要负责加载OS和启动OS</p>
<p>u-boot代码中有两部分：u-boot-spl、u-boot，其中u-boot-spl与芯片启动流程中的BL1对应、u-boot与BL2对应。</p>
<p>那么问题来了，u-boot-spl是如何生成的？u-boot又是怎么生成的?</p>
<p>spl的编译时编译uboot的一部分，和uboot.bin走的是两条编译流程。</p>
<p>一般来说，会先编译主体uboot，也就是uboot.bin，在编译uboot-spl，也就是uboot-spl.bin，两个流程。</p>
<p>编译成功后有几个文件名需要注意下，</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>u-boot-spl</td>
<td>初步链接后得到的spl文件</td>
</tr>
<tr>
<td>u-boot-spl-nodtb.bin</td>
<td>在u-boot-spl的基础上，经过objcopy去除符号表信息之后的可执行程序</td>
</tr>
<tr>
<td>u-boot-spl.bin</td>
<td>在不需要dtb的情况下，直接由u-boot-spl-nodtb.bin复制而来，也就是编译spl的最终目标</td>
</tr>
<tr>
<td>smart210-spl.bin</td>
<td>由s5pv210平台决定，需要在u-boot-spl.bin的基础上加上16B的header用作校验</td>
</tr>
<tr>
<td>u-boot-spl.lds</td>
<td>spl的连接脚本</td>
</tr>
<tr>
<td>u-boot-spl.map</td>
<td>连接之后的符号表文件</td>
</tr>
<tr>
<td>u-boot-spl.cfg</td>
<td>由spl配置生成的文件</td>
</tr>
</tbody></table>
<p><strong>框架</strong></p>
<blockquote>
<p>一般情况下，u-boot采用”board–&gt;machine–&gt;arch–&gt;cpu”框架，如图：</p>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201605/29bd3da4b061810a74093c33d3292b4320160519144243.gif"></p>
</blockquote>
<blockquote>
<p>基于这个架构，u-boot和平台有关的初始化流程就很清晰了。</p>
<ol>
<li>u-boot 启动后，会先执行CPU（如armv8）的初始化代码</li>
<li>CPU相关的代码， 会调用ARCH的公共代码（如arch/arm）</li>
<li>ARCH的公共代码，在适当的时候，调用board有关的接口。u-boot的功能逻辑，大多是由common代码实现，部分和平台有关的部分，则由公共代码声明，由board代码实现。</li>
<li>board代码在需要的时候，会调用machine(arch/arm/mach-xxx)提供的接口，实现特定的功能。因此machine的定位是提供一些基础的代码支持，不会直接参与到u-boot的逻辑功能中去。</li>
</ol>
</blockquote>
<p>由此可知，当u-boot上电后，首先执行的是CPU的初始化代码。板卡型号为smart210，CPU型号为s5pv210，armv7指令集。</p>
<p>通过 <code>u-boot-spl.lds</code>（<code>arch/arm/cpu/u-boot-spl.lds</code>） 和 <code>u-boot.lds</code>（arch/arm/cpu/u-boot.lds） 中 <code>ENTRY(_start)</code>可知，不管是u-boot-spl还是u-boot都是从<code>_start</code>开始的。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先解决编译问题，其次是分析代码，在分析代码的过程中遇到不会的指令和寄存器及时记录下来，防止下次还是不会。</p>
<h3 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h3><h4 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h4><p>/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</p>
<p>dirname: missing operand</p>
<p>具体如下</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">glj0@glj0-ubuntu21:~/worksapce/os/smart210/u-boot-2014.04$ ./make.sh </span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">Configuring <span class="keyword">for</span> smart210 board...</span><br><span class="line">make: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: No such file or directory</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">dirname: missing operand</span><br><span class="line">Try <span class="string">'dirname --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">  GEN     include/autoconf.mk.dep</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">  GEN     include/autoconf.mk</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">  CHK     include/config/uboot.release</span><br><span class="line">  CHK     include/generated/timestamp_autogenerated.h</span><br><span class="line">  UPD     include/generated/timestamp_autogenerated.h</span><br><span class="line">  UPD     include/config/uboot.release</span><br><span class="line">  HOSTCC  scripts/basic/fixdep</span><br><span class="line">  CHK     include/generated/version_autogenerated.h</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-ld: not found</span><br><span class="line">  UPD     include/generated/version_autogenerated.h</span><br><span class="line">  CC      lib/asm-offsets.s</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">make[1]: *** [/home/glj0/worksapce/os/smart210/u-boot-2014.04/./Kbuild:35: lib/asm-offsets.s] Error 127</span><br><span class="line">make[1]: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>....</span><br><span class="line">  CC      arch/arm/lib/asm-offsets.s</span><br><span class="line">/bin/sh: 1: /opt/FriendlyARM/toolschain/4.5.1/bin/arm-none-linux-gnueabi-gcc: not found</span><br><span class="line">make[1]: *** [/home/glj0/worksapce/os/smart210/u-boot-2014.04/./Kbuild:84: arch/arm/lib/asm-offsets.s] Error 127</span><br><span class="line">make: *** [Makefile:999: prepare0] Error 2</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>缺少32位库，安装就可以了。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgl1-mesa-dri:i386</span><br></pre></td></tr></tbody></table></figure>



<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><strong>TODO：待补充</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>寄存器</th>
<th>APCS(ARM 过程调用标准)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>通用寄存器/不分组寄存器</td>
<td>r0</td>
<td>a1</td>
<td>用作传入函数参数，传出函数返回值。在子程序调用之间，可以将r0-r3用于任何用途</td>
</tr>
<tr>
<td></td>
<td>r1</td>
<td>a2</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r2</td>
<td>a3</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r3</td>
<td>a4</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r4</td>
<td>v1</td>
<td><strong>存放函数的局部变量</strong>如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值</td>
</tr>
<tr>
<td></td>
<td>r5</td>
<td>v2</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r6</td>
<td>v3</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r7</td>
<td>v4</td>
<td>同上</td>
</tr>
<tr>
<td>通用寄存器/分组寄存器</td>
<td>r8</td>
<td>v5</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r9</td>
<td>v6</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r10</td>
<td>sl (stack limit)</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r11</td>
<td>fp ()</td>
<td>同上</td>
</tr>
<tr>
<td></td>
<td>r12</td>
<td>ip (intra-prpcedure-call scratch regiser)</td>
<td>内部调用暂时寄存器。</td>
</tr>
<tr>
<td></td>
<td>r13</td>
<td>sp (stack pointer)</td>
<td>栈指针sp，存放的值在退出被调用函数时必须与进入时的值相同。</td>
</tr>
<tr>
<td></td>
<td>r14</td>
<td>lr (link register)</td>
<td>通常被用作子程序链接寄存器，也称lr,指向函数的返回地址。</td>
</tr>
<tr>
<td>通用寄存器/程序计数器</td>
<td>r15</td>
<td>pc (program counter)</td>
<td>程序计数器，保留下一条CPU即将执行的指令。不能用于其它用途。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>程序状态字寄存器</td>
<td>cpsr</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>spsr</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><strong>TODO：待补充</strong></p>
<p>条件码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131656507.png"></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>指令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>条件（有符号数）</td>
<td>GE</td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LE</td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>GT</td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LT</td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td>条件（用于无符号数）</td>
<td>HS</td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LS</td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>HI</td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LO</td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>STR{条件} 源寄存器，&lt;存储器地址&gt;</td>
<td>从源寄存器中将一个32位的字数据传送到存储器中</td>
<td><code>STR r1, [r0]</code>将r1里面值复制到以r0里面的值作为地址的内存中</td>
</tr>
<tr>
<td></td>
<td>STRLO 源寄存器，&lt;存储器地址&gt;</td>
<td>当满足条件小于时，从源寄存器中将一个32位的字数据传送到存储器中</td>
<td><code>CMP r0，r1;STRLO r2，[r0];</code> 首先r0=r0-r1,当满足条件r0&lt;r1时，将r2中的值复制到以r0里面的值作为地址的内存中。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>地址读取伪指令</td>
<td>ADR{条件}目的寄存器，相对地址或标签</td>
<td>将基于PC相对偏移的地址值或基于寄存器相对地址值传送到目的寄存器中（小范围）</td>
<td><code>ADR r0, here;here: ....</code>将标签here处的相对地址传递给寄存器r0</td>
</tr>
<tr>
<td></td>
<td>LDR{条件}目的寄存器，&lt;存储器地址&gt;</td>
<td>从存储器中将一个32位的字数据传送到目的寄存器中（大范围）</td>
<td><code>LDR r0, [r1]</code>将r1里面的值作为地址，将地址里面的值复制给寄存器r0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>跳转指令</td>
<td>B{条件} 目标地址</td>
<td>跳转指令</td>
<td><code>B Label</code>程序无条件跳转到标号Label处执行</td>
</tr>
<tr>
<td></td>
<td>BL{条件} 目标地址</td>
<td>带返回的跳转指令（跳转之前，将PC内容存到R14中）</td>
<td><code>BL Label</code>程序将当前PC值存到R14中，程序无条件跳转至标号Label中执行</td>
</tr>
<tr>
<td></td>
<td>BLX</td>
<td>带返回和状态切换的跳转指令</td>
<td></td>
</tr>
<tr>
<td></td>
<td>BX</td>
<td>带状态切换的跳转指令</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>算术运算指令</td>
<td>SUB 寄存器1，寄存器2，寄存器3</td>
<td>寄存器1=寄存器2-寄存器3</td>
<td><code>SUB r0，r1,#1</code> r0=r1-1</td>
</tr>
<tr>
<td></td>
<td>SUBS 寄存器1，寄存器2，寄存器3</td>
<td>寄存器1=寄存器2-寄存器3;S表示并将进位结果写到CPSR中</td>
<td><code>SUBS r0，r1,#1</code> r0=r1-1，并将进位结果写道CPSR</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>CMP 寄存器1，寄存器2</td>
<td>寄存器1=寄存器1-寄存器2</td>
<td><code>CMP r0，r1</code> 也就是<code>r0=r0-r1</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>多数据传输条件</td>
<td>IA（Increase After）</td>
<td>每次传送后地址加4,其中的寄存器<strong>从左到右执行</strong>,例如:STMIA R0,{R1,LR} 先存R1,再存LR</td>
<td></td>
</tr>
<tr>
<td></td>
<td>IB（Increase Before）</td>
<td>每次传送前地址加4,同上</td>
<td></td>
</tr>
<tr>
<td></td>
<td>DA（Decrease After）</td>
<td>每次传送后地址减4,其中的寄存器<strong>从右到左执行</strong>,例如:STMDA R0,{R1,LR} 先存LR,再存R1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>DB（Decrease Before）</td>
<td>每次传送前地址减4,同上</td>
<td></td>
</tr>
<tr>
<td></td>
<td>FD</td>
<td>满递减堆栈 (每次传送前地址减4)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>FA</td>
<td>满递增堆栈 (每次传送后地址减4)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ED</td>
<td>空递减堆栈 (每次传送前地址加4)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>EA</td>
<td>空递增堆栈 (每次传送后地址加4)</td>
<td></td>
</tr>
<tr>
<td>多数据传输（加载）</td>
<td>LDM{cond} Rn{!},reglist{^}</td>
<td>多数据加载，将地址上的值加载到寄存器中。Rn：基址寄存器，装有传送数据的起始地址，Rn不允许为R15；！：表示最后的地址写回到Rn中；reglist：可包含多于一个寄存器范围，用“，”隔开，如{R1，R2，R6-R9}，寄存器由小到大顺序排列；^：不允许在用户模式和系统模式下运行</td>
<td><code>LDR R0,=0x100000;LDMIA R0!,{R1-R8}</code>也就是从左往右加载，首先将0x100000中的数据加载到R1,然后R0=R0+4，然后将0x1000004中的数据加载到R2,然后R0=R0+4….</td>
</tr>
<tr>
<td>多数据传输（存储）</td>
<td>STM{cond} mode Rn{!}, reglist{^}</td>
<td>多数据存储，将寄存器的值存到地址上。同上</td>
<td></td>
</tr>
<tr>
<td></td>
<td>.globl</td>
<td>伪指令，声明一个全局变量</td>
<td><code>.globl _start</code>声明_start，下面调用时才不会出现链接错误。类似c语言中的extern。</td>
</tr>
</tbody></table>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="2022中的-start不看"><a href="#2022中的-start不看" class="headerlink" title="2022中的_start不看"></a><strong><del>2022中的_start不看</del></strong></h4><p><del>所以首先会执行armv7中的start.S代码，但是呢，通过代码，我们没有发现start.S中有 <code>_start</code>相关的定义，而且也没有一些向量表的处理，这就很奇怪了，代码放哪呢了呢？没有<code>_start</code>又要怎么启动呢？带着问题，我们接着往下走。</del></p>
<p>由于我们的代码是最新的，但有印象在2014版本中是有这一部分的，所以我们直接去查找git上这个文件的history</p>
<p>于是有了找到了以下</p>
<p><a target="_blank" rel="noopener" href="https://source.denx.de/u-boot/u-boot/-/commit/41623c91b09a0c865fab41acdaff30f060f29ad6">https://source.denx.de/u-boot/u-boot/-/commit/41623c91b09a0c865fab41acdaff30f060f29ad6</a></p>
<p>在这个链接右上角可以看到，删除了2426行，新增了313行。看了下发现删除的都是 下面这种代码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start: b    reset </span><br><span class="line">...</span><br><span class="line">	.balignl 16,0xdeadbeef</span><br></pre></td></tr></tbody></table></figure>

<p>那这些代码去哪了呢？</p>
<p>接着搜索armv7，发现也是这种代码被删除。</p>
<p>接着走，看看新增了什么，在u-boot-spl.lds和u-boot.lds中 代码中新增了一个 *(vectors)并且位置比start.o靠前，什么意思？中断向量表存到这个地方了嘛？是的，接着往下看，一切都会真相大白</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203291016583.png"></p>
<p>终于看到vector.S了，这部分代码是存在 arch/arm/lib下，有没有发现很熟悉，没错，就是上面删掉的代码，而且 <code>.global _start</code>也在这，由此可以猜测，<strong>开发人员将各个处理器的公共代码抽离，最终以vector.S体现</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202203291030263.png"></p>
<p>借助 u-boot.lds（arch/arm/cpu/u-boot.lds）可知，<code>ENTRY(_start)</code>，整个u-boot的开始依然是<code>_start</code>，由以上分析可知，<code>_start</code>在vectors.S中定义，所以整个U-boot的入口为vector.S中的<code>_start</code>，接着 ARM_VECTORS 是一个宏，展开就是 <code>.macro/.endm</code>之间包裹的。接着往下走，就会走入<code>b reset</code>，调用reset。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* arch/arm/lib/vectors.S */</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">	.section ".vectors", "ax"</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)</span><br><span class="line">#include &lt;asm/arch/boot0.h&gt;</span><br><span class="line">#else   /*走这个分支 (怎么确认的呢？在此处随便加个乱七八糟的字符，然后编译，如果编译过，则说明走的不是此分支)*/</span><br><span class="line">_start: /*U-boot程序入口*/</span><br><span class="line">#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">	.word	CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">#endif</span><br><span class="line">	ARM_VECTORS /* 一个宏*/</span><br><span class="line">#endif /* !defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) */</span><br><span class="line">	/* 在.macro 和 .endm 中的为*/</span><br><span class="line">    .macro ARM_VECTORS</span><br><span class="line">#ifdef CONFIG_ARCH_K3</span><br><span class="line">	ldr     pc, _reset</span><br><span class="line">#else</span><br><span class="line">	b	reset	// 走这个分支</span><br><span class="line">#endif</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br><span class="line">	.endm</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>reset标签在哪呢？<code>arch/arm/cpu/armv7/start.S</code>中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* arch/arm/cpu/armv7/start.S */</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	/* Allow the board to save important registers */</span><br><span class="line">	b	save_boot_params</span><br><span class="line">save_boot_params_ret:</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,</span><br><span class="line"> * except if in HYP mode already</span><br><span class="line"> * 禁用中断，同时设置CPU模式，除非已经处于HYP模式下</span><br><span class="line"> */</span><br><span class="line">    mrs		r0, cpsr			;读取寄存器cpsr中的值，并保存到r0寄存器中。</span><br><span class="line">    and		r1, r0, #0x1f		@ mask mode bits</span><br><span class="line">    teq		r1, 	#0x1a		@ test for HYP mode</span><br><span class="line">    bicne	r0, r0, #0x1f		@ clear all mode bits</span><br><span class="line">    orrne	r0, r0, #0x13		@ set SVC mode</span><br><span class="line">    orr		r0, r0, #0xc0		@ disable FIQ and IRQ</span><br><span class="line">    msr		cpsr,r0</span><br><span class="line"></span><br><span class="line">ENTRY(save_boot_params)</span><br><span class="line">	b	save_boot_params_ret		@ back to my caller</span><br><span class="line">ENDPROC(save_boot_params)</span><br></pre></td></tr></tbody></table></figure>

<p><code>mrs        r0, cpsr</code> ;读取寄存器cpsr中的值，并保存到r0寄存器中。</p>
<p><code>and        r1, r0, #0x1f</code>寄存器r0中的值与0X1F进行与运算，结果保存到r1寄存器中，目的就是提取cpsr的bit0~bit4这5位，这5位为M4 M3 M2 M1 M0，M[4:0]这五位用来设置处理器的工作模式</p>
<p>以上为 u-boot-2022.04中的内容</p>
<hr>
<h4 id="start"><a href="#start" class="headerlink" title="_start"></a>_start</h4><p>由于我们的处理器使用的指令集为armv7，所以**_start**的路径为<code>arch/arm/cpu/armv7/start.S</code></p>
<p>其实对于u-boot的<code>start.S</code>，主要做的几件事就是系统各方面的初始化。</p>
<p>从大的方面分，可分为以下部分</p>
<ul>
<li><p>设置 CPU 模式</p>
</li>
<li><p>关闭看门狗</p>
</li>
<li><p>关闭中断</p>
</li>
<li><p>设置堆栈 sp 指针</p>
</li>
<li><p>清除 bss 段</p>
</li>
<li><p>异常中断处理</p>
</li>
</ul>
<p>接着我们看代码，</p>
<p><code>.globl _start</code> 声明<code>_start</code>标号对全局可见，类似于c语言中的<code>extern</code></p>
<p><code>_start: b    reset</code> <code>_start</code>后加一个冒号，表示其实一个Label。而同时<code>_start</code>的值，也就是代码的最开始的位置，相对是<code>0</code>。在u-boot-spl中其地址是<code>0</code>，在u-boot中，由于经过了relocate之后，代码的运行地址是我们定义的基地址（TODO：找到基地址的定义）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">reset:</span><br><span class="line">        bl	save_boot_params       //跳转到save_boot_params符号处</span><br><span class="line">	/*</span><br><span class="line">	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,</span><br><span class="line">	 * except if in HYP mode already</span><br><span class="line">	 */</span><br><span class="line">        mrs		r0, cpsr			//将cpsr寄存器的值读到r0中</span><br><span class="line">        and		r1, r0, #0x1f		 @ mask mode bits</span><br><span class="line">        teq		 r1,      #0x1a		    @ test for HYP mode</span><br><span class="line">        bicne	 r0, r0, #0x1f		   @ clear all mode bits  </span><br><span class="line">        orrne	 r0, r0, #0x13		  @ set SVC mode 			//更改处理器模式为SVC模式</span><br><span class="line">        orr		 r0, r0, #0xc0		  @ disable FIQ and IRQ	//将I、F位（7、6位）置1 也即0xc0，关闭快中断和中断</span><br><span class="line">        msr	cpsr,r0				      //将r0的内容写入cpsr寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY(save_boot_params)</span><br><span class="line">	bx	lr			@ back to my caller</span><br><span class="line">ENDPROC(save_boot_params)</span><br><span class="line">	.weak	save_boot_params</span><br></pre></td></tr></tbody></table></figure>

<p>这一段，首先会跳转到 <strong>save_boot_params</strong> 标号处，而 <code>ENTRY(save_boot_params)</code> 表示 <code>save_boot_params</code> 入口，进入后就一句 <code>bx lr</code>，其作用为 跳转到 <code>lr</code> 中存放的地址处。而<code>lr</code>的用途：当通过BL或者BLX调用<strong>子程序</strong>时，硬件将自动将子程序返回地址保存在R14寄存器中，在子程序返回时，把LR的值复制到程序计数器就可以实现子程序返回。所以这段代码的意思就是跳转到调用者处。也就是接着执行 bl save_boot_params 后面的代码。</p>
<p><code>mrs    r0, cpsr</code>读取寄存器cpsr中的值，并保存到r0寄存器中。</p>
<p><code>and    r1, r0, #0x1f</code>寄存器r0中的值与0X1F进行与运算，结果保存到r1寄存器中，目的就是提取cpsr的bit0~bit4这5位，这5位为M4 M3 M2 M1 M0，M[4:0]这五位用来设置处理器的工作模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101725592.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101726017.png"></p>
<p>如果<code>r1</code>和<code>0X1A(0b11010)</code>不相等，也就是CPU不处于Hyp模式的话就将<code>r0</code>寄存器的bit0~5进行清零，其实就是清除模式位。</p>
<p>如果处理器不处于Hyp模式的话就将r0的寄存器的值与<code>0x13</code>进行或运算，<code>0x13(0b10011)</code>，也就是设置处理器进入SVC模式。</p>
<p><code>r0</code>寄存器的值再与<code>0xC0(0b1100_0000)</code>进行或运算，那么r0寄存器此时的值就是<code>0xD3(0b1101_0000)</code>，cpsr的I位和F位分别控制IRQ和FIQ这两个中断的开关，设置为1就关闭了FIQ和IRQ！</p>
<p>将<code>r0</code>寄存器写回到<code>cpsr</code>寄存器中。完成设置CPU处于SVC32模式，并且关闭FIQ和IRQ这两个中断。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">/*</span><br><span class="line"> * Setup vector:</span><br><span class="line"> * (OMAP4 spl TEXT_BASE is not 32 byte aligned.</span><br><span class="line"> * Continue to use ROM code vector only in OMAP4 spl)</span><br><span class="line"> */</span><br><span class="line">#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))</span><br><span class="line">	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register</span><br><span class="line">	bic	r0, #CR_V		@ V = 0</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register</span><br><span class="line"></span><br><span class="line">	/* Set vector address in CP15 VBAR register */</span><br><span class="line">	ldr	r0, =_start</span><br><span class="line">	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p>这部分代码通过对协处理器CP15进行操作，设置了处理器的异常向量入口地址为<code>_start</code>。</p>
<p>这是因为ARM默认的异常向量表入口在0x0地址，然而S5PV210中0x0地址存放的是IROM，不可修改，自然不可能存放异常向量表，所以需要修改异常向量表入口，将它们映射到其他位置上去。</p>
<p>接着是三个跳转，每个跳转后都会返回到当前位置的下一条地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">	/* the mask ROM code should have PLL and others stable */</span><br><span class="line">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span><br><span class="line">	bl	cpu_init_cp15</span><br><span class="line">	bl	cpu_init_crit</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	bl	_main</span><br></pre></td></tr></tbody></table></figure>



<h4 id="cpu-init-cp15"><a href="#cpu-init-cp15" class="headerlink" title="cpu_init_cp15"></a>cpu_init_cp15</h4><p>首先跳转到 <strong>cpu_init_cp15</strong> 中，我们可以看到在<code>ENDPROC(cpu_init_cp15)</code>之前，有一条 <code>mov pc, lr</code>，此命令作用和<code>bx lr</code>相同，跳转回子函数调用的地方。在 <code>cpu_init_cp15</code> 中，主要是失效  L1 I/D、关闭 MMU 等</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(cpu_init_cp15)</span><br><span class="line">	...</span><br><span class="line">	mov	pc, lr			@ back to my caller //子过程运行结束，跳转回去</span><br><span class="line">ENDPROC(cpu_init_cp15)</span><br></pre></td></tr></tbody></table></figure>



<h4 id="cpu-init-crit"><a href="#cpu-init-crit" class="headerlink" title="cpu_init_crit"></a>cpu_init_crit</h4><p>接着跳转到 <strong>cpu_init_crit</strong> 中，里面又一个跳转 <code>lowlevel_init</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(cpu_init_crit)</span><br><span class="line">	b	lowlevel_init		@ go setup pll,mux,memory</span><br><span class="line">ENDPROC(cpu_init_crit)</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h4 id="lowlevel-init-分析错误"><a href="#lowlevel-init-分析错误" class="headerlink" title="lowlevel_init(分析错误)"></a><del>lowlevel_init(分析错误)</del></h4><p><strong>注意：以下分析错误，请直接看下一个 lowlevel_init</strong> </p>
<p><del><strong>lowlevel_init</strong> 位于 <code>arch/arm/cpu/armv7/lowlevel_init.S</code></del>，主要是设置栈顶指针为 CONFIG_SYS_INIT_SP_ADDR ，然后栈顶指针8字节对齐。如果在SPL，设置r9数据为 gdata 地址，否则为GD数据分配空间，并将分配后的栈顶指针给r9。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(lowlevel_init)</span><br><span class="line">	/*</span><br><span class="line">	 * Setup a temporary stack</span><br><span class="line">	 */</span><br><span class="line">	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR</span><br><span class="line">	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */</span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">	ldr	r9, =gdata</span><br><span class="line">#else</span><br><span class="line">	sub	sp, sp, #GD_SIZE</span><br><span class="line">	bic	sp, sp, #7</span><br><span class="line">	mov	r9, sp</span><br><span class="line">#endif</span><br><span class="line">	/*</span><br><span class="line">	 * Save the old lr(passed in ip) and the current lr to stack</span><br><span class="line">	 */</span><br><span class="line">	push	{ip, lr}</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * go setup pll, mux, memory</span><br><span class="line">	 */</span><br><span class="line">	bl	s_init</span><br><span class="line">	pop	{ip, pc}</span><br><span class="line">ENDPROC(lowlevel_init)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>CONFIG_SYS_INIT_SP_ADDR</strong> 在 <code>include/configs/smart210.h</code>，也就是说设置栈顶指针为SDRAM结束的高地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR + PHYS_SDRAM_1_SIZE)</span><br><span class="line">...</span><br><span class="line">#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE</span><br><span class="line">...</span><br><span class="line">/* DRAM Base */</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br><span class="line">...</span><br><span class="line">#define PHYS_SDRAM_1_SIZE	(512 &lt;&lt; 20)				/* 0x2000_0000, 512 MB Bank #1 */</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101814781.png"></p>
<p>其中 gddata 定义在 <code>arch/arm/lib/spl.c</code>中，这里需要补充一个高级用法。具体用法查看 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html</a> ，这里则是将 gdata 位置存放到 .data 段中。</p>
<blockquote>
<p>_<em>attribute</em>_</p>
<p>该关键字允许您指定变量、函数参数或结构体、联合体以及类成员的特殊属性</p>
<p>而 _<em>attribute</em>_ ((section(“.data”))) </p>
<p>则说明将 前者定义的放入<code>.data</code>段中</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pointer to as well as the global data structure for SPL */</span></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"><span class="keyword">gd_t</span> gdata __attribute__ ((section(<span class="string">".data"</span>)));</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 在 arch/arm/include/asm/global_data.h 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm (<span class="meta-string">"r9"</span>)</span></span><br></pre></td></tr></tbody></table></figure>

<p>此时需要注意下 DECLARE_GLOBAL_DATA_PTR 这个宏，这个宏的意思是定义了全局数据结构gd（<strong>寄存器r9来表示全局数据结构gd</strong>）</p>
<p><code>register volatile gd_t *gd asm ("r9")</code> 其中register关键字是必须的，asm (“r9”)为嵌入式汇编，表示用r9寄存器存储gd指针，r9和CPU体系结构相关。寄存器变量。</p>
<p>所以不管 <code>ldr    r9, =gdata</code>还是<code>mov    r9, sp</code>都是更新 gd 的地址，不同的是在SPL下，gd结构体空间被分配在 <code>.data</code>段中，在u-boot中，gd结构体空间被分配在<code>CONFIG_SYS_INIT_SP_ADDR - GD_SIZE</code> （需要8字节对齐）处。</p>
<p>接着往下走，<code>push    {ip, lr}</code>用stack的形式保存<code>lr</code>(返回指针)，将ip和lr入栈</p>
<p>然后一个跳转到<code>bl    s_init</code>中。</p>
<p>下面 <code>pop    {ip, pc}</code> 恢复到<code>ip</code>、<code>pc</code>，意思是改变pc的指向，将lr内容恢复到pc中，也即返回到lr指向的地方，在此处应为<code>bl    cpu_init_crit</code>的下方，也即<code>bl    _main</code>。</p>
<p>接着分析 <code>s_init</code>，在与smart210相关的任何地方找不到与s_init相关的定义，也找不到与s5pv210任何相关的，所以此处应该是有问题的，通过在指令间添加一些异常数据，编译，编译通过，得知在调用 lowlevel_init时并不是找的此处。</p>
<p><strong>以上分析错误，请直接查看下一个 lowlevel_init</strong> </p>
<hr>
<h4 id="lowlevel-init"><a href="#lowlevel-init" class="headerlink" title="lowlevel_init"></a>lowlevel_init</h4><p><strong>lowlevel_init</strong> 位于 <code>board/samsung/smart210/lowlevel_init.S</code> ，这个相对简单，但还是说一下，首先将<code>lr</code>返回地址保存到<code>r9</code>中（此处不应该使用r9，或者说在使用r9前先保存r9的值），如果在SPL下，则需要初始化时钟和ddr，并配置串口寄存器<code>PA0CON</code>值为<code>0x22222222</code>（查看手册 <code>S5PV210_UM_REV1.1.pdf</code>中<code>2.2.2.1 Port Group GPA0 Control Register (GPA0CON, R/W, Address = 0xE020_0000)</code> ），也即配置<code>GPA0CON</code>功能为串口UART1。之后，恢复<code>pc</code>值为<code>lr</code>，返回到调用 <code>lowlevel_init</code> 的地方。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; board/samsung/smart210/lowlevel_init.S</span><br><span class="line"></span><br><span class="line">        .globl lowlevel_init</span><br><span class="line">lowlevel_init:</span><br><span class="line">	mov	r9, lr</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">	bl clock_init                   /* clock init */</span><br><span class="line">	bl ddr_init                     /* DDR init */</span><br><span class="line"></span><br><span class="line">	/* add by Flinn, for uart */</span><br><span class="line">	ldr r0, =0xE0200000     		/* GPA0_CON */</span><br><span class="line">	ldr r1, =0x22222222</span><br><span class="line">	str r1, [r0]</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">	mov pc, r9                		/* return */</span><br></pre></td></tr></tbody></table></figure>



<p>返回到<code>bl cpu_init_crit</code>的下一句指令，也即执行 <code>bl _main</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line"></span><br><span class="line">	/* the mask ROM code should have PLL and others stable */</span><br><span class="line">#ifndef CONFIG_SKIP_LOWLEVEL_INIT</span><br><span class="line">	bl	cpu_init_cp15</span><br><span class="line">	bl	cpu_init_crit</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	bl	_main</span><br></pre></td></tr></tbody></table></figure>



<h4 id="main"><a href="#main" class="headerlink" title="_main"></a>_main</h4><p><strong>_main</strong>位于<code>arch/arm/lib/crt0.S</code>中，具体代码一会回来分析。</p>
<p>终于来到<code>_main</code>中了，首先如果定义了<code>CONFIG_SPL_BUILD</code>和<code>CONFIG_SPL_STACK</code>，也即SPL时，sp值为<code>CONFIG_SPL_STACK</code>，但经过验证没有走这个分支；所以sp的值只可能为<code>CONFIG_SYS_INIT_SP_ADDR</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">/*</span><br><span class="line"> * entry point of crt0 sequence</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">ENTRY(_main)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set up initial C runtime environment and call board_init_f(0).</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">	ldr	sp, =(CONFIG_SPL_STACK)</span><br><span class="line">#else</span><br><span class="line">	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line">#endif</span><br><span class="line">	...</span><br><span class="line">ENDPROC(_main)</span><br></pre></td></tr></tbody></table></figure>



<p><strong>CONFIG_SYS_INIT_SP_ADDR</strong> 在 <code>include/configs/smart210.h</code>，也就是说设置栈顶指针为SDRAM结束的高地址处。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* include/configs/smart210.h */</span><br><span class="line">#define CONFIG_SYS_INIT_SP_ADDR		   (CONFIG_SYS_LOAD_ADDR + PHYS_SDRAM_1_SIZE)</span><br><span class="line">...</span><br><span class="line">#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE</span><br><span class="line">...</span><br><span class="line">/* DRAM Base */</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br><span class="line">...</span><br><span class="line">#define PHYS_SDRAM_1_SIZE			 (512 &lt;&lt; 20)				/* 0x2000_0000, 512 MB Bank #1 */</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204101814781.png"></p>
<p>接着往下走，是给<code>gd</code>数据结构分配空间。gd是什么？</p>
<blockquote>
<p>gd是一个寄存器变量。此时需要注意下 DECLARE_GLOBAL_DATA_PTR 这个宏，这个宏的意思是定义了全局数据结构gd（<strong>寄存器r9来表示全局数据结构gd</strong>）</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// board/samsung/smart210/smart210.c</span></span><br><span class="line">&gt;DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line">&gt;---------------------------------------------------------------------------------------</span><br><span class="line">&gt;<span class="comment">// arch/arm/include/asm/global_data.h </span></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm (<span class="meta-string">"r9"</span>)</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>register volatile gd_t *gd asm ("r9")</code> 其中<code>register</code>关键字是必须的，<code>asm ("r9")</code>为嵌入式汇编，表示用<code>r9</code>寄存器存储<code>gd</code>指针，<code>r9</code>和CPU体系结构相关。</p>
</blockquote>
<p>先8字节对齐，然后给<code>gd</code>结构分配大小为<code>GD_SIZE</code>的空间，然后继续8字节对齐。<code>GD_SIZE</code>是一个宏，在<code>include/generated/generic-asm-offsets.h</code>中定义为<code>160</code>（<code>sizeof(struct global_data)</code>），该文件也是生成的。</p>
<p>更新<code>r9</code>值为<code>sp</code>，此时<code>r9 = sp = [CONFIG_SYS_INIT_SP_ADDR - GD_SIZE]</code>（<code>[CONFIG_SYS_INIT_SP_ADDR - GD_SIZE]</code>为对应地址处的值），接着给<code>r0</code>清零</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	bic	sp, sp, #7			/* 8-byte alignment for ABI compliance */</span><br><span class="line">	sub	sp, sp, #GD_SIZE	/* allocate one GD above SP */</span><br><span class="line">	bic	sp, sp, #7			/* 8-byte alignment for ABI compliance */</span><br><span class="line">	mov	r9, sp				/* GD is above SP */</span><br><span class="line">	mov	r0, #0</span><br></pre></td></tr></tbody></table></figure>



<p>接着往下走，分为两种情况，第一种SPL下，跳转到 <code>copy_bl2_to_ram</code>（完成BL2阶段镜像校验并拷贝到SDRAM中），执行结束后返回，更改PC指针为<code>CONFIG_SYS_SDRAM_BASE</code>，也即跳转到 BL2阶段（SDRAM中）。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">        bl       copy_bl2_to_ram</span><br><span class="line">        ldr pc,=CONFIG_SYS_SDRAM_BASE</span><br><span class="line">#else</span><br><span class="line">        bl       board_init_f</span><br><span class="line">#endif</span><br><span class="line">-----------------------------------------------</span><br><span class="line">; include/configs/smart210.h</span><br><span class="line">#define CONFIG_SYS_SDRAM_BASE		0x20000000</span><br></pre></td></tr></tbody></table></figure>



<h4 id="copy-bl2-to-ram"><a href="#copy-bl2-to-ram" class="headerlink" title="copy_bl2_to_ram"></a>copy_bl2_to_ram</h4><p><code>copy_bl2_to_ram</code>函数在 <code>board/samsung/smart210/smart210.c</code> 中</p>
<p>首先是几个宏定义，让我们看一下是什么东东？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从SD/MMC拷贝（加载）块到内存中的函数 </span></span><br><span class="line"><span class="comment">** ch:  通道号</span></span><br><span class="line"><span class="comment">** sb:  起始块号</span></span><br><span class="line"><span class="comment">** bs:  块数量</span></span><br><span class="line"><span class="comment">** dst: 要拷贝到内存的什么位置上</span></span><br><span class="line"><span class="comment">** i:   是否需要初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CopySDMMCtoMem(ch, sb, bs, dst, i) \</span></span><br><span class="line"><span class="meta">        (((u8(*)(int, u32, unsigned short, u32*, u8))\</span></span><br><span class="line"><span class="meta">        (*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_1CON  (*(volatile u32 *)0xE02002E0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_3CON  (*(volatile u32 *)0xE0200320)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_6CON  (*(volatile u32 *)0xE0200380) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF8_ReadPage_Adv(a,b,c) (((int(*)(u32, u32, u8*))(*((u32 *)0xD0037F90)))(a,b,c))</span></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CopySDMMCtoMem(ch, sb, bs, dst, i) \</span></span><br><span class="line"><span class="meta">(((u8(*)(int, u32, unsigned short, u32*, u8))(*((u32 *)0xD0037F98)))(ch, sb, bs, dst, i))   </span></span><br></pre></td></tr></tbody></table></figure>

<p>这个宏定义分为三段来看，分别对应着 <strong>函数返回值数据类型 （*指针变量名）（函数的实际参数或者函数参数的类型）</strong><br>第一段：<code>((u8 (*)(int, u32, unsigned short, u32*, u8))</code> 是一个函数类型强制类型转换，其中<code>u8</code>为返回值，<code>(int, u32, unsigned short, u32*, u8)</code>为传入参数类型。<br>第二段：<code>(*((u32 *)0xD0037F98)))</code> ，在地址<code>0xD0037F98</code>中存放了一个名字叫<code>CopySDMMCtoMem</code>的函数，armv7 为32位cpu，所以先转成<strong>指针类型为u32*<strong>，然后再把这个地址</strong>解引用</strong>，就得到了地址中存在的值也就是CopySDMMCtoMem</p>
<p>第三段：将函数的实际参数传入即可<code>(ch, sb, bs, dst, i)</code>，最外层加上一个大括号。</p>
<p>接着三个宏表示 将对<strong>对应地址处的值</strong>操作。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_1CON  (*(volatile u32 *)0xE02002E0) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.25.1*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_3CON  (*(volatile u32 *)0xE0200320) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.27.1*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP0_6CON  (*(volatile u32 *)0xE0200380) <span class="comment">/* 查看手册S5PV210_UM_REV1.1.pdf中 2.2.30.1*/</span></span></span><br></pre></td></tr></tbody></table></figure>

<p><code>NF8_ReadPage_Adv(a,b,c)</code>与<code>CopySDMMCtoMem(ch, sb, bs, dst, i)</code>一致，不在讲解。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CopySDMMCtoMem(ch, sb, bs, dst, i)</td>
<td>从SD/MMC拷贝（加载）块到内存中的函数 （从通道ch的sb块处，加载bs块内存到以dst起始的地方）</td>
</tr>
<tr>
<td>NF8_ReadPage_Adv(a,b,c)</td>
<td>从nand flash拷贝（加载）页到内存中的函数（a：要复制的源块地址号，b：要复制的源页地址号，c：目标缓冲区指针，返回值成功或失败）</td>
</tr>
</tbody></table>
<p>接着就进入到<code>copy_bl2_to_ram</code>，整个<code>copy_bl2_to_ram</code>框架如下。也就是上来先定义bl2的大小为250k（编译结束后生成u-boot.bin大小为240k），所以此处最好大小调大一些（建议512k）。OM为寄存器<code>0xE0000004</code>中存储的值，通过手册（<code>SIAP</code> 中<code>3 Boot configuration</code>）可知OM低5位控制着从哪里启动，所以下面两个分支也就是选择从哪边启动。0x2（0b0010）也即<code>Nand 2KB,5cycle X-TAL</code>；0xc（0b1100）也即<code>SD/MMC X-TAL</code>。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_bl2_to_ram</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    u32 bl2Size = <span class="number">250</span> * <span class="number">1024</span>;       		  <span class="comment">// 250K</span></span><br><span class="line">    u32 OM = *(<span class="keyword">volatile</span> u32 *)(<span class="number">0xE0000004</span>); <span class="comment">// OM Register</span></span><br><span class="line">    OM &amp;= <span class="number">0x1F</span>;                             	       <span class="comment">// 取出低5位OM[4:0]</span></span><br><span class="line">    <span class="keyword">if</span> (OM == <span class="number">0x2</span>) {				       <span class="comment">// Nand 2KB,5cycle X-TAL</span></span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (OM == <span class="number">0xC</span>) {			           <span class="comment">// SD/MMC X-TAL</span></span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204112027872.png"></p>
<p>先分析SD/MMC下的代码（SD卡下的代码），首先取出当前boot的<code>V210_SDMMC_BASE</code>基地址（查看手册<code>SIAP</code> 中<code>2.6 Global Variable</code> ），接着看手册<code>S5PV210_UM_REV1.1.pdf</code>中的<code>7.9.1 REGISTER MAP</code> 找出对应地址的channel，然后从对应channel的SD卡中将以<code>32块开始的250k数据</code>拷贝到SDRAM中的<code>CONFIG_SYS_SDRAM_BASE</code> （<code>0x20000000</code>）中去。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (OM == <span class="number">0xC</span>) {</span><br><span class="line">	    u32 V210_SDMMC_BASE = *(<span class="keyword">volatile</span> u32 *)(<span class="number">0xD0037488</span>);    <span class="comment">// V210_SDMMC_BASE</span></span><br><span class="line">            u8 ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 7.9.1 SD/MMC REGISTER MAP */</span></span><br><span class="line">            <span class="keyword">if</span> (V210_SDMMC_BASE == <span class="number">0xEB000000</span>)</span><br><span class="line">                    ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (V210_SDMMC_BASE == <span class="number">0xEB200000</span>)</span><br><span class="line">                    ch = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 将BL2 从SD卡（32块开始的250k区域数据）拷贝到SDRAM中</span></span><br><span class="line">            CopySDMMCtoMem(ch, <span class="number">32</span>, bl2Size / <span class="number">512</span>, (u32 *)CONFIG_SYS_SDRAM_BASE, <span class="number">0</span>);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p>接着分析如果u-boot在nand中是怎样将BL2拷贝到内存中的？</p>
<p>首先初始化配置，将配置写入到 <code>nand_reg-&gt;nfconf</code> 和 <code>nand_reg-&gt;nfcont</code> 中，接着配置GPIO。<code>pages = bl2Size/2048</code>，看一下BL2一共有多少页。下一个<code>offset = 0x4000/2048</code>，意思是BL2在nand的页偏移。<code>0x4000/512 = 32blocks</code>，也就是在nand中第32个block开始，后256k</p>
<blockquote>
<p><code>void writel(unsigned char data, unsigned short addr)</code> 往内存映射的IO空间上写数据</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line">	<span class="keyword">if</span> (OM == <span class="number">0x2</span>) {</span><br><span class="line">            u32 cfg = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">s5pv210_nand</span> *<span class="title">nand_reg</span> =</span> (struct s5pv210_nand *)(struct s5pv210_nand *)samsung_get_base_nand();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* initialize hardware */</span></span><br><span class="line">            <span class="comment">/* HCLK_PSYS=133MHz(7.5ns) */</span></span><br><span class="line">            cfg =   (<span class="number">0x1</span> &lt;&lt; <span class="number">23</span>) |   <span class="comment">/* Disable 1-bit and 4-bit ECC */</span></span><br><span class="line">                       (<span class="number">0x3</span> &lt;&lt; <span class="number">12</span>) |   <span class="comment">/* 7.5ns * 2 &gt; 12ns tALS tCLS */</span></span><br><span class="line">                       (<span class="number">0x2</span> &lt;&lt; <span class="number">8</span>) |    <span class="comment">/* (1+1) * 7.5ns &gt; 12ns (tWP) */</span></span><br><span class="line">                       (<span class="number">0x1</span> &lt;&lt; <span class="number">4</span>) |    <span class="comment">/* (0+1) * 7.5 &gt; 5ns (tCLH/tALH) */</span></span><br><span class="line">                       (<span class="number">0x0</span> &lt;&lt; <span class="number">3</span>) |    <span class="comment">/* SLC NAND Flash */</span></span><br><span class="line">                       (<span class="number">0x0</span> &lt;&lt; <span class="number">2</span>) |    <span class="comment">/* 2KBytes/Page */</span></span><br><span class="line">                       (<span class="number">0x1</span> &lt;&lt; <span class="number">1</span>);     <span class="comment">/* 5 address cycle */</span></span><br><span class="line"></span><br><span class="line">            writel(cfg, &amp;nand_reg-&gt;nfconf);</span><br><span class="line"></span><br><span class="line">            writel((<span class="number">0x1</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">0x1</span> &lt;&lt; <span class="number">0</span>), &amp;nand_reg-&gt;nfcont);</span><br><span class="line">            <span class="comment">/* Disable chip select and Enable NAND Flash Controller */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Config GPIO */</span></span><br><span class="line">            MP0_1CON &amp;= ~(<span class="number">0xFFFF</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">            MP0_1CON |= (<span class="number">0x3333</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">            MP0_3CON = <span class="number">0x22222222</span>;</span><br><span class="line">            MP0_6CON = <span class="number">0x22222222</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pages = bl2Size / <span class="number">2048</span>;             <span class="comment">//</span></span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">0x4000</span> / <span class="number">2048</span>;             <span class="comment">// u-boot.bin</span></span><br><span class="line">            u8 *p = (u8 *)CONFIG_SYS_SDRAM_BASE;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; pages; i++, p += <span class="number">2048</span>, offset += <span class="number">1</span>)</span><br><span class="line">            	NF8_ReadPage_Adv(offset / <span class="number">64</span>, offset % <span class="number">64</span>, p);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204112111124.png"></p>
<h4 id="board-init-f"><a href="#board-init-f" class="headerlink" title="board_init_f"></a>board_init_f</h4><p><code>board_init_f</code> 在<code>arch/arm/lib/board.c</code>中，天哪，这是个什？这么多代码。</p>
<p>一点点分析吧，首先定义一堆变量，指针等。将<code>gd</code>（<code>global data</code>）中清零，什么，gd又是个什？gd是在什么时候赋值？什么时候分配空间的呢？</p>
<p>在<a href="#_main">_main</a>中通过<code>sub sp,sp,#GD_SIZE</code>给gd分配了空间，后面通过 <code>mov r9，sp</code>更新gd指针，使之指向分配的空间。所以此处直接清零没有任何问题。</p>
<h5 id="global-data"><a href="#global-data" class="headerlink" title="global_data"></a>global_data</h5><blockquote>
<p>在某些情况下，uboot运行在某些只读存储器上，在uboot被重定向到RAM（可读可写）之前，我们都无法写入数据，更无法通过全局变量来传递数据。而global_data则是为了解决这个问题。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/asm-generic/global_data.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> {</span></span><br><span class="line">	<span class="keyword">bd_t</span> *bd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> baudrate;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_clk;	<span class="comment">/* CPU clock in Hz!		*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bus_clk;</span><br><span class="line">	<span class="comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pci_clk;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mem_clk;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fb_base;	<span class="comment">/* Base address of framebuffer mem */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_POST) || defined(CONFIG_LOGBUFFER)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> post_log_word;  <span class="comment">/* Record POST activities */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> post_log_res; <span class="comment">/* success of POST test */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> post_init_f_time;  <span class="comment">/* When post_init_f started */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOARD_TYPES</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> board_type;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> have_console;	<span class="comment">/* serial_init() was called */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PRE_CONSOLE_BUFFER</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> precon_buf_idx;	<span class="comment">/* Pre-Console buffer index */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> do_mdm_init;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> be_quiet;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> env_addr;	<span class="comment">/* Address  of Environment struct */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> env_valid;	<span class="comment">/* Checksum of Environment valid? */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ram_top;	<span class="comment">/* Top address of RAM used by U-Boot */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> relocaddr;	<span class="comment">/* Start address of U-Boot in RAM */</span></span><br><span class="line">	<span class="keyword">phys_size_t</span> ram_size;	<span class="comment">/* RAM size */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mon_len;	<span class="comment">/* monitor len */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> irq_sp;		<span class="comment">/* irq stack pointer */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_addr_sp;	<span class="comment">/* start_addr_stackpointer */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> reloc_off;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">new_gd</span>;</span>	<span class="comment">/* relocated global data */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	*<span class="title">dm_root</span>;</span>	<span class="comment">/* Root instance for Driver Model */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">uclass_root</span>;</span>	<span class="comment">/* Head of core tree */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *fdt_blob;	<span class="comment">/* Our device tree, NULL if none */</span></span><br><span class="line">	<span class="keyword">void</span> *new_fdt;		<span class="comment">/* Relocated FDT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fdt_size;	<span class="comment">/* Space reserved for relocated FDT */</span></span><br><span class="line">	<span class="keyword">void</span> **jt;		<span class="comment">/* jump table */</span></span><br><span class="line">	<span class="keyword">char</span> env_buf[<span class="number">32</span>];	<span class="comment">/* buffer for getenv() before reloc. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE</span></span><br><span class="line">	<span class="keyword">void</span>		*trace_buff;	<span class="comment">/* The trace buffer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SYS_I2C)</span></span><br><span class="line">	<span class="keyword">int</span>		cur_i2c_bus;	<span class="comment">/* current used i2c bus */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timebase_h;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timebase_l;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">arch_global_data</span> <span class="title">arch</span>;</span>	<span class="comment">/* architecture-specific data */</span></span><br><span class="line">} <span class="keyword">gd_t</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>重点说明</p>
<ul>
<li><code>bd_t *bd</code>：board info数据结构定义,位于文件 include/asm-arm/u-boot.h定义,主要是保存开发板的相关参数。</li>
<li><code>unsigned long env_addr</code>：环境变量的地址。</li>
<li><code>unsigned long ram_top</code>：RAM空间的顶端地址</li>
<li><code>unsigned long relocaddr</code>：UBOOT重定向后地址</li>
<li><code>phys_size_t ram_size</code>：物理ram的size</li>
<li><code>unsigned long irq_sp</code>：中断的堆栈地址</li>
<li><code>unsigned long start_addr_sp</code>：堆栈地址</li>
<li><code>unsigned long reloc_off</code>：uboot的relocation的偏移</li>
<li><code>struct global_data *new_gd</code>：重定向后的struct global_data结构体</li>
<li><code>const void *fdt_blob</code>：设备的dtb地址</li>
<li><code>void *new_fdt</code>：relocation之后的dtb地址</li>
<li><code>unsigned long fdt_size</code>：dtb的长度</li>
<li><code>struct udevice *cur_serial_dev</code>：当前使用的串口设备。</li>
</ul>
<p>计算监视区（monitor）长度（<code>__bss_end</code> - <code>_start</code>）并给<code>gd-&gt;mon_len</code></p>
<p>从环境变量中查找<code>fdtcontroladdr</code>，如果存在则更新<code>gd-&gt;fdt_blob</code></p>
<blockquote>
<p><code>ulong getenv_ulong(const char *name, int base, ulong default_val)</code>从环境变量中查找name，存在返回name对应的数值，不存在返回default_val。其中base为进制，例如10、16等。</p>
<p>环境变量的存储用hash表实现</p>
</blockquote>
<p>这一段的意思遍历<code>init_sequence</code>，<code>init_sequence</code>存放的是一系列的函数首地址，通过循环不断将函数地址取出<code>解引用</code>并调用。如果函数返回不为0，表示有错误则一直在此循环。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f</span><span class="params">(ulong bootflag)</span></span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {</span><br><span class="line">		<span class="keyword">if</span> ((*init_fnc_ptr)() != <span class="number">0</span>) {</span><br><span class="line">			hang ();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">        ...</span><br><span class="line"> }</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">init_fnc_t</span> *init_sequence[] = {</span><br><span class="line">	arch_cpu_init,		<span class="comment">/* basic arch cpu dependent setup */</span></span><br><span class="line">	mark_bootstage,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF_CONTROL</span></span><br><span class="line">	fdtdec_check_fdt,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BOARD_EARLY_INIT_F)</span></span><br><span class="line">	board_early_init_f,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	timer_init,		<span class="comment">/* initialize timer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BOARD_POSTCLK_INIT</span></span><br><span class="line">	board_postclk_init,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSL_ESDHC</span></span><br><span class="line">	get_clocks,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	env_init,			<span class="comment">/* initialize environment */</span></span><br><span class="line">	init_baudrate,		<span class="comment">/* initialze baudrate settings */</span></span><br><span class="line">	serial_init,		  <span class="comment">/* serial communications setup */</span></span><br><span class="line">	console_init_f,		  <span class="comment">/* stage 1 init of console */</span></span><br><span class="line">	display_banner,		<span class="comment">/* say that we are here */</span></span><br><span class="line">	print_cpuinfo,		<span class="comment">/* display cpu info (and speed) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_DISPLAY_BOARDINFO)</span></span><br><span class="line">	checkboard,		<span class="comment">/* display board info */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span></span><br><span class="line">	init_func_i2c,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	dram_init,		<span class="comment">/* configure available RAM banks */</span></span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>让我们一个个的看看这些函数都是干什么的。</p>
<h5 id="arch-cpu-init"><a href="#arch-cpu-init" class="headerlink" title="arch_cpu_init"></a>arch_cpu_init</h5><p>这个函数做的是针对特定CPU的初始化，u-boot支持很多CPU，不同CPU的初始化也不尽相同，因此u-boot提供了arch_cpu_init用于CPU初始化。这个函数由移植者根据自己的硬件（CPU）的情况来提供，如果不提供，则默认的是一个仅返回0的函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arch_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span> __<span class="title">attribute__</span><span class="params">((weak, alias(<span class="string">"__arch_cpu_init"</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __arch_cpu_init(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="mark-bootstage"><a href="#mark-bootstage" class="headerlink" title="mark_bootstage"></a>mark_bootstage</h5><p>其中<code>bootstage_mark_name（id,name）</code>用于标记当前运行的id和名字。这个函数也就是用来标记当前运行的函数为<code>board_init_f</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mark_bootstage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, <span class="string">"board_init_f"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="fdtdec-check-fdt"><a href="#fdtdec-check-fdt" class="headerlink" title="fdtdec_check_fdt"></a>fdtdec_check_fdt</h5><p>由于未配置<code>CONFIG_OF_CONTROL</code>，所以不会检查fdt。</p>
<p>这个函数的功能是，在 控制台未准备好之前必须有一个FDT，否则会panic。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lib/fdtdec.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdtdec_check_fdt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We must have an FDT, but we cannot panic() yet since the console</span></span><br><span class="line"><span class="comment">	 * is not ready. So for now, just assert(). Boards which need an early</span></span><br><span class="line"><span class="comment">	 * FDT (prior to console ready) will need to make their own</span></span><br><span class="line"><span class="comment">	 * arrangements and do their own checks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	assert(!fdtdec_prepare_fdt());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="board-early-init-f"><a href="#board-early-init-f" class="headerlink" title="board_early_init_f"></a>board_early_init_f</h5><p>由于未配置<code>CONFIG_BOARD_EARLY_INIT_F</code>，不会执行</p>
<h5 id="timer-init"><a href="#timer-init" class="headerlink" title="timer_init"></a>timer_init</h5><p>这个配置貌似跟cpu有关系，在每个不同的cpu有不同的 <code>timer_init</code>，另外在 <code>lib/time.c</code> 中也有一个弱空实现。</p>
<p>s5pv210芯片的在 <code>arch/arm/cpu/armv7/s5p-common/time.c</code>中。</p>
<p>使用SOC的<code>Pwm Timer4</code>作为定时器，Timer4 没有输出引脚，不耽误其Pwm功能。设置Pwm Timer4 4分频，设置占空比为100000ns、周期为100000ns,开启定时器4。</p>
<p>接着将<code>gd-&gt;arch.timer_reset_value</code>复位。更新<code>gd-&gt;arch.lastinc</code>，复位<code>gd-&gt;arch.lastinc = readl(&amp;timer-&gt;tcnto4);</code>，<code>gd-&gt;arch.tbl = 0;</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/cpu/armv7/s5p-common/time.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">/* PWM Timer 4 */</span></span><br><span class="line">	pwm_init(<span class="number">4</span>, MUX_DIV_4, <span class="number">0</span>);</span><br><span class="line">	pwm_config(<span class="number">4</span>, <span class="number">100000</span>, <span class="number">100000</span>);</span><br><span class="line">	pwm_enable(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use this as the current monotonic time in us */</span></span><br><span class="line">	gd-&gt;arch.timer_reset_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use this as the last timer value we saw */</span></span><br><span class="line">	gd-&gt;arch.lastinc = timer_get_us_down();</span><br><span class="line">	reset_timer_masked();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="board-postclk-init"><a href="#board-postclk-init" class="headerlink" title="board_postclk_init"></a>board_postclk_init</h5><p>由于未配置<code>CONFIG_BOARD_POSTCLK_INIT</code>，不会执行</p>
<h5 id="get-clocks"><a href="#get-clocks" class="headerlink" title="get_clocks"></a>get_clocks</h5><p>由于未配置<code>CONFIG_FSL_ESDHC</code>，不会执行</p>
<h5 id="env-init"><a href="#env-init" class="headerlink" title="env_init"></a>env_init</h5><p>通过SI在Symbols中搜索发现有多个<code>env_init</code>,猜测是不同的板子可能存到不同的存储设备上。</p>
<blockquote>
<ol>
<li><p>环境变量可能位于很多地方，比如EEPROM、FLASH等地方，枚举<code>enum env_location</code>定义了一些常量用于标识环境变量的位置。这些常量有ENVL_EEPROM、ENVL_EXT4等</p>
</li>
<li><p>uboot获取环境变量的位置时，有一个先后顺序，比如优先看环境变量是否在EEPROM中。这个优先顺序实现很简单：定义一个数组<code>env_locations</code>，<strong>数组里存的是环境变量各个的位置，存的顺序就是优先顺序，</strong>然后只要从下标为0开始访问这个数组，即可按照数组指定的优先顺序来获取环境变量的位置。</p>
</li>
<li><p>对于存在于不同位置的环境变量，u-boot会使用<code>U_BOOT_ENV_LOCATION</code>定义一个相应的<code>struct env_driver</code>类型的entry，多个entry在内存中连续分布，因此可以向遍历数组元素那样遍历这些entry。而实现内存连续分布的关键在于<strong>自定义段</strong>，</p>
 <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在链接脚本中将这些段按照段名的字母顺序排列:</span></span><br><span class="line"><span class="comment">	.u_boot_list : {</span></span><br><span class="line"><span class="comment">  		KEEP(*(SORT(.u_boot_list*)));</span></span><br><span class="line"><span class="comment"> 	}</span></span><br><span class="line"><span class="comment">	因此可用u_boot_list_2_env_driver_1标记这些entry的起始地址</span></span><br><span class="line"><span class="comment">	而使用u_boot_list_2_env_driver_3标记相应的结束地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.u_boot_list_2_env_driver_1</span><br><span class="line">.u_boot_list_2_env_driver_2_eeprom</span><br><span class="line">.u_boot_list_2_env_driver_2_ext4</span><br><span class="line">.u_boot_list_2_env_driver_3</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</blockquote>
<p>smart210这个板子在执行<code>saveenv</code>是直接存储环境变量到<code>NAND</code>的0x60000处。实际上通过编译脚本来说更有说服力，首先，看下<code>common/Makefile</code>，要编译对应的文件，需要使能相关宏后才会编译。再次查看<code>include/configs/smart210.h</code>，其定义了<code>#define CONFIG_ENV_IS_IN_NAND 1</code>，所以env_init的路径为<code>common/env_nand.c</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># environment</span></span><br><span class="line">obj-y += env_attr.o</span><br><span class="line">obj-y += env_callback.o</span><br><span class="line">obj-y += env_flags.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o</span><br><span class="line">extra-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_embedded.o</span><br><span class="line">extra-$(CONFIG_ENV_IS_IN_FLASH) += env_embedded.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_embedded.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_MMC) += env_mmc.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o</span><br><span class="line">obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o</span><br></pre></td></tr></tbody></table></figure>



<p>所以我们只关心<code>common/env_nand.c</code>中的，别看代码这么长。实际上<code>ENV_IS_EMBEDDED</code>与<code>CONFIG_NAND_ENV_DST</code>我们都没有定义，所以真正的代码只有两句。</p>
<p>从注释就基本可以看出这个函数的作用，因为<code>env_init</code>要早于静态存储器的初始化，所以无法进行<code>env</code>的读写，这里将<code>gd</code>中的<code>env</code>相关变量进行配置，默认设置<code>env</code>为<code>valid</code>。<code>default_environment</code>是什么？<strong>TODO:待分析</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gd-&gt;env_addr	= (ulong)&amp;default_environment[<span class="number">0</span>];</span><br><span class="line">gd-&gt;env_valid	  = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/env_nand.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is called before nand_init() so we can't read NAND to</span></span><br><span class="line"><span class="comment"> * validate env data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Mark it OK for now. env_relocate() in env_common.c will call our</span></span><br><span class="line"><span class="comment"> * relocate function which does the real validation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When using a NAND boot image (like sequoia_nand), the environment</span></span><br><span class="line"><span class="comment"> * can be embedded or attached to the U-Boot image in NAND flash.</span></span><br><span class="line"><span class="comment"> * This way the SPL loads not only the U-Boot image from NAND but</span></span><br><span class="line"><span class="comment"> * also the environment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ENV_IS_EMBEDDED) || defined(CONFIG_NAND_ENV_DST)</span></span><br><span class="line">	<span class="keyword">int</span> crc1_ok = <span class="number">0</span>, crc2_ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">env_t</span> *tmp_env1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ENV_OFFSET_REDUND</span></span><br><span class="line">	<span class="keyword">env_t</span> *tmp_env2;</span><br><span class="line"></span><br><span class="line">	tmp_env2 = (<span class="keyword">env_t</span> *)((ulong)env_ptr + CONFIG_ENV_SIZE);</span><br><span class="line">	crc2_ok = crc32(<span class="number">0</span>, tmp_env2-&gt;data, ENV_SIZE) == tmp_env2-&gt;crc;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	tmp_env1 = env_ptr;</span><br><span class="line">	crc1_ok = crc32(<span class="number">0</span>, tmp_env1-&gt;data, ENV_SIZE) == tmp_env1-&gt;crc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!crc1_ok &amp;&amp; !crc2_ok) {</span><br><span class="line">		gd-&gt;env_addr	= <span class="number">0</span>;</span><br><span class="line">		gd-&gt;env_valid	= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (crc1_ok &amp;&amp; !crc2_ok) {</span><br><span class="line">		gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ENV_OFFSET_REDUND</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!crc1_ok &amp;&amp; crc2_ok) {</span><br><span class="line">		gd-&gt;env_valid = <span class="number">2</span>;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">/* both ok - check serial */</span></span><br><span class="line">		<span class="keyword">if</span> (tmp_env1-&gt;flags == <span class="number">255</span> &amp;&amp; tmp_env2-&gt;flags == <span class="number">0</span>)</span><br><span class="line">			gd-&gt;env_valid = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp_env2-&gt;flags == <span class="number">255</span> &amp;&amp; tmp_env1-&gt;flags == <span class="number">0</span>)</span><br><span class="line">			gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp_env1-&gt;flags &gt; tmp_env2-&gt;flags)</span><br><span class="line">			gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp_env2-&gt;flags &gt; tmp_env1-&gt;flags)</span><br><span class="line">			gd-&gt;env_valid = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">/* flags are equal - almost impossible */</span></span><br><span class="line">			gd-&gt;env_valid = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;env_valid == <span class="number">2</span>)</span><br><span class="line">		env_ptr = tmp_env2;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (gd-&gt;env_valid == <span class="number">1</span>)</span><br><span class="line">		env_ptr = tmp_env1;</span><br><span class="line"></span><br><span class="line">	gd-&gt;env_addr = (ulong)env_ptr-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */</span></span></span><br><span class="line">	gd-&gt;env_addr	= (ulong)&amp;default_environment[<span class="number">0</span>];</span><br><span class="line">	gd-&gt;env_valid	= <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ENV_IS_EMBEDDED || CONFIG_NAND_ENV_DST */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="init-baudrate"><a href="#init-baudrate" class="headerlink" title="init_baudrate"></a>init_baudrate</h5><p>上面我们介绍了<code>getenv_ulong</code>，从环境变量中获取参数，所以本函数的作用是从环境变量中取出<code>baudrate</code>对应的值给<code>gd</code>，以10进制，如果没有，默认为<code>115200</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_baudrate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;baudrate = getenv_ulong(<span class="string">"baudrate"</span>, <span class="number">10</span>, CONFIG_BAUDRATE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="serial-init"><a href="#serial-init" class="headerlink" title="serial_init"></a>serial_init</h5><p>获取当前的串口设备，并调用当前串口设备的start成员函数</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/serial/serial.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serial_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> get_current()-&gt;start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于此时重定位还没做，GD_FLG_RELOC标志未设置，因此条件满足，会进入第一个分支，因此<code>dev = default_serial_console();</code>后面调用start。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/serial/serial.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct serial_device *<span class="title">get_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">serial_device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(gd-&gt;flags &amp; GD_FLG_RELOC))</span><br><span class="line">		dev = default_serial_console();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!serial_current)</span><br><span class="line">		dev = default_serial_console();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		dev = serial_current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We must have a console device */</span></span><br><span class="line">	<span class="keyword">if</span> (!dev) {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPL_BUILD</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Cannot find console\n"</span>);</span><br><span class="line">		hang();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		panic(<span class="string">"Cannot find console\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="console-init-f"><a href="#console-init-f" class="headerlink" title="console_init_f"></a>console_init_f</h5><p>将<code>gd</code>中<code>have_console</code>置为1，然后打印Pre-Console Buffer中的数据。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* common/console.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">console_init_f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;have_console = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SILENT_CONSOLE</span></span><br><span class="line">	<span class="keyword">if</span> (getenv(<span class="string">"silent"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">		gd-&gt;flags |= GD_FLG_SILENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	print_pre_console_buffer();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="display-banner"><a href="#display-banner" class="headerlink" title="display_banner"></a>display_banner</h5><p>上面我们已经配置好串口，现在可以输出信息到终端了。</p>
<p>此处就是打印，如果定义了宏 <code>DEBUG</code>，将输出更多信息。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">U-Boot 2014.04-g8819fbf-dirty (Apr 12 2022 - 10:19:11) for SMART210</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">display_banner</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n\n%s\n\n"</span>, version_string);</span><br><span class="line">	debug(<span class="string">"U-Boot code: %08lX -&gt; %08lX  BSS: -&gt; %08lX\n"</span>,(ulong)&amp;_start,(ulong)&amp;__bss_start, (ulong)&amp;__bss_end);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODEM_SUPPORT</span></span><br><span class="line">	debug(<span class="string">"Modem Support enabled\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_USE_IRQ</span></span><br><span class="line">	debug(<span class="string">"IRQ Stack: %08lx\n"</span>, IRQ_STACK_START);</span><br><span class="line">	debug(<span class="string">"FIQ Stack: %08lx\n"</span>, FIQ_STACK_START);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="print-cpuinfo"><a href="#print-cpuinfo" class="headerlink" title="print_cpuinfo"></a>print_cpuinfo</h5><p>打印CPU信息，所以该函数位置为 <code>arch/arm/cpu/armv7/s5p-common/cpu_info.c</code></p>
<p>输出CPU名字、ID、频率信息。如</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU:	S5PC110@1000MHz</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/cpu/armv7/s5p-common/cpu_info.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_cpuinfo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CPU:\t%s%X@%sMHz\n"</span>,</span><br><span class="line">			s5p_get_cpu_name(), s5p_cpu_id,</span><br><span class="line">			strmhz(buf, get_arm_clk()));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="checkboard"><a href="#checkboard" class="headerlink" title="checkboard"></a>checkboard</h5><p>配置了宏<code>CONFIG_DISPLAY_BOARDINFO</code>,位于<code>board/samsung/smart210/smart210.c</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Board:	SMART210</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkboard</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Board:\tSMART210\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="init-func-i2c"><a href="#init-func-i2c" class="headerlink" title="init_func_i2c"></a>init_func_i2c</h5><p>似乎没有配置，暂不分析。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* board/samsung/smart210/smart210.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_func_i2c</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"I2C:   "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_I2C</span></span><br><span class="line">	i2c_init_all();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"ready\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>



<h5 id="dram-init"><a href="#dram-init" class="headerlink" title="dram_init"></a>dram_init</h5><p>更新<code>gd</code>中的内存大小，其值为<code> get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE)</code>。<code>get_ram_size</code>又是什么呢？是用来检测内给定范围内的内存是否有效的一个小函数，在当前函数中检测范围为<code>[PHYS_SDRAM_1, PHYS_SDRAM_1+PHYS_SDRAM_1_SIZE]</code>。如果没有问题，返回<code>PHYS_SDRAM_1_SIZE</code>。<code>TODO:剩下的下次在分析</code></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// board/samsung/smart210.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dram_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	gd-&gt;ram_size = get_ram_size((<span class="keyword">long</span> *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/memsize.c</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_ram_size</span><span class="params">(<span class="keyword">long</span> *base, <span class="keyword">long</span> maxsize)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> *addr;</span><br><span class="line">	<span class="keyword">long</span>           save[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">long</span>           cnt;</span><br><span class="line">	<span class="keyword">long</span>           val;</span><br><span class="line">	<span class="keyword">long</span>           size;</span><br><span class="line">	<span class="keyword">int</span>            i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (cnt = (maxsize / <span class="keyword">sizeof</span> (<span class="keyword">long</span>)) &gt;&gt; <span class="number">1</span>; cnt &gt; <span class="number">0</span>; cnt &gt;&gt;= <span class="number">1</span>) {</span><br><span class="line">		addr = base + cnt;	<span class="comment">/* pointer arith! */</span></span><br><span class="line">		sync ();</span><br><span class="line">		save[i++] = *addr;</span><br><span class="line">		sync ();</span><br><span class="line">		*addr = ~cnt;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	addr = base;</span><br><span class="line">	sync ();</span><br><span class="line">	save[i] = *addr;</span><br><span class="line">	sync ();</span><br><span class="line">	*addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	sync ();</span><br><span class="line">	<span class="keyword">if</span> ((val = *addr) != <span class="number">0</span>) {</span><br><span class="line">		<span class="comment">/* Restore the original data before leaving the function.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sync ();</span><br><span class="line">		*addr = save[i];</span><br><span class="line">		<span class="keyword">for</span> (cnt = <span class="number">1</span>; cnt &lt; maxsize / <span class="keyword">sizeof</span>(<span class="keyword">long</span>); cnt &lt;&lt;= <span class="number">1</span>) {</span><br><span class="line">			addr  = base + cnt;</span><br><span class="line">			sync ();</span><br><span class="line">			*addr = save[--i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (cnt = <span class="number">1</span>; cnt &lt; maxsize / <span class="keyword">sizeof</span> (<span class="keyword">long</span>); cnt &lt;&lt;= <span class="number">1</span>) {</span><br><span class="line">		addr = base + cnt;	<span class="comment">/* pointer arith! */</span></span><br><span class="line">		val = *addr;</span><br><span class="line">		*addr = save[--i];</span><br><span class="line">		<span class="keyword">if</span> (val != ~cnt) {</span><br><span class="line">			size = cnt * <span class="keyword">sizeof</span> (<span class="keyword">long</span>);</span><br><span class="line">			<span class="comment">/* Restore the original data before leaving the function.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">for</span> (cnt &lt;&lt;= <span class="number">1</span>; cnt &lt; maxsize / <span class="keyword">sizeof</span> (<span class="keyword">long</span>); cnt &lt;&lt;= <span class="number">1</span>) {</span><br><span class="line">				addr  = base + cnt;</span><br><span class="line">				*addr = save[--i];</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> (size);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (maxsize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p>上文我们将那一个初始化列表讲完了。下面接着对board_init_f分析。根据打印日志，删除没有用的宏开关，方便我们分析代码。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2014.04-g8819fbf-dirty (Apr 12 2022 - 10:16:10) for SMART210</span><br><span class="line"></span><br><span class="line">U-Boot code: 20000000 -&gt; 2003A2D0  BSS: -&gt; 200706D0</span><br><span class="line">CPU:	S5PC110@1000MHz</span><br><span class="line">Board:	SMART210</span><br><span class="line">monitor len: 000706D0</span><br><span class="line">ramsize: 20000000</span><br><span class="line">TLB table from 3fff0000 to 3fff4000</span><br><span class="line">Top of RAM usable for U-Boot at: 3fff0000</span><br><span class="line">Reserving 449k for U-Boot at: 3ff7f000</span><br><span class="line">Reserving 1280k for malloc() at: 3fe3f000</span><br><span class="line">Reserving 32 Bytes for Board Info at: 3fe3efe0</span><br><span class="line">Reserving 160 Bytes for Global Data at: 3fe3ef40</span><br><span class="line">New Stack Pointer is: 3fe3ef30</span><br><span class="line">RAM Configuration:</span><br><span class="line">Bank #0: 20000000 512 MiB</span><br><span class="line">relocation Offset is: 1ff7f000</span><br><span class="line">WARNING: Caches not enabled</span><br></pre></td></tr></tbody></table></figure>

<p>接着打印<code>gd-&gt;mon_len</code>和<code>gd-&gt;ram_size</code>，然后<code>addr=CONFIG_SYS_SDRAM_BASE+get_effective_memsize();</code> ，其中<code>CONFIG_SYS_SDRAM_BASE</code>为SDRAM起始地址，也就是<code>0x20000000</code>，<code>get_effective_memsize</code>在 <code>common/memsize.c</code> 有一个弱实现，其余与板级相关的地方没有发现该函数。所以确认调用为<code>common/memsize.c</code>中<code>get_effective_memsize()</code>，其实也就是判断定义内存大小是否超过了最大界限，超过则返回最大值，否则<code>gd-&gt;ram_size</code>。而<code>gd-&gt;ram_size</code>在<a href="#dram_init">dram_init</a>中得到的大小为<code>PHYS_SDRAM_1_SIZE</code>，所以addr此时为<code>CONFIG_SYS_SDRAM_BASE+PHYS_SDRAM_1_SIZE</code>。</p>
<p>然后更新<code>gd-&gt;arch.tlb_size</code> 值为<code>PGTABLE_SIZE</code>（<code>4096*4</code>，也就是4k），然后下面一个64kb对齐（换句话说<code>PGTABLE_SIZE</code>最大可设置为64kb），接着更新<code>gd-&gt;arch.tlb_addr</code>。然后4kb对齐，<code>addr -= gd-&gt;mon_len</code>，继续4kb对齐。</p>
<p><strong>TODO：剩下的明天接着分析</strong>最好画个图就清晰多了。最终内存分布是这样的。</p>
<p>总结一下，这段代码首先用来<code>更新gd结构体</code>中的内容，然后将<code>gd</code>结构体在拷贝到内存中对应位置。</p>
<p>此处需要注意下，当前代码还没有重定位，所以<code>_start</code>还是在起始位置，也就是<code>0x20000000</code>处，</p>
<p><code>gd-&gt;relocaddr = addr</code>，<code>gd-&gt;reloc_off = addr - (ulong)&amp;_start</code>，<code>gd-&gt;relocaddr</code>存储的为重定位后的地址，所以<code>gd-&gt;reloc_off</code>存储的是重定位前后<code>_start</code>的绝对值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131359579.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arch/arm/lib/board.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f</span><span class="params">(ulong bootflag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">bd_t</span> *bd;</span><br><span class="line">	<span class="keyword">init_fnc_t</span> **init_fnc_ptr;</span><br><span class="line">	<span class="keyword">gd_t</span> *id;</span><br><span class="line">	ulong addr, addr_sp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PRAM</span></span><br><span class="line">	ulong reg;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">void</span> *new_fdt = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> fdt_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	debug(<span class="string">"monitor len: %08lX\n"</span>, gd-&gt;mon_len);</span><br><span class="line">	debug(<span class="string">"ramsize: %08lX\n"</span>, gd-&gt;ram_size);</span><br><span class="line">	addr = CONFIG_SYS_SDRAM_BASE + get_effective_memsize();	<span class="comment">/* CONFIG_SYS_SDRAM_BASE+PHYS_SDRAM_1_SIZE */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(defined(CONFIG_SYS_ICACHE_OFF) &amp;&amp; defined(CONFIG_SYS_DCACHE_OFF))</span></span><br><span class="line">	<span class="comment">/* reserve TLB table */</span></span><br><span class="line">	gd-&gt;arch.tlb_size = PGTABLE_SIZE;</span><br><span class="line">	addr -= gd-&gt;arch.tlb_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* round down to next 64 kB limit */</span></span><br><span class="line">	addr &amp;= ~(<span class="number">0x10000</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	gd-&gt;arch.tlb_addr = addr;</span><br><span class="line">	debug(<span class="string">"TLB table from %08lx to %08lx\n"</span>, addr, addr + gd-&gt;arch.tlb_size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* round down to next 4 kB limit */</span></span><br><span class="line">	addr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);</span><br><span class="line">	debug(<span class="string">"Top of RAM usable for U-Boot at: %08lx\n"</span>, addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * reserve memory for U-Boot code, data &amp; bss</span></span><br><span class="line"><span class="comment">	 * round down to next 4 kB limit</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr -= gd-&gt;mon_len;</span><br><span class="line">	addr &amp;= ~(<span class="number">4096</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"Reserving %ldk for U-Boot at: %08lx\n"</span>, gd-&gt;mon_len &gt;&gt; <span class="number">10</span>, addr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPL_BUILD</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * reserve memory for malloc() arena</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp = addr - TOTAL_MALLOC_LEN;</span><br><span class="line">	debug(<span class="string">"Reserving %dk for malloc() at: %08lx\n"</span>,</span><br><span class="line">			TOTAL_MALLOC_LEN &gt;&gt; <span class="number">10</span>, addr_sp);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * (permanently) allocate a Board Info struct</span></span><br><span class="line"><span class="comment">	 * and a permanent copy of the "global" data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr_sp -= <span class="keyword">sizeof</span> (<span class="keyword">bd_t</span>);</span><br><span class="line">	bd = (<span class="keyword">bd_t</span> *) addr_sp;</span><br><span class="line">	gd-&gt;bd = bd;</span><br><span class="line">	debug(<span class="string">"Reserving %zu Bytes for Board Info at: %08lx\n"</span>,</span><br><span class="line">			<span class="keyword">sizeof</span> (<span class="keyword">bd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MACH_TYPE</span></span><br><span class="line">	gd-&gt;bd-&gt;bi_arch_number = CONFIG_MACH_TYPE; <span class="comment">/* board id for Linux */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	addr_sp -= <span class="keyword">sizeof</span> (<span class="keyword">gd_t</span>);</span><br><span class="line">	id = (<span class="keyword">gd_t</span> *) addr_sp;</span><br><span class="line">	debug(<span class="string">"Reserving %zu Bytes for Global Data at: %08lx\n"</span>,</span><br><span class="line">			<span class="keyword">sizeof</span> (<span class="keyword">gd_t</span>), addr_sp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ARM64</span></span><br><span class="line">	<span class="comment">/* setup stackpointer for exeptions */</span></span><br><span class="line">	gd-&gt;irq_sp = addr_sp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_USE_IRQ</span></span><br><span class="line">	addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);</span><br><span class="line">	debug(<span class="string">"Reserving %zu Bytes for IRQ stack at: %08lx\n"</span>,</span><br><span class="line">		CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* leave 3 words for abort-stack    */</span></span><br><span class="line">	addr_sp -= <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 8-byte alignment for ABI compliance */</span></span><br><span class="line">	addr_sp &amp;= ~<span class="number">0x07</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* CONFIG_ARM64 */</span></span></span><br><span class="line">	<span class="comment">/* 16-byte alignment for ABI compliance */</span></span><br><span class="line">	addr_sp &amp;= ~<span class="number">0x0f</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_ARM64 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	addr_sp += <span class="number">128</span>;	<span class="comment">/* leave 32 words for abort-stack   */</span></span><br><span class="line">	gd-&gt;irq_sp = addr_sp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	debug(<span class="string">"New Stack Pointer is: %08lx\n"</span>, addr_sp);</span><br><span class="line"></span><br><span class="line">	gd-&gt;bd-&gt;bi_baudrate = gd-&gt;baudrate;</span><br><span class="line">	<span class="comment">/* Ram ist board specific, so move it to board code ... */</span></span><br><span class="line">	dram_init_banksize(); <span class="comment">// 更新gd-&gt;bd-&gt;bi_dram[0] 的start和size</span></span><br><span class="line">	display_dram_config();	<span class="comment">/* and display it */</span></span><br><span class="line"></span><br><span class="line">	gd-&gt;relocaddr = addr;</span><br><span class="line">	gd-&gt;start_addr_sp = addr_sp;</span><br><span class="line">	gd-&gt;reloc_off = addr - (ulong)&amp;_start;</span><br><span class="line">	debug(<span class="string">"relocation Offset is: %08lx\n"</span>, gd-&gt;reloc_off);</span><br><span class="line">	<span class="keyword">if</span> (new_fdt) {</span><br><span class="line">		<span class="built_in">memcpy</span>(new_fdt, gd-&gt;fdt_blob, fdt_size);</span><br><span class="line">		gd-&gt;fdt_blob = new_fdt;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">memcpy</span>(id, (<span class="keyword">void</span> *)gd, <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="main-继续，接上文"><a href="#main-继续，接上文" class="headerlink" title="_main 继续，接上文"></a>_main 继续，接上文</h4><p>在非SPL下，接着就是更新<code>sp</code>和<code>gd</code>，然后重定位代码。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	...</span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">	ldr	sp, [r9, #GD_START_ADDR_SP]	/* sp = gd-&gt;start_addr_sp */</span><br><span class="line">	bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */</span><br><span class="line">	ldr	r9, [r9, #GD_BD]		/* r9 = gd-&gt;bd */</span><br><span class="line">	sub	r9, r9, #GD_SIZE		/* new GD is below bd */</span><br><span class="line">	...</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p><code>GD_START_ADDR_SP</code>在 <code>include/generated/generic-asm-offsets.h</code>中定义，其值为 <code>start_addr_sp</code> 在  <code>global_data</code> 结构中的相对偏移，同样是编译后才生成的。</p>
<p>由上面的代码可知，刚刚为<code>gd</code>也就是<code>global_data</code>分配了大小为<code>GD_SIZE</code>的空间，现在<code>r9</code>和<code>sp</code>内的数据为地址<code>CONFIG_SYS_INIT_SP_ADDR - GD_SIZE</code> （需要8字节对齐）中的数据。换句话说此时<code>r9</code>中为<code>gd</code>的地址，那么再加上 <code>GD_START_ADDR_SP</code>，也就是<code>gd+GD_START_ADDR_SP</code>，将<code>gd+GD_START_ADDR_SP</code>地址中的值（<code>gd-&gt;start_addr_sp</code>）传递给<code>sp</code>，接着8字节对齐。</p>
<p>然后更新<code>r9</code>的值为<code>[r9 + GD_BD]</code>，也就是<code>r9 = gd-&gt;bd</code>。</p>
<p>然后又分配一个大小为<code>GD_SIZE</code>的空间。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	...</span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">	...</span><br><span class="line">	adr	lr, here</span><br><span class="line">	ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd-&gt;reloc_off */</span><br><span class="line">	add	lr, lr, r0</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd-&gt;relocaddr */</span><br><span class="line">	b	relocate_code</span><br><span class="line">	</span><br><span class="line">here:</span><br><span class="line">/* Set up final (full) environment */</span><br><span class="line">	bl	c_runtime_cpu_setup	/* we still call old routine here */</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>

<p>将<code>here</code>处的<code>相对地址</code>复制给<code>lr</code>，将<code>gd</code>结构中的<code>reloc_off</code>值（其相对于<code>gd</code>偏移为<code>GD_RELOC_OFF</code>）给<code>r0</code>。</p>
<p><code>lr</code>与<code>r0</code>相加给<code>lr</code>,即<code>lr = lr + r0</code>，将<code>gd</code>结构中的<code>relocaddr</code>值（其相对于<code>gd</code>偏移为<code>GD_RELOCADDR</code>）给<code>r0</code>。</p>
<p>此时<code>lr = here + gd-&gt;reloc_off</code>，<code>r0 = gd-&gt;relocaddr</code>，然后调用<code>relocate_code</code>。</p>
<h4 id="relocate-code"><a href="#relocate-code" class="headerlink" title="relocate_code"></a>relocate_code</h4><p>其定义位于 <code>include/common.h</code>中，由于定义了宏<code>CONFIG_ARM</code>，所以其声明为如下代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/common.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relocate_code</span><span class="params">(ulong)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>其实现位于 <code>arch/arm/lib/relocate.S</code>中</p>
<p>是一个比较麻烦的地方，并且需要函数传参。</p>
<p>看代码，进入到<code>relocate_code</code>后，此时r0寄存器中数据为<code>gd-&gt;relocaddr</code>，也就是为重定位后的u-boot程序地址。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	ldr	r1, =__image_copy_start	/* r1 &lt;- SRC &amp;__image_copy_start */</span><br><span class="line">	subs	r4, r0, r1		/* r4 &lt;- relocation offset */</span><br><span class="line">	beq	relocate_done		/* skip relocation */</span><br><span class="line">	ldr	r2, =__image_copy_end	/* r2 &lt;- SRC &amp;__image_copy_end */</span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, {r10-r11}		/* copy from source address [r1]    */</span><br><span class="line">	stmia	r0!, {r10-r11}		/* copy to   target address [r0]    */</span><br><span class="line">	cmp	r1, r2			/* until source end address [r2]    */</span><br><span class="line">	blo	copy_loop</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * fix .rel.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	ldr	r2, =__rel_dyn_start	/* r2 &lt;- SRC &amp;__rel_dyn_start */</span><br><span class="line">	ldr	r3, =__rel_dyn_end	/* r3 &lt;- SRC &amp;__rel_dyn_end */</span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, {r0-r1}		/* (r0,r1) &lt;- (SRC location,fixup) */</span><br><span class="line">	and	r1, r1, #0xff</span><br><span class="line">	cmp	r1, #23			/* relative fixup? */</span><br><span class="line">	bne	fixnext</span><br><span class="line"></span><br><span class="line">	/* relative fix: increase location by offset */</span><br><span class="line">	add	r0, r0, r4</span><br><span class="line">	ldr	r1, [r0]</span><br><span class="line">	add	r1, r1, r4</span><br><span class="line">	str	r1, [r0]</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3</span><br><span class="line">	blo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line"></span><br><span class="line">#ifdef __XSCALE__</span><br><span class="line">	/*</span><br><span class="line">	 * On xscale, icache must be invalidated and write buffers drained,</span><br><span class="line">	 * even with cache disabled - 4.2.7 of xscale core developer's manual</span><br><span class="line">	 */</span><br><span class="line">	mcr	p15, 0, r0, c7, c7, 0	/* invalidate icache */</span><br><span class="line">	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* ARMv4- don't know bx lr but the assembler fails to see that */</span><br><span class="line"></span><br><span class="line">#ifdef __ARM_ARCH_4__</span><br><span class="line">	mov        pc, lr</span><br><span class="line">#else</span><br><span class="line">	bx        lr</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></tbody></table></figure>



<p>在进入第一句代码之前，我们先了解一下<code>__image_copy_start</code>和<code>__image_copy_end</code>，在<code>arch/arc/lib/sections.c</code>定义，并通过<code>__attribute__</code>放到了对应段中。在编译之后，这些段有什么用呢？</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arc/lib/sections.c</span></span><br><span class="line"><span class="keyword">char</span> __bss_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__bss_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __bss_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__bss_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __image_copy_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__image_copy_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __image_copy_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__image_copy_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __rel_dyn_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__rel_dyn_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __rel_dyn_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__rel_dyn_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __text_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__text_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __text_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__text_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __init_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__init_end"</span>)));</span><br></pre></td></tr></tbody></table></figure>

<p>查看<code>u-boot.lds</code>，在 <code>arch/arm/cpu/u-boot.lds</code>，但这个并不是最终的，最终的链接脚本是在此基础上生成的。需要编译u-boot后会在根目录下才会生成u-boot.lds。</p>
<blockquote>
<p>GNU编译器生成的目标文件缺省为elf格式，elf文件由若干段（section）组成，如不特殊指明，由C源程序生成的目标代码中包含如下段：</p>
<ul>
<li>.text(正文段)包含程序的指令代码；</li>
<li>.data(数据段)包含固定的数据，如常量、字符串；</li>
<li>.bss(未初始化数据段)包含未初始化的变量、数组等。</li>
</ul>
<p>C++源程序生成的目标代码中还包括</p>
<ul>
<li>.fini(析构函数代码)</li>
<li>.init(构造函数代码)等.<br>  链接器的任务就是将多个目标文件的.text、.data和.bss等段链接在一起，而链接脚本文件是告诉链接器从什么地址开始放置这些段.简而言之，由于一个工程中有多个.c文件，当它们生成.o文件后如何安排它们在可执行文件中的顺序，这就是链接脚本的作用.</li>
</ul>
<p>这里以u-boot的lds为例说明uboot的链接过程，首先看一下GNU官方网站上对.lds文件形式的完整描述：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;SECTIONS {</span><br><span class="line">&gt;...</span><br><span class="line">&gt;<span class="function">secname start <span class="title">BLOCK</span><span class="params">(align)</span> <span class="params">(NOLOAD)</span> : <span class="title">AT</span> <span class="params">( ldadr )</span></span></span><br><span class="line"><span class="function">&gt;</span>{ contents } &gt;region :phdr =fill</span><br><span class="line">&gt;...</span><br><span class="line">&gt;}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，secname和contents是必须的，前者用来命名这个段，后者用来确定代码中的什么部分放在这个段，以下是对这个描述中的一些关键字的解释。</p>
<ul>
<li>secname：段名</li>
<li>contents：决定哪些内容放在本段，可以是整个目标文件（如start.o），也可以是目标- 文件中的某段（代码段、数据段等）（如start.o (.text .rodata)）</li>
<li>start：是段的重定位地址，本段链接（运行）的地址，如果代码中有位置无关指令，程序运行时这个段必须放在这个地址上。start可以用任意一种描述地址的符号来描述。<br>  AT（ldadr）：定义本段存储（加载）的地址，如果不使用这个选项，则加载地址等于运行地址，通过这个选项可以控制各段分别保存于输出文件中不同的位置。</li>
</ul>
</blockquote>
<p>上面我们了解到lds文件的格式之后，就可以直接阅读下面的lds文件， <code>. = 0x00000000;</code>定义当前位置为<code>0x00000000</code>; 紧接着<code>.text:{...}</code>，所以.text的相对地址也是0，而在.text中<code>*(.__image_copy_start)</code>又在开始的位置，也就是说把我们前面定义的<code>.__image_copy_start</code>段在链接的时候挪到这个位置当前位置（0x0），紧接着<code>arch/arm/cpu/armv7/start.o (.text*)</code> 将<code>arch/arm/cpu/armv7/start.o</code>中的<code>.text*</code>段全部挪到当前位置（当前位置为 0x0 + <code>.__image_copy_start</code>大小），后面也是如此。</p>
<p>…</p>
<p>将<code>.__image_copy_end</code>挪到<code>.image_copy_end</code>段。所以从<code>.__image_copy_start</code>到<code>.__image_copy_end</code>包括了代码段、只读数据段、读写数据段、<code>.u_boot_list</code>(uboot的命令)。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(<span class="string">"elf32-littlearm"</span>, <span class="string">"elf32-littlearm"</span>, <span class="string">"elf32-littlearm"</span>)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">{</span><br><span class="line"> . = <span class="number">0x00000000</span>;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .text :</span><br><span class="line"> {</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  arch/arm/cpu/armv7/start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> }</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .data : {</span><br><span class="line">  *(.data*)</span><br><span class="line"> }</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> . = .;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .u_boot_list : {</span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line"> }</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .image_copy_end :</span><br><span class="line"> {</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> }</span><br><span class="line"> .rel_dyn_start :</span><br><span class="line"> {</span><br><span class="line">  *(.__rel_dyn_start)</span><br><span class="line"> }</span><br><span class="line"> .rel.dyn : {</span><br><span class="line">  *(.rel*)</span><br><span class="line"> }</span><br><span class="line"> .rel_dyn_end :</span><br><span class="line"> {</span><br><span class="line">  *(.__rel_dyn_end)</span><br><span class="line"> }</span><br><span class="line"> .end :</span><br><span class="line"> {</span><br><span class="line">  *(.__end)</span><br><span class="line"> }</span><br><span class="line"> _image_binary_end = .;</span><br><span class="line"> . = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> .mmutable : {</span><br><span class="line">  *(.mmutable)</span><br><span class="line"> }</span><br><span class="line"> .bss_start __rel_dyn_start (OVERLAY) : {</span><br><span class="line">  KEEP(*(.__bss_start));</span><br><span class="line">  __bss_base = .;</span><br><span class="line"> }</span><br><span class="line"> .bss __bss_base (OVERLAY) : {</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = ALIGN(<span class="number">4</span>);</span><br><span class="line">   __bss_limit = .;</span><br><span class="line"> }</span><br><span class="line"> .bss_end __bss_limit (OVERLAY) : {</span><br><span class="line">  KEEP(*(.__bss_end));</span><br><span class="line"> }</span><br><span class="line"> .dynsym _image_binary_end : { *(.dynsym) }</span><br><span class="line"> .dynbss : { *(.dynbss) }</span><br><span class="line"> .dynstr : { *(.dynstr*) }</span><br><span class="line"> .dynamic : { *(.dynamic*) }</span><br><span class="line"> .plt : { *(.plt*) }</span><br><span class="line"> .interp : { *(.interp*) }</span><br><span class="line"> .gnu.hash : { *(.gnu.hash) }</span><br><span class="line"> .gnu : { *(.gnu*) }</span><br><span class="line"> .ARM.exidx : { *(.ARM.exidx*) }</span><br><span class="line"> .gnu.linkonce.armexidx : { *(.gnu.linkonce.armexidx.*) }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着我们回到代码<code>ldr    r1, =__image_copy_start</code>则是将<code>__image_copy_start</code>的地址取出给到r1，<code>r4=r0-r1</code>,r0为重定位后的代码位置，r1为当前<code>__image_copy_start</code>的位置，那么r4为代码重定位前后的差，也就是<code>重定位的偏移</code>。<code>beq</code>实际上是一个跳转指令<code>b</code>和一个条件变量<code>eq</code>组合起来的，其意思也就是如果相等则跳转到<code>relocate_done</code>。什么意思呢？这个地方怎么可能会相等呢？不对，你在想想，当前代码的起始位置是<code>__image_copy_start</code>，重定位后代码的位置是r0即<code>gd-&gt;relocaddr</code>，当重定位后，当前代码的起始位置是哪呢？不就是<code>gd-&gt;relocaddr</code>，所以此时<code>r0-r1</code>为<code>0</code>，也即满足相等的条件，跳转到<code>relocate_done</code>，不需要重定位（<strong>此处有疑问？该代码上电后会执行两次吗？如果不会执行两次，那么相等这个条件也就不会满足，也就不会有跳转这个分支了。。。。</strong>）。重定位完成后执行xxxxxxx操作后跳出。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	ldr	r1, =__image_copy_start	  /* r1 &lt;- SRC &amp;__image_copy_start */</span><br><span class="line">	subs	r4, r0, r1		       /* r4 &lt;- relocation offset */</span><br><span class="line">	beq	relocate_done		   /* skip relocation */</span><br><span class="line">	ldr	r2, =__image_copy_end    /* r2 &lt;- SRC &amp;__image_copy_end */</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">relocate_done:</span><br><span class="line">#ifdef __XSCALE__</span><br><span class="line">	/*</span><br><span class="line">	 * On xscale, icache must be invalidated and write buffers drained,</span><br><span class="line">	 * even with cache disabled - 4.2.7 of xscale core developer's manual</span><br><span class="line">	 */</span><br><span class="line">	mcr	p15, 0, r0, c7, c7, 0	/* invalidate icache */</span><br><span class="line">	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */</span><br><span class="line">#endif</span><br><span class="line">	...</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></tbody></table></figure>

<p>建议先去寄存器中查看LDM、STM命令以及模式的用法。此时<code>r0=gd-&gt;relocaddr</code>，<code>r1=&amp;__image_copy_start</code>，<code>r2=&amp;__image_copy_end</code></p>
<p>此处从r1地址开始，将数据拷贝r10、r11，每次拷贝后r1地址加4，结束后r1的值为刚开始的值+8。</p>
<p>然后此处从r0地址开始，将r10、r11寄存器中的值拷贝到r0地址处，每次拷贝结束后r0地址加4，所以，结束后r0的值为刚开始的值+8。</p>
<p>比较r1和r2的值，当r1&lt;r2时，跳转到 <code>copy_loop</code>，继续拷贝。直到r1&gt;=r2时，拷贝结束。此时<code>__image_copy_start</code>至<code>__image_copy_end</code>地址的数据已经拷贝到<code>gd-&gt;relocaddr</code>处了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	...</span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, {r10-r11}		/* copy from source address [r1]    */</span><br><span class="line">	stmia	r0!, {r10-r11}		/* copy to   target address [r0]    */</span><br><span class="line">	cmp	r1, r2			          /* until source end address [r2]    */</span><br><span class="line">	blo	copy_loop</span><br><span class="line">	...</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></tbody></table></figure>



<p>接着 <code>r2=__rel_dyn_start</code>，<code>r3=__rel_dyn_end</code>，从r2处加载数据到r0和r1中，取出r1中数据的低8位，与23比较，如果不相等，跳转到<code>fixnext</code>，比较r2、r3，如果r2&lt;r3，说明没修正结束，接着修正；如果相等，<code>r0=r0+r4</code>，停，r4是什么？大家还有印象不，前面我们在刚进入<code>relocate_code</code>，r4为重定位前后的代码的相对地址偏移。所以代码的意思就是r0=r0+r4，然后以r0中存的值为地址取出 已拷贝到新地址的.text段中的值；将该值加上新旧.text段的偏移，在写回到 新的.text段中。这样就完成了重定位。<strong>此处需明白重定位，到底重定位的是什么？</strong></p>
<p>代码解释完了，但是这又是什么意思啊？完全不理解，从<code>.rel.dyn</code>取出的是什么值啊，接下来我们了解了解<code>.rel.dyn</code>段，之后在回来看这段代码，应该就一目了然了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">ENTRY(relocate_code)</span><br><span class="line">	...</span><br><span class="line">	/*</span><br><span class="line">	 * fix .rel.dyn relocations</span><br><span class="line">	 */</span><br><span class="line">	ldr	r2, =__rel_dyn_start	/* r2 &lt;- SRC &amp;__rel_dyn_start */</span><br><span class="line">	ldr	r3, =__rel_dyn_end	/* r3 &lt;- SRC &amp;__rel_dyn_end */</span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, {r0-r1}		/* (r0,r1) &lt;- (SRC location,fixup) */</span><br><span class="line">	and	r1, r1, #0xff</span><br><span class="line">	cmp	r1, #23			/* relative fixup? */</span><br><span class="line">	bne	fixnext</span><br><span class="line"></span><br><span class="line">	/* relative fix: increase location by offset */</span><br><span class="line">	add	r0, r0, r4</span><br><span class="line">	ldr	r1, [r0]</span><br><span class="line">	add	r1, r1, r4</span><br><span class="line">	str	r1, [r0]</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3</span><br><span class="line">	blo	fixloop</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line">	...</span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p><code>.rel.dyn</code>  存放<code>.text</code>段中需要重定位地址的集合</p>
<p>接下来我们来说明一个很重要的概念。</p>
<p>　u-boot在启动过程中，会把自己拷贝到RAM的顶端去执行。这一拷贝带来的问题是执行地址的混乱。代码的执行地址通常都是在编译时有链接地址指定的，如何保证拷贝前后都可以执行呢？<br>　　一个办法是使用拷贝到RAM后的地址作为编译时的链接地址，拷贝前所有函数与全局变量的调用都增加偏移量。（如VxWorks的bootloader）尽量减少拷贝前需要执行的代码量。<br>　　另一个办法是把image编译成与地址无关的程序，也就是PIC - Position independent code。编译器无法保证代码的独立性，它需要与加载器配合起来。U-boot自己加载自己，所以它自己就是加载器。PIC依赖于下面两种技术：<br>1） 使用相对地址<br>2） 加载器可以自动更新涉及到绝对地址的指令<br>　　对于PowerPC架构，u-boot只是在编译时使用了-fpic，这种方式会生成一个.got段来存储绝对地址符号。对于ARM架构，则是在编译时使用-mword-relocations，生成与位置无关代码，链接时使用-pie生成.rel.dyn段，该段中的每个条目被称为一个LABEL，用来存储绝对地址符号的地址。</p>
<p>为了理解地址表的概念我们分析一段代码。</p>
<p>借助两个工具 <code>readelf</code>、<code>objdump</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131923808.png"></p>
<p>通过readelf的<code>-r</code>选项查看<code>relocate段</code>，<code>readelf -r u-boot | less</code>打开，看到类型是可重定位段，其中有了<code>offset、info、type</code>以及后面没有为空的项。m每个需要修改地址的信息占用8个字节，第一个为可重定位的地址，第二个为0x17，0x17对应的是Arm32位。那么让我们看一下第一条可重定位地址处（0x20000020）放的是什么？<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204132024704.png"></p>
<p>通过命令 <code>objdump -S u-boot | less</code> ，看到此处存的正是 start.S 中<code>_undefined_instruction: .word undefined_instruction</code>入口地址。</p>
<p>因为这个入口地址如果直接.text段拷贝过去，将来执行跳转的还是旧的uboot里面的undefined_instruction，而不是我们新uboot里面的undefined_instruction，所以这个要修改。</p>
<p>即要修改所有位置有关码的地址。</p>
<p>如何修改？</p>
<p>很简单，<strong>旧的地址的值是什么我们取出来加上 新地址和旧地址的偏移，然后存入新的地址就可以了</strong>。</p>
<p>因为编译器已经帮我们剥离出来要修改的地址和它所属的类型，存放进了rel.dyn段，所以我们只要修改新地址的就可以。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131932905.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204131936214.png"></p>
</blockquote>
<p>未定义__ARM_ARCH_4__，所以执行<code>bx lr</code>，而此时<code>lr</code>中的值为<code>here + gd-&gt;reloc_off</code>，怎么解释？此时重定位已经完成，重定位后的地址差值为<code>gd-&gt;reloc_off</code>，<code>here</code> 为<code>here</code>处的相对地址，所以<strong>二者相加后为重定位后的<code>here</code>处的地址</strong>，然后跳回去。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/relocate.S</span><br><span class="line">/* ARMv4- don't know bx lr but the assembler fails to see that */</span><br><span class="line"></span><br><span class="line">#ifdef __ARM_ARCH_4__</span><br><span class="line">	mov        pc, lr</span><br><span class="line">#else</span><br><span class="line">	bx        lr</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>



<h4 id="main-继续，接上文：here"><a href="#main-继续，接上文：here" class="headerlink" title="_main 继续，接上文：here"></a>_main 继续，接上文：here</h4><p>回到<code>here</code>处开始跳转到 <code>c_runtime_cpu_setup</code>，<code>c_runtime_cpu_setup</code>执行结束后返回。</p>
<p>继续执行<code>r0 = __bss_start</code>，<code>r1 = __bss_end</code>，<code>r2 = 0</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">here:</span><br><span class="line"></span><br><span class="line">/* Set up final (full) environment */</span><br><span class="line"></span><br><span class="line">	bl	c_runtime_cpu_setup	/* we still call old routine here */</span><br><span class="line"></span><br><span class="line">	ldr	r0, =__bss_start	/* this is auto-relocated! */</span><br><span class="line">	ldr	r1, =__bss_end		/* this is auto-relocated! */</span><br><span class="line"></span><br><span class="line">	mov	r2, #0x00000000		/* prepare zero to clear BSS */</span><br></pre></td></tr></tbody></table></figure>

<p>将<code>[__bss_start,__bss_end]</code>范围内的内存清零。</p>
<p>比较<code>r0</code>和<code>r1</code>的值，首先<code>r0=r0-r1</code>,当满足条件<code>r0&lt;r1</code>时，将<code>r2</code>中的值0复制给以将<code>r0</code>的值作为地址的内存中，当满足条件<code>r0&lt;r1</code>时，<code>r0=r0+4</code>，当满足条件<code>r0&lt;r1</code>时，跳转到<code>clbss_l</code>处。接着循环，知道二者相等时，不满足条件，继续执行<code>bl coloured_LED_init</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line"></span><br><span class="line">clbss_l:cmp	r0, r1			/* while not at end of BSS */</span><br><span class="line">	strlo	r2, [r0]		/* clear 32-bit BSS word */</span><br><span class="line">	addlo	r0, r0, #4		/* move to next */</span><br><span class="line">	blo	clbss_l</span><br></pre></td></tr></tbody></table></figure>



<p>跳转到coloured_LED_init，跳转到red_led_on，没啥内容。主要关注一下语法即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">    </span><br><span class="line">	bl coloured_LED_init</span><br><span class="line">	bl red_led_on</span><br><span class="line">------------------------------</span><br><span class="line">// common/board_f.c</span><br><span class="line">inline void __coloured_LED_init(void) {}</span><br><span class="line">void coloured_LED_init(void)</span><br><span class="line">        __attribute__((weak, alias("__coloured_LED_init")));</span><br><span class="line">inline void __red_led_on(void) {}</span><br><span class="line">void red_led_on(void) __attribute__((weak, alias("__red_led_on")));</span><br></pre></td></tr></tbody></table></figure>



<p><code>r0 = r9 = gd</code>，<code>r1 = [r9(gd) + GD_RELOCADDR]</code>，也就是说<code>r0</code>此时为<code>gd</code>,<code>r1</code>为相对于<code>gd</code>偏移<code>GD_RELOCADDR</code>的地址中的值。</p>
<p>将<code>pc</code>值更改为<code>board_init_r</code>，也就是跳转到<code>board_init_r</code>执行，此处不需要返回。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/lib/crt0.S</span><br><span class="line">	/* call board_init_r(gd_t *id, ulong dest_addr) */</span><br><span class="line">	mov     r0, r9                  /* gd_t */</span><br><span class="line">	ldr	r1, [r9, #GD_RELOCADDR]		/* dest_addr */</span><br><span class="line">	/* call board_init_r */</span><br><span class="line">	ldr	pc, =board_init_r	/* this is auto-relocated! */</span><br><span class="line"></span><br><span class="line">	/* we should not return here. */</span><br></pre></td></tr></tbody></table></figure>

<p>到此 <code>_main</code>就结束了。</p>
<h4 id="c-runtime-cpu-setup"><a href="#c-runtime-cpu-setup" class="headerlink" title="c_runtime_cpu_setup"></a>c_runtime_cpu_setup</h4><p><code>c_runtime_cpu_setup</code>位于 <code>arch/arm/cpu/armv7/start.S</code>，</p>
<p><strong>TODO：待补充</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; arch/arm/cpu/armv7/start.S</span><br><span class="line">ENTRY(c_runtime_cpu_setup)</span><br><span class="line">/*</span><br><span class="line"> * If I-cache is enabled invalidate it</span><br><span class="line"> */</span><br><span class="line">#ifndef CONFIG_SYS_ICACHE_OFF</span><br><span class="line">	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache</span><br><span class="line">	mcr     p15, 0, r0, c7, c10, 4	@ DSB</span><br><span class="line">	mcr     p15, 0, r0, c7, c5, 4	@ ISB</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * Move vector table</span><br><span class="line"> */</span><br><span class="line">	/* Set vector address in CP15 VBAR register */</span><br><span class="line">	ldr     r0, =_start</span><br><span class="line">	mcr     p15, 0, r0, c12, c0, 0  @Set VBAR</span><br><span class="line"></span><br><span class="line">	bx	lr</span><br><span class="line"></span><br><span class="line">ENDPROC(c_runtime_cpu_setup)</span><br></pre></td></tr></tbody></table></figure>



<h4 id="board-init-r"><a href="#board-init-r" class="headerlink" title="board_init_r"></a>board_init_r</h4><p><strong>board_init_r</strong>函数位于<code>common/board_r.c</code>中，</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *new_gd, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_X86</span></span><br><span class="line">	gd = new_gd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NEEDS_MANUAL_RELOC</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(init_sequence_r); i++)</span><br><span class="line">		init_sequence_r[i] += gd-&gt;reloc_off;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcall_run_list(init_sequence_r))</span><br><span class="line">		hang();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* NOTREACHED - run_main_loop() does not return */</span></span><br><span class="line">	hang();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>TODO：待补充</strong>分析这个函数，这也太麻烦了。。。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/u-boot/boot_flow_1.html">wowo的u-boot启动流程分析（1）平台相关部分_</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ooonebook/category_6471981.html">ooonebook大佬的project-X系列</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ooonebook/category_6484145.html">ooonebook大佬的u-boot系列</a></li>
<li> <a target="_blank" rel="noopener" href="https://github.com/limingth/ARM-Resources/blob/master/tiny210/Datasheet/S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf">S5PV210_iROM_ApplicationNote_Preliminary_20091126.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/limingth/ARM-Resources/blob/master/tiny210/Datasheet/S5PV210_UM_REV1.1.pdf">S5PV210_UM_REV1.1.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://re-eject.gbadev.org/files/GasARMRef.pdf">https://re-eject.gbadev.org/files/GasARMRef.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_55796564/article/details/119949722">第三十二章 U-Boot启动流程详解 -摘自【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.0</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012176730/article/details/54670569">嵌入式Linux学习：u-boot源码分析（1）–AM335X系列的2014.10版</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40531974/article/details/83897559">ARM汇编指令集汇总</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouqt/article/details/78172332">ARM指令CMP详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zackary/p/9343253.html"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zackary/p/9343253.html">ARM 汇编指令 ADR 与 LDR 使用 </a></li>
<li><a target="_blank" rel="noopener" href="https://0uyangsheng.github.io/2018/04/25/Deep-into-Rk3399-uboot/">谈谈 U-boot 启动流程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzxb1995/article/details/103458589">u-boot-2019.10源码分析——init_sequence_f中的函数</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/skyflying2012/article/details/39005705">uboot环境变量实现分析</a></li>
<li><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/Scripts.html">LD脚本</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ec39403db315">u-boot.lds链接文件详解</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-23193900-id-3251565.html">Arm汇编指令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0c6192da2fd0">ARM汇编之解惑条件标志，条件码，条件执行</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16777851/article/details/81749077">从零开始之uboot、移植uboot2017.01 @奔跑的小刺猬</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">lj gong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gonglja.github.io/posts/f88e6d17/">http://gonglja.github.io/posts/f88e6d17/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gonglja.github.io" target="_blank">Gong's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/eeea93b8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TEST</div></div></a></div><div class="next-post pull-right"><a href="/posts/d78cdbc6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://archlinux.org/static/logos/archlinux-logo-dark-1200dpi.b42bd35d5916.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Archlinux从安装到使用（持续更新中）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111228921.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lj gong</div><div class="author-info__description">蓬生麻中，不扶而直，白沙在涅，与之俱黑。</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Gonglja"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/gonglja" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:glj0@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">2022重新出发！加油加油</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#u-boot-2014-04-%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">u-boot-2014.04 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#s5pv210"><span class="toc-number">1.1.</span> <span class="toc-text">s5pv210</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">芯片启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BL0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">BL0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BL1"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">BL1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BL2"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">BL2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">地址映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u-boot"><span class="toc-number">1.2.</span> <span class="toc-text">u-boot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">编译问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">错误1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2022%E4%B8%AD%E7%9A%84-start%E4%B8%8D%E7%9C%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">2022中的_start不看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">_start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-init-cp15"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">cpu_init_cp15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-init-crit"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">cpu_init_crit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lowlevel-init-%E5%88%86%E6%9E%90%E9%94%99%E8%AF%AF"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">lowlevel_init(分析错误)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lowlevel-init"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">lowlevel_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">_main</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-bl2-to-ram"><span class="toc-number">1.3.4.8.</span> <span class="toc-text">copy_bl2_to_ram</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#board-init-f"><span class="toc-number">1.3.4.9.</span> <span class="toc-text">board_init_f</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#global-data"><span class="toc-number">1.3.4.9.1.</span> <span class="toc-text">global_data</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arch-cpu-init"><span class="toc-number">1.3.4.9.2.</span> <span class="toc-text">arch_cpu_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mark-bootstage"><span class="toc-number">1.3.4.9.3.</span> <span class="toc-text">mark_bootstage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fdtdec-check-fdt"><span class="toc-number">1.3.4.9.4.</span> <span class="toc-text">fdtdec_check_fdt</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#board-early-init-f"><span class="toc-number">1.3.4.9.5.</span> <span class="toc-text">board_early_init_f</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#timer-init"><span class="toc-number">1.3.4.9.6.</span> <span class="toc-text">timer_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#board-postclk-init"><span class="toc-number">1.3.4.9.7.</span> <span class="toc-text">board_postclk_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get-clocks"><span class="toc-number">1.3.4.9.8.</span> <span class="toc-text">get_clocks</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#env-init"><span class="toc-number">1.3.4.9.9.</span> <span class="toc-text">env_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#init-baudrate"><span class="toc-number">1.3.4.9.10.</span> <span class="toc-text">init_baudrate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#serial-init"><span class="toc-number">1.3.4.9.11.</span> <span class="toc-text">serial_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#console-init-f"><span class="toc-number">1.3.4.9.12.</span> <span class="toc-text">console_init_f</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#display-banner"><span class="toc-number">1.3.4.9.13.</span> <span class="toc-text">display_banner</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#print-cpuinfo"><span class="toc-number">1.3.4.9.14.</span> <span class="toc-text">print_cpuinfo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#checkboard"><span class="toc-number">1.3.4.9.15.</span> <span class="toc-text">checkboard</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#init-func-i2c"><span class="toc-number">1.3.4.9.16.</span> <span class="toc-text">init_func_i2c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dram-init"><span class="toc-number">1.3.4.9.17.</span> <span class="toc-text">dram_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">1.3.4.9.18.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E7%BB%A7%E7%BB%AD%EF%BC%8C%E6%8E%A5%E4%B8%8A%E6%96%87"><span class="toc-number">1.3.4.10.</span> <span class="toc-text">_main 继续，接上文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#relocate-code"><span class="toc-number">1.3.4.11.</span> <span class="toc-text">relocate_code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E7%BB%A7%E7%BB%AD%EF%BC%8C%E6%8E%A5%E4%B8%8A%E6%96%87%EF%BC%9Ahere"><span class="toc-number">1.3.4.12.</span> <span class="toc-text">_main 继续，接上文：here</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-runtime-cpu-setup"><span class="toc-number">1.3.4.13.</span> <span class="toc-text">c_runtime_cpu_setup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#board-init-r"><span class="toc-number">1.3.4.14.</span> <span class="toc-text">board_init_r</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3b31c731/" title="c语言中给定一个函数地址如何调用呢？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111548715.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言中给定一个函数地址如何调用呢？"/></a><div class="content"><a class="title" href="/posts/3b31c731/" title="c语言中给定一个函数地址如何调用呢？">c语言中给定一个函数地址如何调用呢？</a><time datetime="2022-04-11T07:48:18.000Z" title="发表于 2022-04-11 15:48:18">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eeea93b8/" title="TEST"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TEST"/></a><div class="content"><a class="title" href="/posts/eeea93b8/" title="TEST">TEST</a><time datetime="2022-04-11T04:16:45.000Z" title="发表于 2022-04-11 12:16:45">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f88e6d17/" title="u-boot-2014.04 分析（未完待续）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204082006861.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="u-boot-2014.04 分析（未完待续）"/></a><div class="content"><a class="title" href="/posts/f88e6d17/" title="u-boot-2014.04 分析（未完待续）">u-boot-2014.04 分析（未完待续）</a><time datetime="2022-03-29T01:33:08.000Z" title="发表于 2022-03-29 09:33:08">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d78cdbc6/" title="Archlinux从安装到使用（持续更新中）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://archlinux.org/static/logos/archlinux-logo-dark-1200dpi.b42bd35d5916.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Archlinux从安装到使用（持续更新中）"/></a><div class="content"><a class="title" href="/posts/d78cdbc6/" title="Archlinux从安装到使用（持续更新中）">Archlinux从安装到使用（持续更新中）</a><time datetime="2022-03-25T08:31:48.000Z" title="发表于 2022-03-25 16:31:48">2022-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/74f0a0fa/" title="GS87D键盘说明书"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Gonglja/imgur/img/202204111243846.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GS87D键盘说明书"/></a><div class="content"><a class="title" href="/posts/74f0a0fa/" title="GS87D键盘说明书">GS87D键盘说明书</a><time datetime="2022-03-22T12:46:51.000Z" title="发表于 2022-03-22 20:46:51">2022-03-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By lj gong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'cf6d7d2674b768ef1bf7',
      clientSecret: 'a8254412e77947a4ff26d08ce7af7b5853efbb44',
      repo: 'gonglja.github.io',
      owner: 'Gonglja',
      admin: ['Gonglja'],
      id: '927bcc1d0a6a057c311dda4e328110e5',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>